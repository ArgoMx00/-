今天我们依旧抛开地形的美观问题。尝试开始创建河床。

一、功能描述

①尝试用鼠标点击一定量的地形点之后，在这些点构成的路径上，构成一条河床出来。

②当然我们肯定不能一边点击地形就随意将地形凹陷下去没有规律的去做，所以我们尝试点击足够多的点之后，按动键盘上的空格键之后。再构建出凹槽。
</br></br>

二、首先收集点选的点，将其集合进行存储并且初步处理。

①我们首先点选一部分点，然后按下空格键之后，首先将点选到的点按照高度排序，然后输出所有点的信息进行检阅。
因为当前选定的点的数量是有限的，我们先为了节省编码时间，使用冒泡排序的方法来排序。

代码有：

```c#
/*
任务目标：
将点选出来的点收集起来，然后按照高度排序后，输出。
*/
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class DynamicCreateTerrain : MonoBehaviour {
    //注意重新将脚本拖入GameObject的时候，将初始化的东西都要初始化一下。
    //首先我们需要采集地形信息，所以我们首先创建出来一个terrainData
    //用来存储需要采集的地形的信息。
    //TerrainData类中元素：http://www.manew.com/youxizz/2763.html
    public TerrainData terrainData;
    //用于存地形高度图的
    private float[,] heightmaps;

    //得到在代码中的长和宽。
    int width;
    int height;
    
    //鼠标点击的点
    Vector3 P;
    //实际地形图中的信息：
    public int realWidth;
    public int realheight;
    public int heightResolution;

    //用于保存收集点的信息
    int cnt;
    Vector3[] m_vp3River = new Vector3[10000];
    void Start()
    {
        cnt = 0;
        GetHeightmaps();
       // Change();
    }
    void GetP(Vector3 P)
    {
        print("调用成功,得到鼠标点击点：  "+(int)P.x+" -- "+(int)P.y+" -- "+(int)P.z);
        //拿到点选的点的信息之后，我们将其保存起来。
        m_vp3River[cnt].x = P.x;
        m_vp3River[cnt].y = P.y;
        m_vp3River[cnt].z = P.z;
        cnt++;
    }
    //将点选的点周围15x15的格子统一提升一定量高度。
    void RegularUpTerrain(Vector3 P)
    {
        float Bilv1 = (float)(heightResolution) / (float)(realWidth);
        float Bilv2 = (float)(heightResolution) / (float)(realheight);
        int tx = (int)(P.x * Bilv1);
        int tz = (int)(P.z * Bilv2);

        //接下来需要通过计算来得到点的高度图横纵坐标。
        print(tx + "----------------" + tz);
        GetHeightmaps();
        for (int i = -15; i <= 15; i++)
        {
            for (int j = -15; j <= 15; j++)
            {
                int xx = tx + i;
                int zz = tz + j;
                if (xx >= 0 && xx < width && zz >= 0 && zz < height)
                {
                    //坐标在实际展示中是反着的。
                    heightmaps[zz, xx] += 0.01f;
                }
            }
        }
        //设置高度图
        terrainData.SetHeights(0, 0, heightmaps);
    }
    //得到当前地形的高度图。
    void GetHeightmaps()
    {
        width = terrainData.heightmapWidth;
        height = terrainData.heightmapHeight;
        heightmaps = terrainData.GetHeights(0, 0, width, height);
        //print(width + "---" + height);
    }
    //将指定范围内点提升到指定高度。
    void Change()
    {
        for (int i = 300; i < 350; i++)
        {
            for (int j = 300; j < 350; j++)
            {
                heightmaps[i, j] = 0.9f;
            }
        }
        terrainData.SetHeights(0, 0, heightmaps);
    }
    private void Update()
    {
        if(Input.GetKey(KeyCode.Space))
        {
            //我们应该先将收集到的所有点按照高度排序。考虑到当前点的个数不多，我们先按照冒泡排序去处理、
            //将数组高度处理为递减数组（地势高的放在数组前边）。
            for(int i=0;i<cnt;i++)
            {
                for(int j=i;j<cnt;j++)
                {
                    if(j+1<cnt&&j<cnt)
                    {
                        if(m_vp3River[j].y < m_vp3River[j+1].y)
                        {
                            Vector3 Temp;
                            Temp = m_vp3River[j];
                            m_vp3River[j] = m_vp3River[j+1];
                            m_vp3River[j + 1] = Temp;
                        }
                        
                    }
                }
            }
            print("所有点选点的信息：");
            for (int i = 0; i < cnt; i++)
            {
                print(m_vp3River[i].x + " - " + m_vp3River[i].y + " - " + m_vp3River[i].z);
            }
        }
    }
}

```

运行效果：
![](https://i.loli.net/2018/06/02/5b11f53058ef9.png)

②接下来我们将点选出来的点将其下降一半的河流深度。然后反馈到地形中，展示出来。
同时美化一下代码（随着功能数量的提升，代码分块美化还是需要一哈的。）

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class DynamicCreateTerrain : MonoBehaviour {

    /********************************************************************/
    //注意重新将脚本拖入GameObject的时候，将初始化的东西都要初始化一下。
    //首先我们需要采集地形信息，所以我们首先创建出来一个terrainData
    //用来存储需要采集的地形的信息。
    //TerrainData类中元素：http://www.manew.com/youxizz/2763.html
    public TerrainData terrainData;
    //用于存地形高度图的
    private float[,] heightmaps;

    //得到在代码中的长和宽。
    int width;
    int height;

    //鼠标点击的点
    Vector3 P;
    //实际地形图中的信息：
    //地形宽度、地形长度、地形高度、地形分辨率。
    public int realWidth;
    public int realLength;
    public int realHeight;
    public int heightResolution;
    /********************************************************************/





    /********************************************************************/
    //用于保存收集点的信息
    int cnt;
    Vector3[] m_vp3River = new Vector3[10000];
    //河流的深度
    public int RiverDepth;
    /********************************************************************/





    /********************************************************************/
    void Start()
    {
        cnt = 0;
        GetHeightmaps();
       // Change();
    }
    private void Update()
    {
        if (Input.GetKey(KeyCode.Space))
        {
            Psort();
            FirstUpdateRiver();
        }
    }
    //得到当前地形的高度图。
    void GetHeightmaps()
    {
        width = terrainData.heightmapWidth;
        height = terrainData.heightmapHeight;
        heightmaps = terrainData.GetHeights(0, 0, width, height);
        //print(width + "---" + height);
    }
    //得到鼠标点选的点。
    void GetP(Vector3 P)
    {
        print("调用成功,得到鼠标点击点：  "+(int)P.x+" -- "+(int)P.y+" -- "+(int)P.z);
        //拿到点选的点的信息之后，我们将其保存起来。
        m_vp3River[cnt].x = P.x;
        m_vp3River[cnt].y = P.y;
        m_vp3River[cnt].z = P.z;
        cnt++;
    }
    /********************************************************************/





    /********************************************************************/
    //测试功能
    //将点选的点周围15x15的格子统一提升一定量高度。
    void RegularUpTerrain(Vector3 P)
    {
        int tx = GetiX(P);
        int tz = GetiZ(P);
        //接下来需要通过计算来得到点的高度图横纵坐标。
        print(tx + "----------------" + tz);
        GetHeightmaps();
        for (int i = -15; i <= 15; i++)
        {
            for (int j = -15; j <= 15; j++)
            {
                int xx = tx + i;
                int zz = tz + j;
                if (xx >= 0 && xx < width && zz >= 0 && zz < height)
                {
                    //坐标在实际展示中是反着的。
                    heightmaps[zz, xx] += 0.01f;
                }
            }
        }
        //设置高度图
        terrainData.SetHeights(0, 0, heightmaps);
    }
    //将指定范围内点提升到指定高度。
    void Change()
    {
        for (int i = 300; i < 350; i++)
        {
            for (int j = 300; j < 350; j++)
            {
                heightmaps[i, j] = 0.9f;
            }
        }
        terrainData.SetHeights(0, 0, heightmaps);
    }
    /********************************************************************/





    /********************************************************************/
    //初步处理出河床
    //首先将所有采集到的点按照高度排序。
    void Psort()
    {
        //我们应该先将收集到的所有点按照高度排序。考虑到当前点的个数不多，我们先按照冒泡排序去处理、
        //将数组高度处理为递减数组（地势高的放在数组前边）。
        for (int i = 0; i < cnt; i++)
        {
            for (int j = i; j < cnt; j++)
            {
                if (j + 1 < cnt && j < cnt)
                {
                    if (m_vp3River[j].y < m_vp3River[j + 1].y)
                    {
                        Vector3 Temp;
                        Temp = m_vp3River[j];
                        m_vp3River[j] = m_vp3River[j + 1];
                        m_vp3River[j + 1] = Temp;
                    }

                }
            }
        }
        print("所有点选点的信息：");
        for (int i = 0; i < cnt; i++)
        {
            print(m_vp3River[i].x + " - " + m_vp3River[i].y + " - " + m_vp3River[i].z);
        }
    }

    //初步保证河流高度不可逆
    void FirstUpdateRiver()
    {
        for(int i=0;i<cnt;i++)
        {
            int tx = GetiX(m_vp3River[i]);
            int tz = GetiZ(m_vp3River[i]);
            m_vp3River[i].y -= RiverDepth / 2.0f;
            if(i>0&&m_vp3River[i].y>=m_vp3River[i-1].y)
            {
                m_vp3River[i].y = m_vp3River[i - 1].y - 0.01f*realHeight;
            }
            float ty = GetiY(m_vp3River[i]);
            heightmaps[tz, tx] = ty;
        }
        terrainData.SetHeights(0, 0, heightmaps);
    }
    /********************************************************************/





    /********************************************************************/
    //将地形图的点换算为代码中的（x，y，z）；
    int GetiX(Vector3 P)
    {
        float Bilv1 = (float)(heightResolution) / (float)(realWidth);
        int tx = (int)(P.x * Bilv1);
        return tx;
    }
    int GetiZ(Vector3 P)
    {
        float Bilv2 = (float)(heightResolution) / (float)(realLength);
        int tz = (int)(P.z * Bilv2);
        return tz;
    }
    float GetiY(Vector3 P)
    {
        float Bilv3 = 1.0f / (float)(realHeight);
        float ty = P.y * Bilv3;
        return ty;
    }
    /********************************************************************/

}

```

实际运行效果图：

![](https://i.loli.net/2018/06/02/5b11ff115c9de.png)

</br></br></br></br>


