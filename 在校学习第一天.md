关于GameDev上实例的参考学习：

一、任务背景：
在开放的景观游戏中，河流可以为地形的外观增添逼真的触感。
我将讨论一种将河流添加到随机生成的地形的方法，该方法增加了我们正在寻找的这种逼真的触感。 
不幸的是，当我们处理随机地形时，这并不总是一项琐碎的任务。
在现实生活中，地形通常通过在陆地上雕刻出水并形成山谷和其他这样的地形特征来形成。 
然而，当在体面的加载时间产生地形时，我们没有这种奢侈。
我在Full Sail的最后一个项目是一个名为列日的实时战术游戏，随机生成河流地形。 
在整篇文章中，我将讨论我为列日创建河流所采用的方法。

二、任务关键（算法的关键部分）：

1.用于确定河流路径的路径搜索算法。

2.一种算法来清理河流周围的地形。

3.河床雕刻算法。

三、关于路径：

①路径是整个过程的关键部分，因为一条不遵循现实路径的河流不会和真实的河流一样。
为了达到目的，我们要做的第一件事就是创建地图上所有边缘顶点的高度排序数组。
为了确保我们将选择一条尽可能下坡的路径，我们将随机的去选取边缘顶点。那么我们在
高度排序数组中，取起点在前五分之三高的边缘顶点中的随机一个。然后再取终点在后五分之一
矮的边缘顶点中的随机一个。那么此时我们就得到了起点和终点。如果我们的地图比较小的话
建议我们在选取起点和终点的时候，将其选择在相反的边缘的两个点作为起点和终点。

②现在我们有了河流的起点和终点，我们需要一种计算路径的方法，要做到这一点，
我们将利用我们的优势，即水承受重力的影响。改变一个简单的“最好”的路径寻找算法。
使用一种启发式算法来衡量相邻节点的高度，以便与目标保持距离，我们可以得到一条
相当实际的路径。

③已经形成的路径会出现几个问题。路径的第一个问题是，地形并非由河流组成，因此河流
不可能始终从头至尾完成流动。而且甚至有些稍许上坡。我们将需要改变地形，让河流
总是实际向下流动。该路径的另一个问题是，当路径与地图的边缘相交而且在到达其终点之前
当他没有地形行进到地形边缘之外时，它倾向于坚持边缘，并且如果他是驱动到地图的边缘，
然后低于地图的内部，这将导致部分河流“贴”到地图的边缘。


四、清理路径：

①“贴”到地图边缘的丑恶作用之一就是，河流倾向于在碰到边缘时跳跃，然后折断，然后撞击
边缘然后再次折断。有时候它可能看起来像一条跳跃的线，只不过是从某个地方返回的河流，
但在其他时候它看起来很可怕。所以作为一种解决方案，建议我们通过河流节点寻找河流中
的最长的一次跳跃，在我们还没有击中开始和目标节点之间的边缘的情况下，找到这个最长的一跳
一旦我们找到了，将其他所有跳跃节点删除掉即可。

②另外一个问题是啤酒花。河流在地形边缘的河流宽度内的地方，会导致可见的啤酒花。这个问题
很容易解决。我只是穿过河流，测试每个节点相对于地图边缘的相对距离，如果距离太近，我只是将他
向内移动。河流的路径应该看起来足够逼真，推动这些少数节点看起来不会很糟糕。

③现在我们已经完善了实际的路径，我们需要调整路径的高度，目前它正在铺设在地形的表面上。
我们想要坐的是将每个顶点沿着Y轴向下移动到其当前位子减去河流深度的一半或者比先前节点
低的一个点，取其中较为低的点，在这样做的过程中，我们确信河流的路径总是向下流动。
由于我们拥有这样新的高度，因此我们还需要调整每个相应河流顶点的高度图中存储的高度，如果
愿意的话，这样做会刮擦路径进入地形。

④所以我们首要完成的任务，就是要保证路径是精确的、完美的、不可逆高度的。实际解决这部分问题：

```c#
/*
任务目的：
得到一个河流路径所有点点的高度排序数组后
首先将河流路径上的点，统一降低河流深度的一半，首先将其凹陷
继而保证路径是精确的、完美的、不可逆高度的
最后要把所有点的信息转化为高度图坐标
*/
for( i = m_vp3River.size()-1; i >= 0 ; i-- )
{

  //首先我们需要将实际地图高度，转化为高度图坐标
   int iRX = int(m_vp3River[i].x/m_MapInfo.fScale),
      iRZ = int(m_vp3River[i].z/m_MapInfo.fScale);
  
  //然后我们将所有点的高度降低河流深度的一半
  m_vp3River[i].y -= HALFDEPTH*m_MapInfo.fScale;
  
  //接下来我们精确设计河流路径，使得高度不可逆，保证水往低处流。
  if(i < (m_vp3River.size()-1) && m_vp3River[i].y>=m_vp3River[i+1].y)
    m_vp3River[i].y = m_vp3River[i+1].y-(0.01f*m_MapInFO.fScale);
    
  //最后我们再转化为高度图坐标。更新他们的高度。
  m_fHeightMap[iRX][iRZ] = m_vp3River[i].y;
}

```
五、雕刻路径

现在我们有了精致的河道，甚至刮去了路径的基础信息，进入了地形，转化变成了高度图
坐标，接下来我们需要雕刻路径。为了防止突然下降，我们要在河床切入地形之前将河岸
切割成河流的地形。为了实现这个河床，我们遍历了河流节点的列表，并且对于每一个我
们遍历了的方形距离内所有的地形顶点，并且发现从当前河流顶点到当前正在评估的高度
图顶点的线的斜率。如果坡度太高，我们只能减小地形的高度，我们重复这个循环，直到
河流周围的所有地形都处于我们认为合适的高度。重复这个循环的另一种方法可能仅仅是
第一次设定高度，但这往往看起来更人造，而且过于统一。

```c#

/*
任务目的：
重复的对地形进行雕刻、打磨。防止有大坡度下降的部分。
具体做法大概就是将每个点枚举出来，然后判断他矩形范围内的点是否有坡度太大的部分，如果有，修正打磨。
*/
for( i = m_vp3Riversize()-1; i>= 0; i-- )
{
    //地形实际坐标点转化为高度图点
    int iRX = int(m_vp3River[i].x/m_MapInfo.fScale),
        iRZ = int(m_vp3River[i].z/m_MapInfo.fScale);
    
    //重复进行地形雕刻
    bool bAltered = true;
    while( bAltered )    
    {
        //我们在一个矩形中研究当前块中的地形。
        //为了避免突然下降太多的地形，我们将重复打磨雕刻地形
        
        //一开始我们假设当前点不需要重复打磨了
        bAltered = false;
        for(int iX = max(0,iRX-SLOPE_WIDTH);iX < min(m_MapInfo.iSize,iRX+SLOPE_WIDTH); iX++)
        {
            for(int iZ = max(0,iRZ-SLOPE_WIDTH);iZ < min(m_MapInfo.iSize,iRZ+SLOPE_WIDTH); iZ++)
            {
                float fSlope;
                
                //两点坡度计算公式：（两点高度差）/（两点映射到平面后的直线距离【水平距离】）
                //计算两点坡度，如果坡度大于预设坡度，那么我们修改这个点的高度。
                fSlope= (m_fHeightMap[iX][iZ]-m_fHeightMap[iRX][iRZ])/((sqrt((iRX-iX))*(iRX-iX)+(iRZ-iZ)*(iRZ-iZ))*m_MapInfofScale);
                if(fSlope > SLOPE_VAL)
                {
                    //如果确实坡度过大，那么对应减小当前点的高度以保证坡度变小
                    //如果有了修改，那么就要进入循环判断。
                    m_fHeightMap[iX][iZ] -= HEIGHT_ADJ*m_MapInfo.fScale;
                    bAltered = true;
                }
            }
        }
    }
}

```

完成了以上内容之后，这将我们的地形路径，做出了一个很好的V形凹陷。这种洼地的形成，基于我们一开始
将所有的点降低半河流高度。而不是河床底部，如果我们一开始就降低到了河床底部，那么河流的凹陷感也就
做不出来了，所以这就是一开始为什么是降低半河流高度的原因。在河岸的边缘，取决于我们雕刻到的地形有
多远，地形闪可能会出现一些相当严重的下沉。如果河流较长，随着高度逐渐下降，减小、最终累计起来的下
沉越来越严重。现在人们可以利用这种做法的特点，转化为优势，去雕刻大峡谷，但是大峡谷的风格肯定不符
合我们当前讨论的问题，所以这个特点在我们当前情况就是一种劣势，需要我们去克服、去修改。这个问题其
实解决起来也不难。为了解决这个问题，我们只需要循环遍历地形上的每个顶点，并且将其与四个邻居中的每
一个点都进行比较，如果高度变化的太距离，则当前顶点降低到小于允许的最大差值的某个数量。我们不得不
一遍又一遍的重复这个做法去过滤筛选，直到达到预期的效果。在这种做法的情况下，我希望所有突然消失的
水滴不会被磨损，所以我不得不循环直到没有更多的改变。这种方法实际上效率很低，但它不是我装载时间的
瓶颈，但是在更大的地形上有更长的河流，这个做法肯定也会有瓶颈的情况，然而，我们相当自信，一种算法
可以很容易的形成，从河流中不断的拓展，直到一切都满意为止，覆盖整个地形。

一个代码的实例：

/*
任务目的：
随着河流的延长，会造成越来越凹陷的情况发生
我们的任务就是避免过长的河流导致的凹陷
具体的做法就是重复做以下过程：
枚举出每个高度图点，将其相邻
的四个点和当前点进行判断，如果高度差太大，
那么降低当前点的高度。直到达到预期目标为止


个人判断：这份代码应该在上一份代码之前进行。
作为一个地图的预处理。

*/

//首先我们预先设定一个高度差和一个调整高度
//如果高度差过大，那么将其减小一个单位的调整高度。
float fDeltaY = 0.5f*m_MapInfo.fScale;
float fAdjY = 0.3f*m_MapIno.fScale;

bAltered = true;
while( bAltered )
{
    //一开始我们假设已经达到了预期目标
    bAltered = false;
    for(int x = 0;  x < m_MapInfo.iSize-1; x++)
    {
        for(int z = 0; z < m_MapInfo.iSize-1; z++)
        {
            //如果高度差大于了预设高度差，那么将当前点的高度降低一个单位的调整高度
            if(m_fHeightMap[x][z]-m_fHeightMap[x][z+1] > fDeltaY)
            {
                m_fHeightMap[x][z] -= fAdjY;
                bAltered =true ;
            }
            if(m_fHeightMap[x][z]-m_fHeightMap[x+1][z] > fDeltaY)
            {
                m_fHeightMap[x][z] -= fAdjY;
                bAltered =true ;
            }
        }
    }
    for(int x = m_MapInfo.iSize-1;  x > 0; x--)
    {
        for(int z = m_MapInfo.iSize-1; z >0 ; z--)
        {
            //如果高度差大于了预设高度差，那么将当前点的高度降低一个单位的调整高度
            if(m_fHeightMap[x][z]-m_fHeightMap[x][z-1] > fDeltaY)
            {
                m_fHeightMap[x][z] -= fAdjY;
                bAltered =true ;
            }
            if(m_fHeightMap[x][z]-m_fHeightMap[x-1][z] > fDeltaY)
            {
                m_fHeightMap[x][z] -= fAdjY;
                bAltered =true ;
            }
        }
    }
}

























