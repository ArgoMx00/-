
这里我们声明我们的全局变量。第一个声明是COM接口对象。这是我们的SwapChain。用于将后缓冲区更改为前缓冲区。
将前缓冲区更改为后缓冲区。这称为双缓冲。当我们渲染场景的时候。我们渲染到后台缓冲区。所以我们将后台缓冲区呈现
给监视器的时候。他将被完全绘制。否则，我们将获得扫描线，这时我们可以看到我们的程序通常从上到下将我们的场景绘制
到屏幕上。接下来就是我们将用来表示我们的硬件设备的接口。之后的是Dx11附带的新接口。ID3D11Device接口分为两个
部分。以帮助支持新的多线程功能。我们将使用我们的ID3D11DeviceContext接口对象来调用所有渲染的方法。而ID3D11Device
将用于调用与渲染无关的其余方法。

我将更好的解释ID3D11Device分成两部分的原因。DirectX11具有新的多线程功能，用于加速应用程序。当您将某些内容加载到
内存或者创建对象的时候，您将调用ID3D11Device对象。在加载或者创建对象或者模型的时候可以调用ID3D11DeviceContext接口对象以
继续渲染场景。这将在加载模型，创建对象或者类似内容消除性能命中。理解他并不困难，所以我希望你能按照文章所说的去做。

所以，在那之后，我们有另一个接口对象，他是渲染目标视图。基本上，我们不直接写入屏幕，而是写入渲染目标视图。这是一个2D纹理。
然后将此纹理作为渲染目标发送到关岛的输出合并阶段，然后渲染到屏幕。接下来的6行用于改变北京的颜色，对课程并不重要。

```c++
IDXGISwapChain* SwapChain;
ID3D11Device* d3d11Device;
ID3D11DeviceContext* d3d11DevCon;
ID3D11RenderTargetView* renderTargetView;

float red = 0.0f;
float green = 0.0f;
float blue = 0.0f;
int colormodr = 1;
int colormodg = 1;
int colormodb = 1;
```











