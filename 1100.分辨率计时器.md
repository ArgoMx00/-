`介绍`

在这里，我们将学习如何使用QueryPerformanceCounter（）和QueryPerformanceTimer（）函数来实现我们将用于查找每秒帧数的高分辨率性能游戏计时器。
并且使用我们再上一节课中创建的额功能在屏幕上显示他们。我们还将使用这个计时器查找每个帧所需要的时间。并且根据每帧所需时间的更新立方体旋转。无论每秒
的帧数是多少，这将使立方体保持平稳并且以相同的速度旋转。


`新的全局变量`

这些变量用于保持一些全局信息，如FPS何Countertart、

```c++
double countsPerSecond = 0.0;
__int64 CounterStart = 0;

int frameCount = 0;
int fps = 0;

__int64 frameTimeOld = 0;
double frameTime;
```

`新功能和修改功能`

这是我们的函数原型。您可以看到的第一个是UpdateScene（）函数的更新版本。我们将以渲染帧所花费的时间为单位传递，因此我们可以根据时间而不仅仅是FPS更新
场景。接下来我们的rendertext（）函数。我们已经包含了一个新的参数。以便我们可以传入我们的fps。当然，我们已经宣布我们的fps变量是全局的，所以这实际上
只是浪费，但是作者还是想做到这一点，以使得事情变得更加清晰。接下来三个与我们的性能计时器有关。第一个被调用以启用计时器。第二个被调用到自上次调用
starttimer以来的描述。然后我们可以每帧向framecount变量添加一个。并每秒将该值传递给fps变量。然后清除framecount。最后一个新的函数用于获取每帧的
时间。然后我们可以使用返回的值来更新我们的场景，并且保持我们的场景平稳移动并且保持恒定的速度。

```c++
void UpdateScene(double time);

void RenderText(std::wstring text, int inInt);

void StartTimer();
double GetTime();
double GetFrameTime();
```

`定时器功能`

这是我们课程的核心，三个新的计时器功能。

为了得到时间，我们将使用两个win32函数。QueryPerformanceFrequency（）和QueryPerformanceCounter（）。第一个函数返回64位的整数值。表示每秒
的频率或计数。然后我们使用第二个函数来获取计数中的当前时间。该时间也存在64位整数变量中。因此，StartTimer（）函数将频率存储在我们CountsPerSecond
变量中，并且将当前时间存在名为CounterStart变量中。GetTime（）函数使用QueryPerformanceCounter（）获取计数的当前时间，并且将其存储到CurrentTime
的64位整数中。然后我们从CurrentTime值减去CounterStart值，它给出了自上次调用StartTimer（）以来的计数量。然后我们将该数字除以CountsPerSecond变量。
以获得自StartTimer（）函数后一次以来的描述Called，这是GetTime（）函数的返回值。

GetFramTime（）函数基本上执行其他两个函数所做的工作。除了找到自调用StartTimer以来的时间，我们找到自上次调用GetFrameTime（）以来的时间，我们将每
调用一次。这将返回每帧处理所需要的时间，然后我们可以使用这些时间确保我们的相机和动画平滑更新。

```c++
void StartTimer()
{
    LARGE_INTEGER frequencyCount;
    QueryPerformanceFrequency(&frequencyCount);

    countsPerSecond = double(frequencyCount.QuadPart);

    QueryPerformanceCounter(&frequencyCount);
    CounterStart = frequencyCount.QuadPart;
}

double GetTime()
{
    LARGE_INTEGER currentTime;
    QueryPerformanceCounter(&currentTime);
    return double(currentTime.QuadPart-CounterStart)/countsPerSecond;
}

double GetFrameTime()
{
    LARGE_INTEGER currentTime;
    __int64 tickCount;
    QueryPerformanceCounter(&currentTime);

    tickCount = currentTime.QuadPart-frameTimeOld;
    frameTimeOld = currentTime.QuadPart;

    if(tickCount < 0.0f)
        tickCount = 0.0f;

    return float(tickCount)/countsPerSecond;
}
```

`UpdateScene()函数新参数`

time是UpdateScene（）接收的新变量。我们将传入值GetFrameTime（）返回，然后使用time变量更新我们的场景。

`更新旋转`

在我们更新rot之前，我们每帧更新一个常量值。这样做，如果fps只有30.那么立方体会慢慢旋转。因为0.0005f在一秒内只被添加到变量30次。
但是我们fps更大的时候，他就会旋转的更快。

现在我们将更新rot vairable不是静态的值，而是按照渲染帧所需要的时间的1倍。这样在任何一台机器上运行的旋转效果都会很相近。

```c++
rot += 1.0f * time;
```

`RenderText()新参数`

这是我们新的渲染文本函数，带有我们将fps整数传递给的额外参数。

```c++
void RenderText(std::wstring text, int inInt)
```

`添加新的参数，输出其字符串形式`

这里我们将新的数值参数添加到字符串变量中。这样我们可以输出"FPS:数字"

```c++
printString << text <<inInt;
```

同时我们更新显示的文字：

```c++
RenderText(L"FPS: ", fps);
```

接下来向下移动到我们的messageLoop函数。我们再其中实现我们的计时器功能。首先，我们增加frameCount。然后调用GetTime（）函数，看看自上次调用
StartTimer（）函数以来看他是否超过一秒，如果他是一秒或者是更长的时间，我们将fps设置为Framecount。将其设置为0.并且通过调用StartTimer（）重置
启动计时器。

然后我们将frameTime值设置为GetFrameTime（）返回的任何值。这将是自上次调用以来的秒数。然后我们可以使用这个变量来确保无论每秒帧数是多少，我们的
场景都会以相同的速度移动。

你最终会想要暂停函数，他会计算游戏“暂停”的总时间，然后从GetTimer（）函数返回的值中减去该值。当游戏暂停的时候，您还需要跳过更新场景功能并且直接进入
绘制场景功能。然后我们在调用UpdateScene（）函数的时候传递frameTime作为参数。

```c++
        frameCount++;
        if(GetTime() > 1.0f)
        {
            fps = frameCount;
            frameCount = 0;
            StartTimer();
        }    

        frameTime = GetFrameTime();

        UpdateScene(frameTime);
```

















