重要问题点：
1.人物的collider Box没有随着角色的动画进行变化。
2.同步异步更新
3.人物是否可创建在这个位子上的测试。

2019/4/5

`后坐力`√

不同枪械提供不同的横纵后坐力的值。后坐力的值也都是区间随机的。只不过每个枪械提供的后坐力范围不同而已。

`优化客户端枪械体验`√

①当换子弹动画结束之后我们才可以进行射击。

②当子弹库中数量等于0的时候就不要继续换子弹了。

③当枪没有子弹了的时候，发出空弹的声音

`敌人AI`

①关于手上的武器，我们首先固定武器为AK47，创建单独属于敌人的武器，以及单独术语敌人的子弹。

②现在可以按键发射一个子弹打到玩家的脚下了。

2019/4/6

`地图`√

①首先我们应该设定好地图上的一些该有的建筑物

②然后我们应该导出一个01地图，导出01地图的时候，我们只需要导出静态可走以及不可走的地方即可。我们将地形的高点设置为不可走。将静态障碍物设置为不可走。
静态障碍物我们得到其Mesh的顶点结构，加上他的位子就是不可走的地方。

③暂时我准备先创建几个敌人出来先看看效果

`敌人AI的创建`

①首先我们将处理好的01地图，导入到MapLoad.Py中，然后对其进行分析。创建出敌人AI的逻辑。

2019/4/7

`敌人AI的创建`√

①我们现在创建账号的同时，我们创建出了5个敌人AI。然后把这5个敌人AI的信息随着注册的同时，放入数据库。

②当登陆游戏的时候，我们创建角色并查询剩余敌人的数量

③登陆游戏之后，我们要创建出敌人，那么就要查询剩余敌人的Id都是什么，再根据剩余Id创建出敌人才行。

`目前为止的服务器逻辑`√

①注册账号，当注册账号的时候，我们创建出一个玩家，然后同时创建出五个AI敌人出来，同时将他们都插入到数据库中。

②登陆账号：
1.当登陆账号的时候，我们得到账号的字符串、剩余敌人数量，以及玩家Init状态的字典。
2.当进入游戏场景的时候，我们Init玩家的状态，同时查询剩余玩家的数量以及对应的IdArray。然后创建出敌人，并且将他们的Id赋值过去。
3.敌人创建出来的时候，去服务器上查询他们的信息。比如位子和剩余血量等。相当于要Init敌人。

③保存更新角色：
1.我们每一秒发送到服务器一个信息。然后更新角色的血量，枪械子弹数量等。

`预计服务器剩余任务`

①保存敌人信息，也是每一秒保存敌人的信息，当敌人的血量值小于等于0的时候，将其信息从数据库中删除即可。

②敌人寻路请求，当客户端的敌人发出寻路请求的时候，我们在服务端进行寻路。

2019/4/9

`服务器的Update`√

做了一个本地存储的缓存。
后期可以修改为redis。

`客户端可玩性优化`√

做一个准星动态放大的效果

`服务器`

服务器逻辑暂时不进行修改。

客户端全是问题
①如果取消InitEnemy的活性的话，注册、登陆玩家、保存玩家的逻辑没有问题。

`服务器`

①可能是要把之前的代码全部剔除了。

②简化问题就是，选取适当的技术和方法，让两侧的通信是正确的。即两边的通信各自的接收信息和发送信息的逻辑是正确的。

`客户端发送和接收`

客户端发送：一定是从游戏组件发出的。

客户端接收：？

`服务器发送和接收`

服务器发送：？

服务器接收：？

2019/4/12

`服务器`√

①在服务端，使用select.select对读入进行轮询监听。

①服务器端现在已经有的操作模块为：

1.登录模块（需要返回）

2.注册模块（需要返回）

3.查询玩家信息模块（需要返回）

4.更新玩家信息模块（不需要返回，但是尽量返回一个）

5.查询敌人Id Array模块（需要返回）

6.按照Id查询敌人信息模块（需要返回）

7.按照Id更新敌人信息模块（不需要返回，但是尽量也要返回一个）

`服务器测试模拟`

①写一个简单的服务器窗口，使用select.select，完成两个发送功能：每0.5s发送给客户端一个消息，以及如果有接受到的消息，反馈一个信息。

②写一个简单的Unity接收窗口，使用线程的方式将接受到的信息进行集中处理。

`关于通信`

①无论是服务端还是客户端，我们都需要将接收到的消息分开，可能多条消息重叠在了一起。那么每次处理消息的时候都需要一个关于消息队列的循环。

②我们现在可以使用select.select进行对socket的监控，如果有消息发过来，对发来的消息进行集中处理即可。

③服务器可以主动发送消息也可以被动发送消息，无论怎样发送消息，我们都统一进行处理即可。

`服务器更新`√

将接到的信息分成若干个子信息操作了。

2019/4/13

`服务器和客户端的一个Bug`√


接收到的消息不仅仅可能是单独的一条，还有可能是多条，甚至可能是断档的一条消息。需要做一个伪保存。

`服务器AI`

首先学习一下，什么是简单的服务器AI。

现在的选择应该是AI行为树。具体设计如下：

2019/4/15

`服务器AI`√

修改了下线再上线之后无法寻路的bug

`客户端AI`

将客户端的敌人代码控制器中的代码进行了简单的优化。

将客户端的敌人的Mesh Collider 进行了更新，现在的敌人移动的时候，MeshCollider完全贴合着敌人的模型移动了。

将客户端的Player的Mesh Collider 进行了更新，现在玩家移动的时候，Mesh Collider完全贴合着玩家的模型移动了。

`Bug`

如果当我们正在寻路的时候退出了游戏，那么服务器就会出现问题。

极大的修改了可能出现卡顿的情况的优化。

2019/4/17

`近期需要进行的必要功能实现`

敌人的攻击

`优化了拾起武器和子弹等物品的体验`√

使用了相交球的检测方式，将距离玩家最近的武器设置为可拾取。同时优化了拾取子弹以及血包等物品的体验。

`敌人的子弹`

首先敌人的子弹获取到玩家的位子，然后随机他的子弹落点。同时无限延长子弹的飞行轨迹即可。

`困难点`

碰撞环境，准备搭建游戏环境。搭建好游戏环境之后，将导出一个新的01地图用于寻路和创建敌人。





