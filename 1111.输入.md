`介绍`

没有输入的视频游戏不是真正的视频游戏，更像是电影。在本课中，我们将学习如何使用Direct Input API。您可能想知道为什么我们不会使用
Win32 API来获取用户的输入。毕竟，他可以找到键盘上按下了哪些键。从鼠标甚至操纵杆获取输入。

嗯，Win32的API被设计为键盘输入应用程序的手段。而不是速度事实输入。当win32 API获取输入的时候。他需要处理按键，将他们转换为ascii。
并且对按下的特殊窗口键有很多额外的额处理。比如“alt”。游戏中不需要这么多的处理内容。并且记住，在我们消息队列为空之前，我们无法渲染
帧。他实际上非常慢，另外一件事是。win32 API只能从三个按钮获得输入。现在鼠标的功能远不止如此。所以我们选择使用Driect inputt API。

为了实现这个功能，我们增加了更多的库：

```c++
#pragma comment (lib, "dinput8.lib")
#pragma comment (lib, "dxguid.lib")
#include <dinput.h>
```

`新的全局变量`

接下来我们初始化几个变量，前边两个初始化的是IDirectInputDevice8 COM接口。他们代表我们可以用来获取输入的物理对象。下一行初始化
一个结构，我们将用它来获取鼠标的状态。然后我们初始化一个结构以从键盘输入。之后我们会有几个变量。当我们按下键来改变立方体的比例
旋转的时候，我们都需要这些变量。


```c++
IDirectInputDevice8* DIKeyboard;
IDirectInputDevice8* DIMouse;

DIMOUSESTATE mouseLastState;
LPDIRECTINPUT8 DirectInput;

float rotx = 0;
float rotz = 0;
float scaleX = 1.0f;
float scaleY = 1.0f;

XMMATRIX Rotationx;
XMMATRIX Rotationz;
```

`新功能`

我们有两个新的功能，一个用于初始化DirectInput，另一个用于检测输入。检测输入的函数将采用表示时间的双精度值。因此我们如果想要更新一些
将改变我们场景的值，我们就能够保持场景以恒定的速度移动。

```
bool InitDirectInput(HINSTANCE hInstance);
void DetectInput(double time);
```

`从winMain函数初始直接输入`

我们从winMain函数调用initDirectInput（）函数。我们马上就会讨论这个功能。

```
if(!InitDirectInput(hInstance))
{
    MessageBox(0, L"Direct Input Initialization - Failed",
        L"Error", MB_OK);
    return 0;
}
```

InitDirectInput（）函数

DirectInput8Create（）

现在我们来到我们有一个名为InitDirectInput（）新函数。这个函数将初始化直接输入，就像我们有一个初始化d3d函数一样。
这里第一行创建了我们的Direct Inupt对象。就像我们创建了d3d对象一样。我们可以通过调用DirectInput8Create（）函数
来创建一个Direct Input对象。

```c++
HRESULT WINAPI DirectInput8Create(
    HINSTANCE hinst,
    DWORD dwVersion,
    REFIID riidltf,
    LPVOID *ppvOut,
    LPUNKNOWN punkOuter
);
```

成员信息如下：

hinst：这是我们的应用程序实例的句柄

dwVersion：这是我们想要使用的直接输入的版本，指定DIRECTINPUT_VERSION

riddltf：这是我们想要使用的直接输入接口的标识符。指定IID_IDirectInput8

ppvOut：这是返回指向我们的直接输入对象的指针

punkOuter：用于COM聚合，指定NULL

创建一个DirectInput对象：


```
    hr = DirectInput8Create(hInstance,
        DIRECTINPUT_VERSION,
        IID_IDirectInput8,
        (void**)&DirectInput,
        NULL); 
```

`创建直接输入设备`

CreateDevice()

接下来，我们使用直接输入对象的CreateDevice（）函数创建键盘对象。我们输入GUID设备的标志的第一个参数。我们输入
GUID_SysKeyborad。我们不必担心选择正确的一个。因为只有一个键盘。然后我们返回一个指向所创建设备的指针。
这就是第二个参数。第三个参数是COM相关的，我们设置为诶NULL。然后我们为鼠标做同样的事情。但是要使用GUID_SysMouse
并且将指针返回到我们的DIMouse对象。

```
hr = DirectInput->CreateDevice(GUID_SysKeyboard,
    &DIKeyboard,
    NULL);

hr = DirectInput->CreateDevice(GUID_SysMouse,
    &DIMouse,
    NULL);
```

`设置数据格式`

IDirectInputDevice8::SetDataFormat（）

直接输入让我们告诉设备我们期待什么样子的输入。例如。如果我们有一个操纵杆。我们可能需要告诉他们我们期望操纵杆绕
旋转，如果我们有一个鼠标，我们需要告诉鼠标我们期望他可以自由旋转。我们可以通过下边的方式完成这个操作：

```
    hr = DIKeyboard->SetDataFormat(&c_dfDIKeyboard);
    hr = DIKeyboard->SetCooperativeLevel(hwnd, DISCL_FOREGROUND | DISCL_NONEXCLUSIVE);

    hr = DIMouse->SetDataFormat(&c_dfDIMouse);
    hr = DIMouse->SetCooperativeLevel(hwnd, DISCL_EXCLUSIVE | DISCL_NOWINKEY | DISCL_FOREGROUND);

    return true;
}
```

`检测输入`

DetectInput（）

接下来我们有DetectInput（）函数。在此功能中，我们将检测是否按下了键或者鼠标是否已经移动了。然后我们采取相应的行动。
首先我们初始化一个DIMOUSESTATE类型。我们将在稍后讨论。然后我们创建一个BYTE类型的变量来保存一个可能的键盘键数组。

有时候，在运行应用程序的时候，另一个应用程序会接管键盘，鼠标或者操纵杆。从而阻止当前应用程序使用他。要解决这个问题。
我们使用Acquire（）函数来收回设备。很多时候，您会看到此函数散步在程序周围，以确保程序可以控制设备。

```c++
void DetectInput(double time)
{
    DIMOUSESTATE mouseCurrState;

    BYTE keyboardState[256];

    DIKeyboard->Acquire();
    DIMouse->Acquire();
```

`获取设备当前状态`

第一个功能作用是获取我们设备的状态。由于我们已经将c_dfDIMouse指定为设备，因此我们需要使用DIMOUSESTATE结构的大小
填充第一个参数。然后它发送到我们设备状态的指针。DIMOUSESTATE保存我们的鼠标可能使用的按钮和轴。结构如下所示：

```
typedef struct DIMOUSESTATE {    
    LONG lX;
    LONG lY;
    LONG lZ;
    BYTE rgbButtons[4];
} DIMOUSESTATE, *LPDIMOUSESTATE;
```

钱三个是我们鼠标的x，y和z轴。最后一个是可能的四个按钮、x和y用于鼠标移动。z是鼠标的滚轮。如果自上次检查后未移动。
则x、y和z将返回0。之后我们检查键盘的设备状态。第一个参数是256个字符的数组。用于保存每个键的常量。第二个参数是
返回的状态。

```c++
    DIMouse->GetDeviceState(sizeof(DIMOUSESTATE), &mouseCurrState);

    DIKeyboard->GetDeviceState(sizeof(keyboardState),(LPVOID)&keyboardState);
```

`检测按下了哪些键`

现在我们进行输入检查。检查键盘状态将返回256 char数组。我们可以检查数组以查看是否按下了某个按钮。他是一个常量字符
数组，以下是我们可以检查的一些常见字符：

DIK_A ... DIK_Z A到Z.
DIK_0 ... DIK_9 0到9
DIK_F1 ... DIK_F15 F1至F15
小键盘上的DIK_NUMPAD0 ... DIK_NUMPAD9 0到9。 无论是否打开num lock，键都是相同的。
DIK_ESCAPE转义键
DIK_SPACE空格键
DIK_RETURN返回或回车键
DIK_NUMPADENTER在小键盘上输入键
DIK_UP向上箭头键
DIK_DOWN向下箭头键
DIK_LEFT左箭头键
DIK_RIGHT右箭头键
DIK_SUBTRACT  - 键盘上的键
键盘上的DIK_ADD +键
DIK_MINUS  - 顶行等于键旁边的键
DIK_EQUALS =退格旁边的键
DIK_BACK退格键
DIK_TAB Tab键
DIK_LCONTROL左侧Ctrl键
DIK_LSHIFT左Shift键
DIK_RSHIFT右侧Shift键
DIK_LMENU左侧的Alt键
DIK_RMENU右侧的Alt键
DIK_RCONTROL右侧控制键
DIK_LWIN左侧窗口键

在我们从键盘检查我们想要的按键之后，我们需要查看鼠标是否已经移动。还记得我们初始化mouseLastState之前吗？
这将在此函数结束的时候保持当前状态。并且当再次调用这个函数的时候，将重置实际当前鼠标状态，如果当前状态和之前状态不同。
则我们知道鼠标已经移动或者按钮已经按下。我们首先检查x轴。然后检查y轴。然后我们设置变量。用于沿x轴和y轴拉伸中心立方体。
毕竟，我们检查以确保我们的变量不会因为运行程序太长或者太慢而没有太长或者太低，那么我们就完成了这个功能。

我应该快速提到直接输入使用相对鼠标坐标。这意味着它检测自上次检查以来鼠标移动了多少。有时您可能希望获得绝对鼠标
坐标，例如它在屏幕上的确切位置。您可以通过设置场景开头的位置来实现此目的，然后跟踪它在x和y轴上的移动量。
另一种方法是在windows消息过程中使用lparam和wparam，稍后当我们学习如何“选择”一个对象或选择一个对象时，
我们将会这样做。

```
    if(keyboardState[DIK_ESCAPE] & 0x80)
        PostMessage(hwnd, WM_DESTROY, 0, 0);

    if(keyboardState[DIK_LEFT] & 0x80)
    {
        rotz -= 1.0f * time;
    }
    if(keyboardState[DIK_RIGHT] & 0x80)
    {
        rotz += 1.0f * time;
    }
    if(keyboardState[DIK_UP] & 0x80)
    {
        rotx += 1.0f * time;
    }
    if(keyboardState[DIK_DOWN] & 0x80)
    {
        rotx -= 1.0f * time;
    }
    if(mouseCurrState.lX != mouseLastState.lX)
    {
        scaleX -= (mouseCurrState.lX * 0.001f);
    }
    if(mouseCurrState.lY != mouseLastState.lY)
    {
        scaleY -= (mouseCurrState.lY * 0.001f);
    }

    if ( rotx > 6.28 )
        rotx -=  6.28;
    else if ( rotx < 0 )
        rotx = 6.28 + rotx;

    if ( rotz > 6.28 )
        rotz -=  6.28;
    else if ( rotz < 0 )
        rotz =  6.28 + rotz;

    mouseLastState = mouseCurrState;

    return;
}
```

同样的，别忘记清理接口。

`更新我们的场景`

在这里，我们将根据rotx，rotz，scalex和scaley变更更新场景，这些变量将使用用户输入进行更新哦。

```c++
void UpdateScene(double time)
{
    //Keep the cubes rotating
    rot += 1.0f * time;
    if(rot > 6.28f)
        rot = 0.0f;

    //Reset cube1World
    cube1World = XMMatrixIdentity();

    //Define cube1's world space matrix
    ///////////////**************new**************////////////////////
    XMVECTOR rotyaxis = XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f);
    XMVECTOR rotzaxis = XMVectorSet(0.0f, 0.0f, 1.0f, 0.0f);
    XMVECTOR rotxaxis = XMVectorSet(1.0f, 0.0f, 0.0f, 0.0f);

    Rotation = XMMatrixRotationAxis(rotyaxis, rot);
    Rotationx = XMMatrixRotationAxis(rotxaxis, rotx);
    Rotationz = XMMatrixRotationAxis(rotzaxis, rotz);
    Translation = XMMatrixTranslation( 0.0f, 0.0f, 4.0f );

    //Set cube1's world space using the transformations
    cube1World = Translation * Rotation * Rotationx * Rotationz;
    ///////////////**************new**************////////////////////

    //Reset cube2World
    cube2World = XMMatrixIdentity();

    //Define cube2's world space matrix
    Rotation = XMMatrixRotationAxis( rotyaxis, -rot);
    ///////////////**************new**************////////////////////
    Scale = XMMatrixScaling( scaleX, scaleY, 1.3f );
    ///////////////**************new**************////////////////////

    //Set cube2's world space matrix
    cube2World = Rotation * Scale;
}    
```

`调用DetectInput（）函数`

最后但同样重要的是，我们需要调用检测输入功能。

```
int messageloop(){
    MSG msg;
    ZeroMemory(&msg, sizeof(MSG));
    while(true)
    {
        BOOL PeekMessageL( 
            LPMSG lpMsg,
            HWND hWnd,
            UINT wMsgFilterMin,
            UINT wMsgFilterMax,
            UINT wRemoveMsg
            );

        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (msg.message == WM_QUIT)
                break;
            TranslateMessage(&msg);    
            DispatchMessage(&msg);
        }
        else{
            // run game code    
            frameCount++;
            if(GetTime() > 1.0f)
            {
                fps = frameCount;
                frameCount = 0;
                StartTimer();
            }    

            frameTime = GetFrameTime();

            ///////////////**************new**************////////////////////
            DetectInput(frameTime);
            ///////////////**************new**************////////////////////
            UpdateScene(frameTime);
            DrawScene();
        }
    }
    return msg.wParam;
}
```
















