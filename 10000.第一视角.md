`介绍`

在本课中，我们将学习一种简单的第一人称相机。这将使我们能够用鼠标上下，向上，向左或者向右查看，前后移动，左右扫视。
这并不是很难。所以我们只是对代码进行了解释并且解释了我们前边的过程而已。

我们将使用无缝的曹纹理来制作草地纹理

`新的全局变量`

这里有一堆新的声明。你可以看到四个新的向量。两个新的矩阵和一对浮点数。前两个向量描述了世界上的前向和右向。我们将使用它们来移动我们的相机。
所以当我们按下前进按键的时候，我们要做的就是沿着camForward矢量移动，使他看起来像我们的相机正向移动。

实际上并不需要创建camRotationMatrix，因为我们可能刚刚使用了我们用于立方体的相同旋转矩阵，但是我们还是做了他。我们将用他来旋转我们的相机。
第二个是描述我们的“地面”的世界空间的另一个矩阵。同样，我们可以使其中的一个立方体世界矩阵。但我认为这会更加清楚。

两个浮点数moveLeftRight和moveBackForward用于沿着camForward和camRight向量移动。

`新的功能`

这是我们新的功能，他用于更新我们的相机哦~

`走向全屏`

这是我们的交换链描述。要全屏显示，我们必须将Windowed成员设置为false。按"Alt+Enter"可以退出全屏模式。

```c++
swapChainDesc.BufferDesc = bufferDesc;
swapChainDesc.SampleDesc.Count = 1;
swapChainDesc.SampleDesc.Quality = 0;
swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
swapChainDesc.BufferCount = 1;
swapChainDesc.OutputWindow = hwnd; 
///////////////**************new**************////////////////////
swapChainDesc.Windowed = false; 
///////////////**************new**************////////////////////
swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
```

`UpdateCamera()函数`

这是我们UpdateCamera()函数，它将在DetectInput（）末尾的每一帧调用。

```c++
void UpdateCamera()
{
    camRotationMatrix = XMMatrixRotationRollPitchYaw(camPitch, camYaw, 0);
    camTarget = XMVector3TransformCoord(DefaultForward, camRotationMatrix );
    camTarget = XMVector3Normalize(camTarget);

    XMMATRIX RotateYTempMatrix;
    RotateYTempMatrix = XMMatrixRotationY(camYaw);

    camRight = XMVector3TransformCoord(DefaultRight, RotateYTempMatrix);
    camUp = XMVector3TransformCoord(camUp, RotateYTempMatrix);
    camForward = XMVector3TransformCoord(DefaultForward, RotateYTempMatrix);

    camPosition += moveLeftRight*camRight;
    camPosition += moveBackForward*camForward;

    moveLeftRight = 0.0f;
    moveBackForward = 0.0f;

    camTarget = camPosition + camTarget;    

    camView = XMMatrixLookAtLH( camPosition, camTarget, camUp );
}
```

`旋转相机`

UpdateCamera（）函数中的前三行将更新摄像机目标。第一行使用xna数学库的新函数，称为XMMatrixRotationRollPitchYaw。这个函数有
三个参数，第一个参数是以弧度制表示旋转的音高。第二个以弧度制为单位旋转的偏移量。第三个是以弧度制为单位的旋转。他返回一个旋转矩阵。
此功能对于相机尤其有用。你可以同时围绕所有轴旋转，Yaw，Pitch，Roll，其实就是Y,X,Z轴的旋转。我们的相机将向上/向下，向左和向右查看。
就像你做一个车轮。我们的相机将向上，向下，和向左向右查看。因此我们将设置此功能的偏航和俯仰参数。由于我们没有使用roll参数，因此我们
设置为0.

下一行通过使用我们刚刚创建的rotationMatrix旋转DefaultForward向量并且将其设置为Target矩阵来设置我们的相机目标向量。之后，我们
对矢量进行归一化。因为最后一个操作可能使得目标是两只大于1.0f或者小于-1f.

```c++
camRotationMatrix = XMMatrixRotationRollPitchYaw(camPitch, camYaw, 0);
camTarget = XMVector3TransformCoord(DefaultForward, camRotationMatrix );
camTarget = XMVector3Normalize(camTarget);
```

现在我们需要找到相机的新右前方向。我们将使用在Y轴上旋转来实现这个操作。由于我们的相机时第一人称相机，所以我们只需要在x和z轴上移动。
我们需要保持相机的向前和向右矢量仅仅指向x轴和z轴即可。我们将使用这些矢量向后向前，向左和向右我们的相机。首先我们创建一个新的矩阵。
然后我们再鼠标移动的时候设置的偏航变量旋转这个矩阵。

```
XMMATRIX RotateYTempMatrix;
RotateYTempMatrix = XMMatrixRotationY(camYaw);
```

`更新camForwad，camUp和camRight 向量`

接下来，我们使用我们刚刚定义的RotateYTempMatrix矩阵变换摄像机的向右向上和向前矢量，并且旋转默认的右，向上的和默认向前的向量。
然后将结果设置其中。

```c++
camRight = XMVector3TransformCoord(DefaultRight, RotateYTempMatrix);
camUp = XMVector3TransformCoord(camUp, RotateYTempMatrix);
camForward = XMVector3TransformCoord(DefaultForward, RotateYTempMatrix);
``

`移动相机`

接下来，我们使用两个值，moveLeftRight和moveBackForward以及两个向量Right和Forward来更新摄像机的位子。
要左右移动摄像机，我们将moveLeftRight变量与右矢量相乘。并且将其添加到位子。然后我门为了前后移动。我们在将
moveBackForward与Forward向量相乘，并且添加到Position。当直接输入检测到某个按键被按下的时候。将计算moveLeftRight和moveBcakForward

之后我们重置了moveLeftRight和moveBackForward。

```c++
camPosition += moveLeftRight*camRight;
camPosition += moveBackForward*camForward;

moveLeftRight = 0.0f;
moveBackForward = 0.0f;
```

`设置camView矩阵`

现在我们将相机的位子添加到目标矢量。然后使用XMMatrixLookAtLH（）D3D函数更新我们的View矩阵。此函数更新我们的View矩阵，用于通过
使用摄像机位子，目标和向上矢量来计算我们的WVP矩阵。

```c++
    camTarget = camPosition + camTarget;    

    camView = XMMatrixLookAtLH( camPosition, camTarget, camUp );
```

`DetectInput()函数`

我们更新了DetectInput（）函数，以便在移动鼠标或者按下WASD的时候移动我们的相机。在我们开始检查输入之前注意该行。我们有一个名为“速度”
的新变量。这是我们每帧重新定位相机移动的速度。我们再调用此函数时候传入时间变量，并且与我们的速度相乘，这样无论每秒帧数是多少，我们的
相机都会在下一秒内移动完全相同的距离。接下来我们检查WASD是否按下，并且相应的更新moveLeftRgiht和moveBackForward。之后我们检查
鼠标输入，我们将更新CamYaw和CamPitch，具体取决于鼠标自上一帧和当前帧的x和y的偏移量。毕竟，我们通过调用UpdateCamera（）函数来更新
我们的相机

```c++
void DetectInput(double time)
{
    DIMOUSESTATE mouseCurrState;

    BYTE keyboardState[256];

    DIKeyboard->Acquire();
    DIMouse->Acquire();

    DIMouse->GetDeviceState(sizeof(DIMOUSESTATE), &mouseCurrState);

    DIKeyboard->GetDeviceState(sizeof(keyboardState),(LPVOID)&keyboardState);

    if(keyboardState[DIK_ESCAPE] & 0x80)
        PostMessage(hwnd, WM_DESTROY, 0, 0);

    float speed = 15.0f * time;

    if(keyboardState[DIK_A] & 0x80)
    {
        moveLeftRight -= speed;
    }
    if(keyboardState[DIK_D] & 0x80)
    {
        moveLeftRight += speed;
    }
    if(keyboardState[DIK_W] & 0x80)
    {
        moveBackForward += speed;
    }
    if(keyboardState[DIK_S] & 0x80)
    {
        moveBackForward -= speed;
    }
    if((mouseCurrState.lX != mouseLastState.lX) || (mouseCurrState.lY != mouseLastState.lY))
    {
        camYaw += mouseLastState.lX * 0.001f;

        camPitch += mouseCurrState.lY * 0.001f;

        mouseLastState = mouseCurrState;
    }

    UpdateCamera();

    return;
}
```

同时不要忘记Clean Up每个内容。

`改变光线方向`

当然我们不必这样做，但是这样做是为了获得草纹的全彩色。我们需要确保光线直接从上方击中。

```c++
light.dir = XMFLOAT3(0.0f, 1.0f, 0.0f);
light.ambient = XMFLOAT4(0.2f, 0.2f, 0.2f, 1.0f);
light.diffuse = XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f);
```

`描述地面的顶点和索引缓冲区`

我们的地面将是一个简单的广场（平面）。注意我们的纹理坐标，这是为了获得重复的纹理。而不是覆盖整个地面的伸展的纹理。

```c++
    //Create the vertex buffer
    Vertex v[] =
    {
        // Bottom Face
        Vertex(-1.0f, -1.0f, -1.0f, 100.0f, 100.0f, 0.0f, 1.0f, 0.0f),
        Vertex( 1.0f, -1.0f, -1.0f,   0.0f, 100.0f, 0.0f, 1.0f, 0.0f),
        Vertex( 1.0f, -1.0f,  1.0f,   0.0f,   0.0f, 0.0f, 1.0f, 0.0f),
        Vertex(-1.0f, -1.0f,  1.0f, 100.0f,   0.0f, 0.0f, 1.0f, 0.0f),
    };

    DWORD indices[] = {
        0,  1,  2,
        0,  2,  3,
    };

    D3D11_BUFFER_DESC indexBufferDesc;
    ZeroMemory( &indexBufferDesc, sizeof(indexBufferDesc) );

    indexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
    indexBufferDesc.ByteWidth = sizeof(DWORD) * 2 * 3;
    indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
    indexBufferDesc.CPUAccessFlags = 0;
    indexBufferDesc.MiscFlags = 0;

    D3D11_SUBRESOURCE_DATA iinitData;

    iinitData.pSysMem = indices;
    d3d11Device->CreateBuffer(&indexBufferDesc, &iinitData, &squareIndexBuffer);

    D3D11_BUFFER_DESC vertexBufferDesc;
    ZeroMemory( &vertexBufferDesc, sizeof(vertexBufferDesc) );

    vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
    vertexBufferDesc.ByteWidth = sizeof( Vertex ) * 4;
    vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
    vertexBufferDesc.CPUAccessFlags = 0;
    vertexBufferDesc.MiscFlags = 0;

    D3D11_SUBRESOURCE_DATA vertexBufferData; 

    ZeroMemory( &vertexBufferData, sizeof(vertexBufferData) );
    vertexBufferData.pSysMem = v;
    hr = d3d11Device->CreateBuffer( &vertexBufferDesc, &vertexBufferData, &squareVertBuffer);
```

`更新纹理`

我们现在不适用那种大脑的纹理了，我们将使用一个漂亮的无缝的草纹理。

```c++
hr = D3DX11CreateShaderResourceViewFromFile( d3d11Device, L"grass.jpg",
    NULL, NULL, &CubesTexture, NULL );
```

`更新我们的场景`

我们本课中没有使用立方体。因此我们不会更新他们的世界空间。相反，我们将我们的地面拓展到1000个单位款和长。并且在y轴向下移动十个单位。

```c++
void UpdateScene(double time)
{
    //Reset cube1World
    groundWorld = XMMatrixIdentity();

    //Define cube1's world space matrix
    ///////////////**************new**************////////////////////
    Scale = XMMatrixScaling( 500.0f, 10.0f, 500.0f );
    Translation = XMMatrixTranslation( 0.0f, 10.0f, 0.0f );

    //Set cube1's world space using the transformations
    groundWorld = Scale * Translation;
    ///////////////**************new**************////////////////////
}
```

`更改背景颜色`

我们认为漆黑的背景有点无聊，所以我改成了深灰色。

```c++
float bgColor[4] = { 0.1f, 0.1f, 0.1f, 1.0f };
```




