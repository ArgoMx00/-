`介绍`

本课程将以混合课程为基础，稍作修改。我将尝试怼其进行修改。但是为了安全起见，您应该查看这些课程代码和混合课程代码，实际上有什么不同的地方。这是一个较长
的课程，可能有点无聊，单如果您不想实际阅读全部，或者不想学习如何同步API，您可以使用我所做的三个功能来实现字体。只记得修改创建direct3d11设备和交换链
的代码，并更改后备缓冲区的格式，因为Direct2D似乎只与BRGA格式兼容。而不是我们使用的RGBA格式。

direct3d 11中将字体渲染到屏幕上的速度不是很快。实际上，我很难搞清楚为什么。大多数人只是说使用GDI,Direct2D和DirectWirte。或者说是自己制作。

`Direct3D 11中的字体渲染`

我写的新代码将字体呈现为三个函数。我们现在有一个函数从initializeD3D函数调用，它将初始化我们的Direct3D 设备。Direct2D和DirectDraw。从initscene函数调用的另一个函数将创建一个正方形，用于渲染Direct2D渲染目标纹理。并从纹理Direct2D和Direct3D 10.1渲染创建着色器资源视图。用于纹理该正方形。

将D2D与D3D一起使用11并不像使用D3D和D3D一样简单。在微软的网站上，他们提到要替换ID3DXFont接口，我们应该使用GDI或者是D2D和DirectWrite的API。GDI的
字体很乱很难看，所以如果我们想要一个更加灵活漂亮的字体，我们就会遇到D2D。

那么我们如何在D3D11应用程序中使用D2D呢？我们需要使用一种称为表面共享的技术。这样，我们可以使用D2D和D3D设备渲染的曲面。然后使用D3D设备，将共享曲面
渲染到屏幕空间中覆盖整个场景的正方形上。

首先我将解释如何执行这个操作，然后通过代码显示如何执行这个操作。

`同步曲面共享`

D3D 1，D3D 0.1和D2D都使用DXGI 1.1。因此，我们可以使用DXGI创建一个可以在三个API之间共享的渲染目标。

`适配器`

使用Surface Sharing的时候，我们必须在创建设备的时候指定适配器，因为仅当参数设置为NULL将导致错误。我们可以通过使用IDXGIFactory1接口的Enum
Adapters1（）方法枚举可用的适配器来获取适配器。我们将第一个参数设置为0.这是第一个适配器，第二个参数是一个IDXGIAdapter1来存储他。

`创建D3D 10.1和11设备`

首先，我们将像我们一样创建D3D11设备和交换链。除了我们将第一个参数设置为存储在我们找到的IDXGIAdapter1对象中的枚举适配器。确认D3D 10.1使用相同的
适配器。

第二个参数是驱动程序类型。我们必须为D3D 11设备指定D3D_DRIVER_TYPE_UNKNOWN，然后为D3D 10.1设备指定D3D_DRIVER_TYPE_HARDWARE。

并且对于第四个参数，标记，我们必须指定D3D_CREATE_DEVICE_BGRA_SUPPORT才能使用direct2D。我们可以选择使用D3D11_CREATE_DEVICE_DEBUG来在调试
时获得大量有用的信息。

创建D3D 10.1设备时候的第五个参数，功能级别，我们将指定D3D11_FEATURE_LEVEL_9_3.因为任何更高的东西似乎都不起作用。

`D3D 11共享纹理` 

接下来，我们将从D3D11设备创建一个共享纹理，D3D 10.1将渲染到该设备上。创建这个纹理的时候，在纹理描述中，我们必须确保我们设置了一些正确的东西才行。

我们必须为格式指定DXGI_FORMAT_B8G8R8A8_UNORM

对于MiscFlags成员，我们必须设置D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX以允许D3D11和D3D 10.1都使用这个表面。指定Flag的时候，它将支持
IDXGIKeyedMutex接口，然后我们可以为每个设备调用IDXGIKeyedMutex::AcquireSync和IDXGIKeyedMutex::ReleaseSync。以便其他设备知道另一个设备如何使用纹理。

`纹理中的共享资源`

由于我们无法直接从D3D 10.1创建一个键控互斥锁。因为这个纹理是D3D11，我们需要创建一个共享资源对象。然后我们可以得到一个句柄。然后创建一个使用该资源的句柄共享表面，为D3D10.1提供对纹理的访问。基本上我们正在做的就是获取指向此纹理的指针。并将其存储在IDXGIResource对象中。

`新的INclude和Lib

我们将使用Direct3D 10.1设备，因此我们必须制作必要的包含以及连接器。然后我们使用DXGI进行表面共享，最后使用D2D和DirectWrite。

```c++
//Include and link appropriate libraries and headers//
#pragma comment(lib, "d3d11.lib")
#pragma comment(lib, "d3dx11.lib")
#pragma comment(lib, "d3dx10.lib")
///////////////**************new**************////////////////////
#pragma comment (lib, "D3D10_1.lib")
#pragma comment (lib, "DXGI.lib")
#pragma comment (lib, "D2D1.lib")
#pragma comment (lib, "dwrite.lib")
///////////////**************new**************////////////////////

#include <windows.h>
#include <d3d11.h>
#include <d3dx11.h>
#include <d3dx10.h>
#include <xnamath.h>
///////////////**************new**************////////////////////
#include <D3D10_1.h>
#include <DXGI.h>
#include <D2D1.h>
#include <sstream>
#include <dwrite.h>
///////////////**************new**************////////////////////
```

`新的全局变量`

我们有一大堆新的接口。我们几乎精力了这些新界面中的每一个，而其他界面你可以找出他们的用途。最后一个是一个宽字符串变量，他将保存我们的文本将其传递给D2D、

```c++
ID3D10Device1 *d3d101Device;    
IDXGIKeyedMutex *keyedMutex11;
IDXGIKeyedMutex *keyedMutex10;    
ID2D1RenderTarget *D2DRenderTarget;    
ID2D1SolidColorBrush *Brush;
ID3D11Texture2D *BackBuffer11;
ID3D11Texture2D *sharedTex11;    
ID3D11Buffer *d2dVertBuffer;
ID3D11Buffer *d2dIndexBuffer;
ID3D11ShaderResourceView *d2dTexture;
IDWriteFactory *DWriteFactory;
IDWriteTextFormat *TextFormat;

std::wstring printText;
```

`新功能`

就像我们上边提到的，我们试图将代码分开。以便您可以轻松的将他们放入我们自己的应用程序中。我们这里添加了三个新的功能。但是我们其实可以将其压缩变成两个。第一个函数将使用共享表面初始化D3D10.1,D2D和DirectWrite。这里唯一的参数就是适配器。因为我们需要确保使用的D3D 11设备相同的适配器。第二个函数将从共享纹理创建一个正方形和一个着色器资源视图。以便我们可以将他渲染到正方形上。

```
bool InitD2D_D3D101_DWrite(IDXGIAdapter1 *Adapter);
void InitD2DScreenTexture();
void RenderText(std::wstring text);
```

`枚举第一个适配器`

跳转到initializeD3D11函数。这是我们课程的主要内容和最重要的内容。我们做的第一件事就是枚举一个设备。当我们同步两个设备的时候。我们不能在创建设备的时候为适配器参数指定NULL、我们需要创建一个DXGI Factory，然后我们可以枚举一个适配器。我们将使用第一个适配器，他是主适配器。我们可以通过将0设置为EnumAdapters1（）函数中的第一个参数来指定一个适配器。

```c++
IDXGIFactory1 *DXGIFactory;

HRESULT hr = CreateDXGIFactory1(__uuidof(IDXGIFactory1), (void**)&DXGIFactory);    
    
IDXGIAdapter1 *Adapter;

hr = DXGIFactory->EnumAdapters1(0, &Adapter);

DXGIFactory->Release();    
```

`初始化D3D11`

在这里，我们启动我们的D3D11设备和交换链。这个功能并不新鲜，正如我们在上节课中所介绍的那样。但我们已经改了三个参数。

就像刚才说的那样，我们必须在创建设备的时候实际指定一个适配器，因为在同步设备的时候我们无法使用NULL来获取默认适配器。我们将使用IDXGIAdapter1对象，该对象包含指向我们在上边找到的第一个适配器指针。

第二个参数是我们将使用的设备类型。在我们有硬件设备之前，我们需要使用D3D_DRIVER_TYPE_UNKNOWN,因为指定硬件会导致错误。

我们的第四个参数也从NULL改变了。我们现在指定两个标志。在调试应用程序的时候看到额外的信息。当我们遇到未知的问题的时候可以更加的方便。第一个标志是告诉设备在调试的时候吐出有关设备的额外信息。当我们使用D2D的时候使用第二个标志，因为D2D具有不同的格式。标志将确保我们的设备与D2D的格式兼容。

然后我们调用我们的initD2D_D3D101_DWrite（）函数，传入我们的Adapter作为唯一的参数。在我们调用之后，我们释放我们的适配器对象。

```c++
//Create our Direct3D 11 Device and SwapChain//////////////////////////////////////////////////////////////////////////
hr = D3D11CreateDeviceAndSwapChain(Adapter, D3D_DRIVER_TYPE_UNKNOWN, NULL, D3D11_CREATE_DEVICE_DEBUG |    D3D11_CREATE_DEVICE_BGRA_SUPPORT,
    NULL, NULL,    D3D11_SDK_VERSION, &swapChainDesc, &SwapChain, &d3d11Device, NULL, &d3d11DevCon);

//Initialize Direct2D, Direct3D 10.1, DirectWrite
InitD2D_D3D101_DWrite(Adapter);

//Release the Adapter interface
Adapter->Release();
```

`SwapChain格式`

我忘记了提到我们需要将交换链的格式更改为DXGI_FORMAT_B8G8R8A8_UNORM。这是因为D2D只能与这种格式兼容


```c++
bufferDesc.Width = Width;
bufferDesc.Height = Height;
bufferDesc.RefreshRate.Numerator = 60;
bufferDesc.RefreshRate.Denominator = 1;
bufferDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
bufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
bufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
```

`使用共享表面初始化D3D 10.1,D2D,以及DirectWrite`

InitD2D_D3D101_DWrite()

好的，这是本课程最艰难的部分，初始化D3D 10.1,D2D以及DirectWrite，让他们使用共享表面进行渲染。我将所有这些都放入一个函数中，以便您可以在自己的应用程序中轻松的使用他。这是整个功能：

```c++
bool InitD2D_D3D101_DWrite(IDXGIAdapter1 *Adapter)
{
    //Create our Direc3D 10.1 Device///////////////////////////////////////////////////////////////////////////////////////
    hr = D3D10CreateDevice1(Adapter, D3D10_DRIVER_TYPE_HARDWARE, NULL,D3D10_CREATE_DEVICE_DEBUG |    D3D10_CREATE_DEVICE_BGRA_SUPPORT,
        D3D10_FEATURE_LEVEL_9_3, D3D10_1_SDK_VERSION, &d3d101Device    );    

    //Create Shared Texture that Direct3D 10.1 will render on//////////////////////////////////////////////////////////////
    D3D11_TEXTURE2D_DESC sharedTexDesc;    

    ZeroMemory(&sharedTexDesc, sizeof(sharedTexDesc));

    sharedTexDesc.Width = Width;
    sharedTexDesc.Height = Height;    
    sharedTexDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
    sharedTexDesc.MipLevels = 1;    
    sharedTexDesc.ArraySize = 1;
    sharedTexDesc.SampleDesc.Count = 1;
    sharedTexDesc.Usage = D3D11_USAGE_DEFAULT;
    sharedTexDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;    
    sharedTexDesc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX;    

    hr = d3d11Device->CreateTexture2D(&sharedTexDesc, NULL, &sharedTex11);    

    // Get the keyed mutex for the shared texture (for D3D11)///////////////////////////////////////////////////////////////
    hr = sharedTex11->QueryInterface(__uuidof(IDXGIKeyedMutex), (void**)&keyedMutex11);    

    // Get the shared handle needed to open the shared texture in D3D10.1///////////////////////////////////////////////////
    IDXGIResource *sharedResource10;
    HANDLE sharedHandle10;    

    hr = sharedTex11->QueryInterface(__uuidof(IDXGIResource), (void**)&sharedResource10);

    hr = sharedResource10->GetSharedHandle(&sharedHandle10);    

    sharedResource10->Release();

    // Open the surface for the shared texture in D3D10.1///////////////////////////////////////////////////////////////////
    IDXGISurface1 *sharedSurface10;    

    hr = d3d101Device->OpenSharedResource(sharedHandle10, __uuidof(IDXGISurface1), (void**)(&sharedSurface10));

    hr = sharedSurface10->QueryInterface(__uuidof(IDXGIKeyedMutex), (void**)&keyedMutex10);    

    // Create D2D factory///////////////////////////////////////////////////////////////////////////////////////////////////
    ID2D1Factory *D2DFactory;    
    hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, __uuidof(ID2D1Factory), (void**)&D2DFactory);    

    D2D1_RENDER_TARGET_PROPERTIES renderTargetProperties;

    ZeroMemory(&renderTargetProperties, sizeof(renderTargetProperties));

    renderTargetProperties.type = D2D1_RENDER_TARGET_TYPE_HARDWARE;
    renderTargetProperties.pixelFormat = D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, D2D1_ALPHA_MODE_PREMULTIPLIED);    

    hr = D2DFactory->CreateDxgiSurfaceRenderTarget(sharedSurface10, &renderTargetProperties, &D2DRenderTarget);

    sharedSurface10->Release();
    D2DFactory->Release();    

    // Create a solid color brush to draw something with        
    hr = D2DRenderTarget->CreateSolidColorBrush(D2D1::ColorF(1.0f, 1.0f, 0.0f, 1.0f), &Brush);

    //DirectWrite///////////////////////////////////////////////////////////////////////////////////////////////////////////
    hr = DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
        reinterpret_cast<IUnknown**>(&DWriteFactory));

    hr = DWriteFactory->CreateTextFormat(
        L"Script",
        NULL,
        DWRITE_FONT_WEIGHT_REGULAR,
        DWRITE_FONT_STYLE_NORMAL,
        DWRITE_FONT_STRETCH_NORMAL,
        24.0f,
        L"en-us",
        &TextFormat
        );

    hr = TextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
    hr = TextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);

    d3d101Device->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_POINTLIST);    
    return true;
}
```

`初始化D3D 10.1`

我们再这个函数中做的第一件事情就是初始化D3D 10.1设备。他几乎与初始化D3D11的设备和交换链相同。除了参数比较少以外，你可能猜得到他们大多数都在做什么。无论如何，第一个参数是传入的适配器，第二个参数我们将使用指定D3D10_DRIVER_TYPE_HARDWARE来创建这个硬件设备，第五个是功能级别。

```c++
hr = D3D10CreateDevice1(Adapter, D3D10_DRIVER_TYPE_HARDWARE, NULL,D3D10_CREATE_DEVICE_DEBUG |    D3D10_CREATE_DEVICE_BGRA_SUPPORT,
    D3D10_FEATURE_LEVEL_9_3, D3D10_1_SDK_VERSION, &d3d101Device    );
```

`创建D3D11 2D纹理`

接下来，我们将创建ID3D11Texture2D，他将用作API之间共享纹理。这个纹理唯一不同的是我们必须为MiscFlags成员指定D3D11_RESOURCE_MISC_SHARED_KEYMUTEX,并且为纹理格式指定DXGI_FORMAT_B8G8R8A8_UNORM。确保格式相同。

```
D3D11_TEXTURE2D_DESC sharedTexDesc;    

ZeroMemory(&sharedTexDesc, sizeof(sharedTexDesc));

sharedTexDesc.Width = Width;
sharedTexDesc.Height = Height;    
sharedTexDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
sharedTexDesc.MipLevels = 1;    
sharedTexDesc.ArraySize = 1;
sharedTexDesc.SampleDesc.Count = 1;
sharedTexDesc.Usage = D3D11_USAGE_DEFAULT;
sharedTexDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;    
sharedTexDesc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX;    

hr = d3d11Device->CreateTexture2D(&sharedTexDesc, NULL, &sharedTex11);    
```

`D3D11 Keyed Mutex`

现在我们需要为这个纹理获取一个键控互斥锁。D3D11将用来访问他。我们通过从ID3D11Texture2D对象调用QueryInterFace（）函数来完成这个操作。


```c++
hr = sharedTex11->QueryInterface(__uuidof(IDXGIKeyedMutex), (void**)&keyedMutex11);    
```

`获取D3D11纹理的句柄`

现在，由于D3D 10.1无法直接访问D3D 11纹理，我们需要使用DXGI间接访问它。 我们可以通过再次调用QueryInterface（）函数来创建一个IDXGIResource对象，该对象基本上保存D3D 11纹理的指针。

然后我们需要创建一个这个资源的句柄，以便D3D 10.1可以访问它。 我们通过调用IDXGIResource接口的GetSharedHandle方法来创建此资源的句柄。

然后我们释放共享资源，因为我们现在有了D3D 11纹理的句柄。

```c++
IDXGIResource *sharedResource10;
HANDLE sharedHandle10;    

hr = sharedTex11->QueryInterface(__uuidof(IDXGIResource), (void**)&sharedResource10);

hr = sharedResource10->GetSharedHandle(&sharedHandle10);    

sharedResource10->Release();
```

`为D3D10.1 获取D3D11纹理的键控互斥锁`

接下来，我们必须为D3D 10.1获得D3D 11纹理的键控互斥锁。 我们首先使用D3D 11纹理的句柄打开共享资源（D3D 11纹理），并将指针存储在IDXGISurface1对象中，这是D3D 10.1和D2D将渲染到的对象。 我们可以通过调用函数ID3D10Device1 :: OpenSharedResource来做到这一点。 第一个参数是共享资源的句柄，第二个是我们将指针存储在的对象的接口id，第三个是我们存储指针的对象。

打开共享资源并将指针存储到共享表面后，我们得到D3D 10.1共享表面的键控互斥锁。 我们通过从共享表面调用QueryInterface（）方法，并将指针存储到IDXGIKeyedMutex对象中来实现。

```c++
IDXGISurface1 *sharedSurface10;    

hr = d3d101Device->OpenSharedResource(sharedHandle10, __uuidof(IDXGISurface1), (void**)(&sharedSurface10));

hr = sharedSurface10->QueryInterface(__uuidof(IDXGIKeyedMutex), (void**)&keyedMutex10);    
```

`初始化D2D`

现在我们已经初始化了D3D 10.1以及D3D 11的设备，我们现在可以继续初始化D2D和DirectWrite。D2D资源是ID2DFactory对象。要创建D2D资源，我们调用D2D1CreateFactory函数。第一个参数是指定D2D是使用多个线程还是单个线程。使用单个线程表示D2D功能可以在没有完成的状态下返回。在多个线程中，函数
可以返回而不用实际完成。第二个参数是我们将资源指针存储到对象的接口ID。最后一个参数是我们将指针存储在的对象接口。

```c++
ID2D1Factory *D2DFactory;    
hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, __uuidof(ID2D1Factory), (void**)&D2DFactory);    
```

`D2D渲染目标属性`

接下来我们需要设置D2D渲染目标属性，我们通过填写D2D1_RENDER_TARGET_PROPERRTIES结构来完成这个操作。结构如下所示：

```c++
struct D2D1_RENDER_TARGET_PROPERTIES {
  D2D1_RENDER_TARGET_TYPE  type;
  D2D1_PIXEL_FORMAT        pixelFormat;
  FLOAT                    dpiX;
  FLOAT                    dpiY;
  D2D1_RENDER_TARGET_USAGE usage;
  D2D1_FEATURE_LEVEL       minLevel;
};
```

成员信息如下：

type  - 这是我们可以指定D2D是否使用硬件或软件渲染的地方。我们将使用硬件，因此我们将其设置为D2D1_RENDER_TARGET_TYPE_HARDWARE。

pixelFormat  - 这是渲染目标的像素格式和alpha模式。我们需要创建一个D2D像素格式，因此我们将使用函数D2D1 :: PixelFormat（）。我们稍后会详细解释这个功能。

dpiX  - 这是渲染目标的水平dpi。我们可以指定0来使用默认值，或者将其留空，我们将这样做。

dpiY  - 这是渲染目标的垂直dpi。我们可以指定0来使用默认值，或者将其留空，我们将这样做。

用法 - 指定渲染目标是如何根据msdn“远程”进行的。我们可以将它留给我们的应用程序。

minLevel  - 这与功能级别有关。我们可以设置用于硬件渲染的最小功能级别。如果设备的功能级别低于我们在此处指定的级别，则D2D将使用软件渲染。如果我们单独保留或将其设置为D2D1_RENDER_TARGET_TYPE_DEFAULT，则D2D将决定设备是否具有足够高的功能级别，或者是否能够呈现D2D，并且如果硬件无法呈现D2D，则将使用软件呈现。如果我们要指定D2D1_RENDER_TARGET_TYPE_HARDWARE，并且硬件没有足够高的D2D功能级别，或者无法呈现D2D，则创建渲染目标将失败。但是，此字段不用于我们的特定渲染目标，因为我们正在创建DXGI渲染目标，因为D3D 11,10.1和D2D都是由DXGI接口构建的（这就是为什么我们可以使用DXGI表面和资源）。

好的，所以D2D1 :: PixelFormat（）函数将创建并返回D2D像素格式，这就是我们能够直接在pixelFormat字段中设置此函数的原因。 此函数有两个参数，第一个是像素格式，它是渲染目标中颜色通道的大小和布置（RED GREEN BLUE ALPHA，使用D2D时不是特别按此顺序）。 我们可以指定DXGI_FORMAT_UNKNOWN，这是默认值。 第二个参数是alpha模式。 我们可以在这里使用几个不同的值。 此参数说明如何解释渲染目标中的Alpha通道。 我们需要指定D2D1_ALPHA_MODE_PREMULTIPLIED，以便任何D2D绘制都是不透明的，但是D2D不绘制（D2D的背景）将是不可见的，因为我们将在我们的场景上覆盖其渲染目标。 我们可以在这里放置其他三个值，但是我们放置的值是唯一一个完全按照我们需要的方式工作的值。

```c++
D2D1_RENDER_TARGET_PROPERTIES renderTargetProperties;

ZeroMemory(&renderTargetProperties, sizeof(renderTargetProperties));

renderTargetProperties.type = D2D1_RENDER_TARGET_TYPE_HARDWARE;
renderTargetProperties.pixelFormat = D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, D2D1_ALPHA_MODE_PREMULTIPLIED);    
```

`创建D2D渲染目标`

由于我们需要与D3D 10.1共享渲染目标，我们需要创建一个DXGI渲染目标，因为D2D和D3D 10.1 API都兼容。我们可以通过调用函数ID2D1Factory::creatDxgiSurfaceRenderTarget（）来完成这个操作。第一个参数是D2D将绘制的DXGI表面。这是我们上面用D3D 10.1创建的共享表面（与D3D 11纹理“链接”）。第二个参数是指向我们填写的D2D1_RENDER_TARGET_PROPERTIES结构的指针。最后一个是返回的D2D渲染目标。

因此，要使用D2D渲染到D3D 11纹理，我们将首先使用D2D渲染到D2D渲染目标，D2D是指向DXGI曲面（D2D和D3D 10.1之间的共享曲面）的指针，这是指向D3D的指针11纹理。因此，通过渲染到D2D渲染目标，我们间接渲染到D3D 11纹理。如果微软更新D2D与D3D 11兼容，那真的会很棒，所以我们不必如此间接。

在我们创建D2D渲染目标之后，我们不再需要共享表面了（因为它基本上是D3D 11纹理的指针一直向下传递到D2D渲染目标），所以我们可以释放它，我们是还完成了创建D2D的东西，所以我们可以发布D2D工厂。

```c++
hr = D2DFactory->CreateDxgiSurfaceRenderTarget(sharedSurface10, &renderTargetProperties, &D2DRenderTarget);

sharedSurface10->Release();
D2DFactory->Release();    
```

`D2D画笔`

您可以将D2D视为一种艺术工具包，其中包含油漆桶，画笔和画布。 它使用什么称为画笔来为屏幕的一部分渲染颜色。 我们现在需要创建画笔，所有涉及的操作都是从D2D渲染目标调用一个方法，该方法创建一个新画笔（ID2D1SolidColorBrush对象）并为其赋予颜色。 我们可以通过调用ID2D1SolidColorBrush :: SetColor（）函数随时更改此画笔的颜色，其中唯一的参数是D2D颜色（D2D1_COLOR_F）。

```c++
hr = D2DRenderTarget->CreateSolidColorBrush(D2D1::ColorF(1.0f, 1.0f, 0.0f, 1.0f), &Brush);
```

`初始化DirectWirte`

D2D可以被视为画家工具，而DirectWrite可以以某种方式被视为艺术家。 DirectWrite将“引导”D2D画笔为场景着色。 但具体来说，DirectWrite会告诉D2D如何将文本或字体写入“画布”（渲染目标）。 这是我们初始化DirectWrite（DW）的地方。

我们需要做的第一件事就是创建一个DW Factory，它将创建我们的文本格式。 我们可以通过调用函数DWriteCreateFactory（）来实现这一点，其中第一个参数（就像我们创建D2D Factory时那样）指定是否共享或隔离工厂。 我们指定共享，因为我们将与D2D共享DW。 第二个参数是我们给出DW Factory对象指针的对象的接口ID。 最后一个参数是指向我们发送DW Factory指针的接口对象的指针。

`创建字体格式` 

接下来，我们将使用创建的DW Factory为我们的字体创建格式。 我们调用IDWriteFactory接口的CreateTextFormat（）方法来执行此操作。 该函数如下所示：

```c++
HRESULT CreateTextFormat(
  [in]   const WCHAR * fontFamilyName,
         IDWriteFontCollection * fontCollection,
         DWRITE_FONT_WEIGHT  fontWeight,
         DWRITE_FONT_STYLE  fontStyle,
         DWRITE_FONT_STRETCH  fontStretch,
         FLOAT  fontSize,
  [in]   const WCHAR * localeName,
  [out]  IDWriteTextFormat ** textFormat
)
```

成员信息如下：

fontFamilyName  - 这是我们要使用的字体系列的字符串。我们使用的例子是“脚本”。

fontCollection  - 这是一个指向我们从中获取字体的字体集合对象的指针。我们指定NULL来使用系统字体。

fontWeight  - 这是字体的权重（更高的值更粗体）。它是DWRITE_FONT_WEIGHT枚举类型。我们使用DWRITE_FONT_WEIGHT_REGULAR来使用字体系列的正常权重。

fontStyle  - 这是一个DWRITE_FONT_STYLE枚举类型，其中可能的值为：DWRITE_FONT_STYLE_NORMAL，DWRITE_FONT_STYLE_OBLIQUE和DWRITE_FONT_STYLE_ITALIC。

fontStretch  -  DWRITE_FONT_STRETCH枚举类型的值。这是一个从0到9的值（0未定义），其中值越小，字符宽度越相似，值越大，字符宽度越扩展或拉伸。尝试玩它。

fontSize  - 这是一个表示DIP中字体大小的值（“与设备无关的像素”.DIP是1/96英寸（根据msdn，hehe）。基本上如果你曾经使用过微软的word或wordpad或其他一些像那样的文本编辑软件，字体大小与那些字体大小相同，例如默认大小为12或者其他。

localeName  - 指定字体语言的字符串。如果您能够学习本课程，那么将“en-us”放在这里可能是安全的。

textFormat  - 这是返回指向IDWriteTextFormat对象的指针，该对象将存储字体格式。

```c++
hr = DWriteFactory->CreateTextFormat(
    L"Script",
    NULL,
    DWRITE_FONT_WEIGHT_REGULAR,
    DWRITE_FONT_STYLE_NORMAL,
    DWRITE_FONT_STRETCH_NORMAL,
    24.0f,
    L"en-us",
    &TextFormat
    );
```

`字体对其`

接下来，我们将告诉DW如何在我们稍后指定的矩形中对齐我们的字体。首先，我们指定文本的水平对齐方式。我们通过调用函数IDWriteTextFormat :: SetTextAlignment（）并从DWRITE_TEXT_ALIGNMENT枚举类型中指定一个值来完成此操作。要将文本对齐到矩形的左侧，我们可以指定DWRITE_TEXT_ALIGNMENT_LEADING，否则我们可以将其居中或将其对齐到三角形的右侧。你可以看一下unermation值。

接下来我们指定垂直对齐，它们称为段对齐。我们通过调用函数IDWriteTextFormat :: SetParagraphAlignment（）来做到这一点。我们将参数设置为DWRITE_PARAGRAPH_ALIGNMENT枚举类型中的值。要使段落与矩形的顶部对齐，我们指定DWRITE_PARAGRAPH_ALIGNMENT_NEAR。我们也可以指定DWRITE_PARAGRAPH_ALIGNMENT_CENTER将段落置于矩形的中心，或者DWRITE_PARAGRAPH_ALIGNMENT_FAR将段落与矩形的底部对齐。

```c++
hr = TextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
hr = TextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
```

`初始化场景以及显示D2D`

这是我们将创建一个将覆盖我们的场景并将其存储在索引和顶点缓冲区中的方块。 然后从D2D和D3D 10.1将呈现的共享纹理创建着色器资源视图。 然后，我们可以使用此着色器资源视图来构建覆盖场景的正方形，并应用混合，以便只有任何D2D绘制到纹理（字体）才可见。 （混合将在下一个新功能中完成）

```c++
void InitD2DScreenTexture()
{
    //Create the vertex buffer
    Vertex v[] =
    {
        // Front Face
        Vertex(-1.0f, -1.0f, -1.0f, 0.0f, 1.0f),
        Vertex(-1.0f,  1.0f, -1.0f, 0.0f, 0.0f),
        Vertex( 1.0f,  1.0f, -1.0f, 1.0f, 0.0f),
        Vertex( 1.0f, -1.0f, -1.0f, 1.0f, 1.0f),
    };

    DWORD indices[] = {
        // Front Face
        0,  1,  2,
        0,  2,  3,
    };

    D3D11_BUFFER_DESC indexBufferDesc;
    ZeroMemory( &indexBufferDesc, sizeof(indexBufferDesc) );

    indexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
    indexBufferDesc.ByteWidth = sizeof(DWORD) * 2 * 3;
    indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
    indexBufferDesc.CPUAccessFlags = 0;
    indexBufferDesc.MiscFlags = 0;

    D3D11_SUBRESOURCE_DATA iinitData;

    iinitData.pSysMem = indices;
    d3d11Device->CreateBuffer(&indexBufferDesc, &iinitData, &d2dIndexBuffer);


    D3D11_BUFFER_DESC vertexBufferDesc;
    ZeroMemory( &vertexBufferDesc, sizeof(vertexBufferDesc) );

    vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
    vertexBufferDesc.ByteWidth = sizeof( Vertex ) * 4;
    vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
    vertexBufferDesc.CPUAccessFlags = 0;
    vertexBufferDesc.MiscFlags = 0;

    D3D11_SUBRESOURCE_DATA vertexBufferData; 

    ZeroMemory( &vertexBufferData, sizeof(vertexBufferData) );
    vertexBufferData.pSysMem = v;
    hr = d3d11Device->CreateBuffer( &vertexBufferDesc, &vertexBufferData, &d2dVertBuffer);

    //Create A shader resource view from the texture D2D will render to,
    //So we can use it to texture a square which overlays our scene
    d3d11Device->CreateShaderResourceView(sharedTex11, NULL, &d2dTexture);
}
```

`创建覆盖广场`

我们在这个新功能中做的第一件事情就是创建将在场景顶部进行操作的方块。这些都不是新的。但是我们将它存储在另一个顶点和索引缓冲区中。

```c++
Vertex v[] =
{
    Vertex(-1.0f, -1.0f, -1.0f, 0.0f, 1.0f),
    Vertex(-1.0f,  1.0f, -1.0f, 0.0f, 0.0f),
    Vertex( 1.0f,  1.0f, -1.0f, 1.0f, 0.0f),
    Vertex( 1.0f, -1.0f, -1.0f, 1.0f, 1.0f),
};

DWORD indices[] = {
    0,  1,  2,
    0,  2,  3,
};

D3D11_BUFFER_DESC indexBufferDesc;
ZeroMemory( &indexBufferDesc, sizeof(indexBufferDesc) );

indexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
indexBufferDesc.ByteWidth = sizeof(DWORD) * 2 * 3;
indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
indexBufferDesc.CPUAccessFlags = 0;
indexBufferDesc.MiscFlags = 0;

D3D11_SUBRESOURCE_DATA iinitData;

iinitData.pSysMem = indices;
d3d11Device->CreateBuffer(&indexBufferDesc, &iinitData, &d2dIndexBuffer);

D3D11_BUFFER_DESC vertexBufferDesc;
ZeroMemory( &vertexBufferDesc, sizeof(vertexBufferDesc) );

vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
vertexBufferDesc.ByteWidth = sizeof( Vertex ) * 4;
vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
vertexBufferDesc.CPUAccessFlags = 0;
vertexBufferDesc.MiscFlags = 0;

D3D11_SUBRESOURCE_DATA vertexBufferData; 

ZeroMemory( &vertexBufferData, sizeof(vertexBufferData) );
vertexBufferData.pSysMem = v;
hr = d3d11Device->CreateBuffer( &vertexBufferDesc, &vertexBufferData, &d2dVertBuffer);
```

`从共享纹理创建着色器资源视图`

着色器资源视图不一定是新概念，因为我们已经在纹理课程中介绍了这一点，当我们从文件中的图像创建新的着色器资源视图时。但是，这次我们不是从文件创建它（实际上更简单一点）。我们正在使用D2D和D3D 10.1呈现的共享D3D 11纹理创建它。我们可以通过调用函数ID3D11Device :: CreateShaderResourceView（）来实现这一点，其中第一个参数是我们从（我们的共享纹理）获取着色器资源视图的资源，如果我们要填写D3D11_SHADER_RESOURCE_VIEW_DESC结构，则使用第二个参数描述我们如何想要资源数据。我们可以将此参数设置为NULL以从资源获取所有数据。最后一个参数是一个指向ID3D11ShaderResourceView对象的指针，该对象将存储指向资源的指针（我们的共享纹理）。现在我们可以使用ID3D11ShaderResourceView来纹理我们刚制作的方块。

```c++
d3d11Device->CreateShaderResourceView(sharedTex11, NULL, &d2dTexture);
```

`在我们的场景中调用函数初始化渲染D2D`

这里我们在InitScene（）函数中从上面调用该函数。

```c++
InitD2DScreenTexture();
```

`修改混合描述`

对于要在正方形上呈现的共享纹理（仅显示文本，并且纹理的其余部分“掩盖”我们的场景），我们需要更改混合描述以确保alpha值 在共享纹理中使纹理的背景“透明”。 我们可以通过将DestBlend成员设置为D3D11_BLEND_INV_SRC_ALPHA来完成此操作。 你可以自由地玩这个，看看是否有更好的东西，但从我玩过的，这是最好的。

```c++
D3D11_RENDER_TARGET_BLEND_DESC rtbd;
ZeroMemory( &rtbd, sizeof(rtbd) );

rtbd.BlendEnable             = true;
rtbd.SrcBlend                 = D3D11_BLEND_SRC_COLOR;
///////////////**************new**************////////////////////
rtbd.DestBlend                 = D3D11_BLEND_INV_SRC_ALPHA;
///////////////**************new**************////////////////////
rtbd.BlendOp                 = D3D11_BLEND_OP_ADD;
rtbd.SrcBlendAlpha             = D3D11_BLEND_ONE;
rtbd.DestBlendAlpha             = D3D11_BLEND_ZERO;
rtbd.BlendOpAlpha             = D3D11_BLEND_OP_ADD;
rtbd.RenderTargetWriteMask     = D3D10_COLOR_WRITE_ENABLE_ALL;
```

`接口清理`

```c++
void CleanUp()
{
    //Release the COM Objects we created
    SwapChain->Release();
    d3d11Device->Release();
    d3d11DevCon->Release();
    renderTargetView->Release();
    squareVertBuffer->Release();
    squareIndexBuffer->Release();
    VS->Release();
    PS->Release();
    VS_Buffer->Release();
    PS_Buffer->Release();
    vertLayout->Release();
    depthStencilView->Release();
    depthStencilBuffer->Release();
    cbPerObjectBuffer->Release();
    Transparency->Release();
    CCWcullMode->Release();
    CWcullMode->Release();

    ///////////////**************new**************////////////////////
    d3d101Device->Release();
    keyedMutex11->Release();
    keyedMutex10->Release();
    D2DRenderTarget->Release();    
    Brush->Release();
    BackBuffer11->Release();
    sharedTex11->Release();
    DWriteFactory->Release();
    TextFormat->Release();
    d2dTexture->Release();
    ///////////////**************new**************////////////////////
}
```

`渲染字体`

当我们想要将字体渲染到场景时，我们可以调用此函数。 当然，您可以将参数更改为您想要的任何参数，例如接受浮动值（我们将在下一课中进行操作，跟踪FPS），或者可能是文本的位置（您可以调用的方式） 如果您希望屏幕上的文字位于不同的地方，则此功能不止一次）。

```c++
void RenderText(std::wstring text)
{
    //Release the D3D 11 Device
    keyedMutex11->ReleaseSync(0);

    //Use D3D10.1 device
    keyedMutex10->AcquireSync(0, 5);            

    //Draw D2D content        
    D2DRenderTarget->BeginDraw();    

    //Clear D2D Background
    D2DRenderTarget->Clear(D2D1::ColorF(0.0f, 0.0f, 0.0f, 0.0f));

    //Create our string
    std::wostringstream printString; 
    printString << text;
    printText = printString.str();

    //Set the Font Color
    D2D1_COLOR_F FontColor = D2D1::ColorF(1.0f, 1.0f, 1.0f, 1.0f);

    //Set the brush color D2D will use to draw with
    Brush->SetColor(FontColor);    

    //Create the D2D Render Area
    D2D1_RECT_F layoutRect = D2D1::RectF(0, 0, Width, Height);

    //Draw the Text
    D2DRenderTarget->DrawText(
        printText.c_str(),
        wcslen(printText.c_str()),
        TextFormat,
        layoutRect,
        Brush
        );

    D2DRenderTarget->EndDraw();    

    //Release the D3D10.1 Device
    keyedMutex10->ReleaseSync(1);

    //Use the D3D11 Device
    keyedMutex11->AcquireSync(1, 5);

    //Use the shader resource representing the direct2d render target
    //to texture a square which is rendered in screen space so it
    //overlays on top of our entire scene. We use alpha blending so
    //that the entire background of the D2D render target is "invisible",
    //And only the stuff we draw with D2D will be visible (the text)

    //Set the blend state for D2D render target texture objects
    d3d11DevCon->OMSetBlendState(Transparency, NULL, 0xffffffff);

    //Set the d2d Index buffer
    d3d11DevCon->IASetIndexBuffer( d2dIndexBuffer, DXGI_FORMAT_R32_UINT, 0);
    //Set the d2d vertex buffer
    UINT stride = sizeof( Vertex );
    UINT offset = 0;
    d3d11DevCon->IASetVertexBuffers( 0, 1, &d2dVertBuffer, &stride, &offset );

    WVP =  XMMatrixIdentity();
    cbPerObj.WVP = XMMatrixTranspose(WVP);    
    d3d11DevCon->UpdateSubresource( cbPerObjectBuffer, 0, NULL, &cbPerObj, 0, 0 );
    d3d11DevCon->VSSetConstantBuffers( 0, 1, &cbPerObjectBuffer );
    d3d11DevCon->PSSetShaderResources( 0, 1, &d2dTexture );
    d3d11DevCon->PSSetSamplers( 0, 1, &CubesTexSamplerState );

    d3d11DevCon->RSSetState(CWcullMode);
    //Draw the second cube
    d3d11DevCon->DrawIndexed( 6, 0, 0 );    
}
```

`让D3D 11释放纹理所以D3D 10.1可以获得它`

这个函数的第一件事是从D3D 11的使用中释放共享纹理。请注意，我们使用参数的“0”键释放它。

D3D 11发布共享纹理后，我们使用D3D 10.1设备获取它。注意我们如何用参数的“0”键获取它。第二个参数表示如果当前释放键不是“0”，则在尝试再次获取它之前等待5毫秒。

如果我们的程序在多个线程中运行，并且使用三个设备（D3D 11，D3D 10.1-1，D3D 10.1-2）进行渲染，并且我们的程序设置为首先D3D 11渲染到纹理，那么我们需要D3D 10.1-1来渲染一些东西，最后D3D 10.1-2需要使用共享纹理来完成渲染（按此顺序）。好吧，也许在一个线程中，D3D 11调用AcquireSync（0,5）;并获取纹理，所以它现在使用纹理。在另一个线程中，D3D 10.1-1调用AcquireSync（1,5）;但是D3D 11仍在使用纹理，因此它在调用AcquireSync（1,5）之前等待5毫秒;再次（因此它每隔5毫秒继续调用此函数）。最后，D3D 11完成使用纹理并调用ReleaseSync（1）;但是在另一个线程中，D3D 10.1-2调用AcquireSync（2,5）; D3D 10.1-1在再次调用该函数之前仍在等待5 ms。幸运的是，我们有这些获取和释放键，因此D3D 11已经使用“1”键释放了纹理，纹理等待用“1”键获取。 D3D 10.1-2称为AcquireSync（2,5）;因此在使用“2”键释放纹理之前，它不会获取纹理。现在D3D 10.1-1调用AcquireSync（1,5）;再次，并且能够获得纹理，因为它最终用“1”键释放。使用纹理后，D3D 10.1-1调用ReleaseSync（2）;.从现在开始使用“2”键释放纹理，D3D 10.1-2最终能够在调用AcquireSync（2,5）之后获取纹理。再次。 D3D 10.1-2使用纹理完成其工作并调用ReleaseSync（0）;使用“0”键释放纹理，然后D3D 11可以通过调用AcquireSync（0,5）;再次获取纹理。这可确保在使用多个线程时设备不会无序地获取纹理。

哇，我希望我的探索并没有使你对获取和释放共享纹理的目的的理解变得复杂化。

```c++
//Release the D3D 11 Device
keyedMutex11->ReleaseSync(0);
//Use D3D10.1 device
keyedMutex10->AcquireSync(0, 5);    
```

`使用D2D开始绘制`

现在我们已经使用D3D 10.1设备获得了纹理，我们需要告诉D2D开始绘图。 我们使用ID2D1RenderTarget :: BeginDraw（）函数执行此操作。

```c++
//Draw D2D content        
D2DRenderTarget->BeginDraw();    
```

`清除共享纹理背景`

现在我们使用D2D将共享目标背景清除为黑色并使用ZERO alpha。 尝试使用0.5f或1.0f作为alpha值来查看发生了什么（四个颜色值中的最后一个）。 我们可以通过调用ID2DRenderTarget :: Clear（）函数来清除渲染目标（在本例中为共享纹理），其中唯一的参数是通过调用函数D2D1 :: ColorF（）创建的D2D1_COLOR_F结构。

```c++
//Clear D2D Background
D2DRenderTarget->Clear(D2D1::ColorF(0.0f, 0.0f, 0.0f, 0.0f));
```

`创建将呈现给屏幕的字符串（文本）`

这是我们创建将呈现给屏幕的字符串的地方。 如果您对字符串知之甚少，我们使用的是wostringstream类型，它允许我们在其中输入字符串的“流”（这样我们可以将字符串放在一起，就像一些文本，然后可能是一个intiger，然后 也许是一个换行符来开始一个新的文本行（“\ n”）。我们将在下一课中显示FPS时这样做。 然后我们将该字符串流放入printText字符串中，该字符串将被绘制到屏幕上，或更多，“绘制”。

```c++
//Create our string
std::wostringstream printString; 
printString << text;
printText = printString.str();
```

`设置D2D画笔颜色`

接下来我们要做的是创建一种颜色，然后将D2D画笔设置为该颜色。 我们创建一个名为FontColor的D2D1_COLOR_F，并通过调用函数D2D1 :: ColorF（）来设置它。 我们给它一个白色（确保alpha值，4个值中的最后一个不是0.0f，或者由于我们的混合你不会看到字体）。

在我们创建颜色之后，我们通过调用函数ID2D1SolidColorBrush :: SetColor（）并使用我们刚创建的颜色作为唯一参数，将D2D画笔设置为该颜色。

```c++
//Set the Font Color
D2D1_COLOR_F FontColor = D2D1::ColorF(1.0f, 1.0f, 1.0f, 1.0f);
//Set the brush color D2D will use to draw with
Brush->SetColor(FontColor);    
```

`创建一个将绘制字体的矩形`

此行创建一个矩形（D2D1_RECT_F），用于指定文本在屏幕上的呈现位置。 我们通过调用D2D1 :: RectF（）创建矩形，其中第一个参数是客户区左侧矩形的左侧（以像素为单位）。 第二个参数是从矩形顶部到客户区顶部的距离（以像素为单位）。 第三个基本上是矩形的宽度，而最后一个参数是矩形的高度。

```c++
//Create the Text Render Area
D2D1_RECT_F layoutRect = D2D1::RectF(0, 0, Width, Height);
```

`绘制字体`

现在，在所有这些之后，我们可以最终绘制字体！ （不幸的是，这不是最后一步......）。 我们可以通过调用函数ID2D1RenderTarget :: DrawText（）来绘制文本：

```c++
void DrawText(
  [in]   WCHAR *string,
         UINT stringLength,
  [in]   IDWriteTextFormat *textFormat,
  [ref]  const D2D1_RECT_F &layoutRect,
  [in]   ID2D1Brush *defaultForegroundBrush,
         D2D1_DRAW_TEXT_OPTIONS options = D2D1_DRAW_TEXT_OPTIONS_NONE,
         DWRITE_MEASURING_MODE measuringMode = DWRITE_MEASURING_MODE_NATURAL
);
```

每个成员参数如下：

string  - 这是我们要显示的字符串。

stringLength  - 这是字符串的长度。我们通过调用scslen（）找到字符串的长度。

textFormat  - 这是DirectWrite最终进入的地方。这是我们在初始化时使用DirectWrite创建的文本格式。

layoutRect  - 这是一个矩形，描述了我们要将文本渲染到的客户区域上的矩形。我们将把上面创建的矩形放在这里。

defaultForegroundBrush  - 这是指向我们在初始化D2D时创建的画笔的指针。我们将其颜色设置在上方。

options  - 这是一个D2D1_DRAW_TEXT_OPTIONS枚举类型，说明是否应该将文本捕捉到像素，如果文本超出上述参数中的矩形，则应该剪切文本。如您所见，此方法是选项，如果未指定此参数，则使用默认值D2D1_DRAW_TEXT_OPTIONS_NONE。默认参数表示文本应该捕捉到像素，如果文本超出矩形，则不会剪切文本。

measuringMode  - 这是一个DWRITE_MEASURING_MODE枚举类型，与测量带有用于格式化的字形度量的文本有关。它也是一个可选参数，如果未指定，则使用默认值DWRITE_MEASURING_MODE_NATURAL。

```c++
//Draw the Text
D2DRenderTarget->DrawText(
    printText.c_str(),
    wcslen(printText.c_str()),
    TextFormat,
    layoutRect,
    Brush
    );
```

`停止使用D2D绘图`

我们可以调用函数停止使用D2D绘制。

```c++
D2DRenderTarget->EndDraw();    
```

从D3D 10.1释放共享纹理并使用D3D 11获取它

我们在上面解释了释放和获取纹理时发生的事情。 在这里，我们使用“1”键从D3D 10.1释放纹理，并使用D3D 11的“1”键获取纹理。

```c++
//Release the D3D10.1 Device
keyedMutex10->ReleaseSync(1);

//Use the D3D11 Device
keyedMutex11->AcquireSync(1, 5);
```

`设置混合状态`

在我们用D2D将文本绘制到共享纹理之后，我们需要将它呈现给屏幕。 我们将通过使用从该共享纹理创建的着色器资源对正方形进行纹理化来实现此目的，并将该正方形“覆盖”在我们的场景上，覆盖它。 只是覆盖纹理方块是不够的，我们需要确保它的“透视”，除了我们渲染的文本。 这是我们将设置混合状态的位置，它将纹理与其后面的任何内容混合，具体取决于我们用于纹理多维数据集的着色器资源的alpha值。 请记住，我们将共享纹理清除为0 alpha，并使用1 alpha将文本绘制到纹理。 这样，只有文本可见，而其余的将是完全透明的！ 我们已经知道如何设置混合状态，所以这就是我们这样做的地方。

```c++
//Set the blend state for D2D render target texture objects
d3d11DevCon->OMSetBlendState(Transparency, NULL, 0xffffffff);
```

`将内容绑定到IA`

在我们将几何体的顶点和索引缓冲区绑定到IA之前，我们在初始化场景时就这样做了。 但是，我们现在有多个顶点和索引缓冲区，因此我们需要在绘制几何体之前每次都设置顶点和索引缓冲区。

```c++
//Set the d2d Index buffer
d3d11DevCon->IASetIndexBuffer( d2dIndexBuffer, DXGI_FORMAT_R32_UINT, 0);
//Set the d2d vertex buffer
UINT stride = sizeof( Vertex );
UINT offset = 0;
d3d11DevCon->IASetVertexBuffers( 0, 1, &d2dVertBuffer, &stride, &offset );
```

`将屏幕空间中渲染纹理`

现在，我们讨论了（在之前的课程中）如何渲染几何体并将其放置在世界空间中。 但是我们如何在屏幕空间中实际绘制几何图形，无论我们在哪里移动或进入我们的3D世界，它总是会留在屏幕空间中？ 嗯，答案实际上比你想象的要简单得多。 我们所要做的就是重置WVP并将其发送到着色器！ 我们的屏幕空间在x轴上从-1.0f到1.0f，在y轴上从-1.0f到1.0f。 在屏幕空间中没有深度，因此在创建顶点缓冲区时为z轴设置的值无关紧要。

```c++
WVP =  XMMatrixIdentity();
cbPerObj.WVP = XMMatrixTranspose(WVP);    
d3d11DevCon->UpdateSubresource( cbPerObjectBuffer, 0, NULL, &cbPerObj, 0, 0 );
d3d11DevCon->VSSetConstantBuffers( 0, 1, &cbPerObjectBuffer );
```

`设置着色器资源和采样器状态`

在我们渲染正方形之前的最后一件事，我们需要确保它的纹理与我们的共享纹理。 我们所要做的就是将使用共享纹理创建的着色器资源视图发送到管道的PS阶段。 然后我们设置采样器状态。 我们场景中的所有几何体使用相同的采样器状态，但我们通过在渲染之前确定其设置来明确。 如果未设置采样器状态，则它将使用默认采样器状态。

```c++
d3d11DevCon->PSSetShaderResources( 0, 1, &d2dTexture );
d3d11DevCon->PSSetSamplers( 0, 1, &CubesTexSamplerState );
```

`设置渲染状态，然后绘制正方形`

我们在这个函数中做的最后一件事是渲染正方形。 首先，我们将渲染状态设置为顺时针背面剔除，这意味着渲染的几何形状顺时针方向远离相机，并将被剔除。 我们以逆时针顺序渲染我们的几何（实际上是错误的，但它并不重要），因此这意味着它默认面向我们（根据新设置的顺时针背面剔除渲染状态）。 然后我们终于渲染我们的广场。

```c++
d3d11DevCon->RSSetState(CWcullMode);
//Draw the second cube
d3d11DevCon->DrawIndexed( 6, 0, 0 );    
```
我们最新的代码是在这个函数中，并且......（我真的很高兴这个......）没有太多新代码！我甚至不打算逐行检查，我会让你看看代码。

与我们的旧课程相比，新的第一件事是，我们现在已经在绘制它们之前为渲染场景中的立方体设置了顶点和索引缓冲区。这是因为我在上面说过，我们现在有多个顶点和索引缓冲区，并且必须在绘制几何体之前设置正确的顶点和索引缓冲区。

在此函数的底部，您可以看到新行，它调用渲染文本函数，该函数将使用D2D将文本绘制到共享设备，然后使用共享设备（或实际上使用的着色器资源）它）纹理一个将覆盖我们的场景的正方形！在本课中，我们只使用参数的单个字符串调用该函数。但是，下一课，我们将显示FPS，因此我们需要添加另一个参数来获取表示FPS的intiger变量

```c++
void DrawScene()
{
    //Clear our render target and depth/stencil view
    float bgColor[4] = {(0.0f, 0.0f, 0.0f, 0.0f)};
    d3d11DevCon->ClearRenderTargetView(renderTargetView, bgColor);    
    d3d11DevCon->ClearDepthStencilView(depthStencilView, D3D11_CLEAR_DEPTH|D3D11_CLEAR_STENCIL, 1.0f, 0);

    //Set our Render Target
    d3d11DevCon->OMSetRenderTargets( 1, &renderTargetView, depthStencilView );

    //Set the default blend state (no blending) for opaque objects
    d3d11DevCon->OMSetBlendState(0, 0, 0xffffffff);

    ///////////////**************new**************////////////////////
    //Set the cubes index buffer
    d3d11DevCon->IASetIndexBuffer( squareIndexBuffer, DXGI_FORMAT_R32_UINT, 0);
    //Set the cubes vertex buffer
    UINT stride = sizeof( Vertex );
    UINT offset = 0;
    d3d11DevCon->IASetVertexBuffers( 0, 1, &squareVertBuffer, &stride, &offset );
    ///////////////**************new**************////////////////////

    //Set the WVP matrix and send it to the constant buffer in effect file
    WVP = cube1World * camView * camProjection;
    cbPerObj.WVP = XMMatrixTranspose(WVP);    
    d3d11DevCon->UpdateSubresource( cbPerObjectBuffer, 0, NULL, &cbPerObj, 0, 0 );
    d3d11DevCon->VSSetConstantBuffers( 0, 1, &cbPerObjectBuffer );
    d3d11DevCon->PSSetShaderResources( 0, 1, &CubesTexture );
    d3d11DevCon->PSSetSamplers( 0, 1, &CubesTexSamplerState );

    d3d11DevCon->RSSetState(CWcullMode);
    d3d11DevCon->DrawIndexed( 36, 0, 0 );

    WVP = cube2World * camView * camProjection;
    cbPerObj.WVP = XMMatrixTranspose(WVP);    
    d3d11DevCon->UpdateSubresource( cbPerObjectBuffer, 0, NULL, &cbPerObj, 0, 0 );
    d3d11DevCon->VSSetConstantBuffers( 0, 1, &cbPerObjectBuffer );
    d3d11DevCon->PSSetShaderResources( 0, 1, &CubesTexture );
    d3d11DevCon->PSSetSamplers( 0, 1, &CubesTexSamplerState );

    d3d11DevCon->RSSetState(CWcullMode);
    d3d11DevCon->DrawIndexed( 36, 0, 0 );

    ///////////////**************new**************////////////////////
    RenderText(L"Hello World");
    ///////////////**************new**************////////////////////

    //Present the backbuffer to the screen
    SwapChain->Present(0, 0);
}
```

这节课花了比我希望的更长的时间，但现在我们终于可以在屏幕上呈现文字！

如果我做错了什么，你发现了错误，或者知道更有效的做事方式，请随时告知或告诉我。 我非常感谢任何一种反馈，因为它需要一段时间才能放在一起;）









