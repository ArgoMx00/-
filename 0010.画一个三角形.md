
在这里，我们将学习绘制一个简单的蓝色三角形！在我们真正开始之前，我们需要介绍D3D的实际工作方式。我尽可能的在尽可能短的时间内完成这部分讲解。
，同时尽可能的采取最有意义的步骤。我认为他们的效率更高。

`可编程的图形渲染管道`

如果你有使用D3D 10的经验，并且了解管道，你几乎可以跳过这段讲解。因为Dx11基本上是Dx10的拓展。他们使用相同的管道。但是又几个额外的阶段。
D3D 11为可编程图形管道增加了3个新的阶段。不仅仅如此。它还支持另一个独立但松散连接的管道。称为计算着色器通道。图形渲染管道中的三个新阶段
是Hull，Tesselator和Domain着色器。他们与tesselation有关，它基本上为对象添加了更多的细节。他的作用例如是从模型中取一个简单的三角形，
它可能会添加一些顶点以创建更多的三角形，然后重新定位顶点以使三角形更加详细。它可以采用简单的低Pollygon模型，并在屏幕上显示的时候将其转换
为非常详细的高polly模型。它可以非常快速有效的完成所有这些工作。这是一个高级主题。但是我们不会在本课程中学习如何实现。

计算着色器用于通过GPU作为一种并行处理器来拓展CPU的处理能力，从而进行极快的计算。这不一定与图形有任何关系。例如，您可以使用计算着色器管道
在GPU上执行性能极高的操作。例如准确的碰撞检测。本课程不讨论计算着色器。

渲染管道是D3D用于根据虚拟摄像机看到的内容创建2D图像的一组步骤。它包括D3D 10中使用的7个阶段。以及伴随D3D 11的三个新的阶段，如下所示：

1.输入汇编（IA）阶段
2.顶点着色器（VS）阶段
3. Hull Shader（HS）舞台
4. Tesselator Shader（TS）阶段
5.域着色器（DS）阶段
6.几何着色器（GS）阶段
7.流输出（SO）阶段
8.光栅化器（RS）阶段
9.像素着色器（PS）舞台
10.输出合并（OM）阶段

另外一件事是我们现在必须编译每个着色器。这可以确保着色器没有错误。此外，我们可以在代码中随时设置各个着色器，而不是将效果文件中的技术设置为
活动技术。我相信这是一种更加动态的方法，因为我们有更多的自由来更改活动着色器，同时保持其他人作为活动着色器。例如我们可以使用光照计算更改
像素着色器，以确定不使用光照方程的像素着色器的最终像素颜色，同时仍保持相同的顶点着色器处于活动状态。

圆形舞台是可编程的舞台，我们实际上是自己创作的。方形阶段是我们不编程的阶段，但我们可以使用D3D11设备上下文更改其设置。

`输入汇编（IA）阶段`

您可以看到的第一个阶段是输入汇编（IA）程序。IA是一个固定的功能阶段，这意味着我们不进行编程来实现它，IA读取集合数据。
顶点和指数。然后，他使用数据创建几何图元，如traingles，square等。这些图形将被输入到其他阶段并且由其他阶段来进行使用、
索引定义了如何通过顶点将基元放在一起。我们将在后边的课程中讨论索引。

在我们向IA发送内容之前，我们需要先做一些事情，例如创建缓冲区并设置原始拓扑，输入布局和活动缓冲区。

首先，我们创建一个缓冲区。IA使用的两个缓冲区是顶点和索引缓冲区。在本课程中，我们不会担心索引缓冲区。要创建缓冲区。我们
将填写D3D11_BUFFER_DESC结构。

在创建缓冲区或者在创建缓冲区之后，我们需要创建输入布局对象。这样做是告诉D3D我们的椎骨结构是由什么组成的。以及如何处理我们
的定点结构中的每个组件。我们使用D3D11_INPUT_ELEMENT_DESC元素数组向D3D提供信息。D3D11_INPUT_ELEMENT_DESC数组中的
每个元素描述定点结构中的一个元素，那么您的Vertex结构有一个posision元素和一个color元素。那么您的D3D_INPUT_ELEMENT_D
ESC数组将有一个元素用于位子。另一个元素用于颜色。下边就是一个例子：

```c++
//The vertex Structure
struct Vertex
{
    D3DXVECTOR3 pos;
    D3DXCOLOR   color;
};


//The input-layout description
D3D11_INPUT_ELEMENT_DESC layout[] =
{
    {"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0},
    {"COLOR",    0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0}
};
```

在本课程中，我们的顶点结构如下所示：

```Sc++
struct Vertex    //Overloaded Vertex Structure
{
    Vertex(){}
    Vertex(float x, float y, float z)
        : pos(x,y,z){}

    XMFLOAT3 pos;
};
```

所以我们的输出布局如下所示：

```c++
D3D11_INPUT_ELEMENT_DESC layout[] =
{
    { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },  
};
```

在使用D3D11_INPUT_ELEMENT_DESC结构描述输入布局之后，我们需要使用以下函数来创建他：

```c++
ID3D11Device::CreateInputLayout()
```

我们还需要创建一个顶点缓冲区来保存我们的对象顶点。要创建顶点缓冲区，首先我们使用D3D11_BUFFER_DESC结构描述
缓冲区，然后使用实际顶点来填充D3D_SUBRESOURCE_DATA结构。要实际创建顶点缓冲区，我们可以调用：

```c++
ID3D11DeviceContext::IASetVertexBuffers()
ID3D11DeviceContext::IASetInputLayout()
```

现在我们需要设置原始拓扑，以便IA知道如何使用顶点并且声称诸如三角形或者线条之类的内容，我们叫做功能：

```c++
ID3D11DeviceContext::IASetPrimitiveTopology()
```

我们将在本课后边介绍不同的类型。
在我们的管道准备好之后，我们调用Draw方法将愿语发送到IA，我们本课程中称之为方法是：

```c++
ID3D11DeviceContext::Draw()
```

顶点着色器（VS）阶段

VS是第一个可编程着色器，这意味着我们必须自己编程。VS阶段是在AI中组装基元之后所有顶点必须经过的。绘制的每个顶点都
将通过VS，使用VS，您可以执行转换，缩放，光照，纹理的位移贴图等操作。必须始终实现顶点着色器才能使得管道工作。即使
程序中的顶点不需要修改也是如此。管道中的着色器使用HLSL语言编写。该语言类似于C++语法，因此学习起来并不难。我们将在
每节课中解释效果文件，我们将对其进行更改，之后我们将专门介绍HLSL课程，对于本课程，我们的顶点着色器不执行任何操作，
因此我们只返回每个定点的额位子而不进行更改：

```HLSL
float4 VS(float4 inPos:POSITION):SV_POSION
{
  return inPos;
}
```

顶点着色器将单个顶点作为输入，并且返回单个输出。请注意，VS参数中POS之后的POSSTION。当我们创建顶点布局的时候，我们
为顶点的位子指定POSITION，因此他们讲被发送到VS中的此参数。如果需要，您可以从POSITION更改名称。

`Pixel Shader（PS）舞台`

此阶段会计算并修改将在屏幕上显示的每个像素，例如每个像素基础上的照明。他是另一个可编程的功能，也是一个可选的阶段。
像素着色器的工作是计算每个像素片段的颜色。像素片段是将被绘制到屏幕的每个像素。
我们举出一个例子:

```HLSL
float4 PS():SV_TARGET
{
  return float4(0.0f,0.0f,1.0f,1.0f);
}
```

在这里，我们创建了几个新的接口对象。请记住，完成后必须释放界面对象。第一个是缓冲区，它将保存我们的顶点数据。接下来的
两个是我们的顶点和像素着色器。之后我们有顶点和像素缓冲区，他们将保存有关顶点和像素着色器信息。最后一个是我们的输入布局。

```c++
ID3D11Buffer* triangleVertBuffer;
ID3D11VertexShader* VS;
ID3D11PixelShader* PS;
ID3D10Blob* VS_Buffer;
ID3D10Blob* PS_Buffer;
ID3D11InputLayout* vertLayout;
```


