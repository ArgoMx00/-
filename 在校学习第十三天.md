接下来我们尝试右键点击一个点，在其周围生成一片水域，并使其按照物理流动原理进行流动。

一、首先我们分析整个任务需要的一些点。

①右键点选一个点，将其周围的点的水高提升固定高度，即将该点周围生成一片水域，这里肯定要用到Mesh网格编程的内容。
我们每个水的点依旧以一个水柱来构成。

②接下来我们沿用之前的做法，将周围的点框起来，做一个一个的小小的水柱出来，先绘制在地图上。

③接下来我们考虑加入物理元素，将水Update起来绘制Mesh图。

二、我们将静态水柱建立出来。

①我们将高度图分成两部分，一部分是地形高度图，一部分是水的高度图，那么对于点【i，j】来讲，其实际总高度为两者相加的高度。

②接下来我们将静态的水柱画出来，代码总结一哈

```c#
DynamicCreateTerrain.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class DynamicCreateTerrain : MonoBehaviour
{

    /********************************************************************/
    //注意重新将脚本拖入GameObject的时候，将初始化的东西都要初始化一下。
    //首先我们需要采集地形信息，所以我们首先创建出来一个terrainData
    //用来存储需要采集的地形的信息。
    //TerrainData类中元素：http://www.manew.com/youxizz/2763.html
    public TerrainData terrainData;
    public GameObject Water;
    //当前高度图
    private float[,] heightmaps;
    //还原高度图（运行时候初始高度图）
    private float[,] returnheightmaps;
    //水的高度图
    private float[,] waterheightmaps;

    //得到在代码中的长和宽。
    int width;
    int length;

    //鼠标点击的点
    Vector3 P;
    //实际地形图中的信息：
    //地形宽度、地形长度、地形高度、地形分辨率。
    public int realWidth;
    public int realLength;
    public int realHeight;
    public int heightResolution;


    //用于保存收集点的信息
    int cnt;
    Vector3[] m_vp3River = new Vector3[10000];
    Vector3[] Tm_vp3River = new Vector3[10000];
    //河流的深度
    public float RiverDepth;
    //预设坡度、如果大于坡度降低的高度值。
    public float Slope_Val;
    public float Height_Del;
    //凹河床周围点的范围
    public int AAwidth;
    public int AAlength;

    //判断是否是右键点击的功能
    int IsRight;
    /********************************************************************/





    /********************************************************************/
    void Start()
    {
        IsRight = 0;
        cnt = 0;
        GetHeightmaps();
        //Change();
    }
    private void Update()
    {
        if(IsRight==1)
        {
            IsRight = 0;
            print("右键功能实现开始");
            GameObject.Instantiate(Water, new Vector3(0, 0, 0), transform.rotation);
            BuildFirstWater();
            cnt = 0;
        }
        if (Input.GetKey(KeyCode.Space))
        {
            if (cnt > 0)
            {
                Psort();
                FirstUpdateRiver();
                SecondUpdateRiver();
                GameObject.Instantiate(Water, new Vector3(0, 0, 0), transform.rotation);
                //FindEdge();
                FindAllEdge();
                cnt = 0;
            }
        }
        if (Input.GetKey(KeyCode.Escape))
        {
            terrainData.SetHeights(0, 0, returnheightmaps);
            heightmaps = terrainData.GetHeights(0, 0, width, length);
        }
    }
    void BuildFirstWater()
    {
        waterheightmaps= terrainData.GetHeights(0, 0, width, length);
        for (int i=0;i<width;i++)
        {
            for(int j=0;j<length;j++)
            {
                waterheightmaps[i, j] = 0;
            }
        }
        
        for(int z=0;z<cnt;z++)
        {
            int tx = GetiX(m_vp3River[z]);
            int tz = GetiZ(m_vp3River[z]);
            for(int i=tx-AAwidth;i<=tx+AAwidth;i++)
            {
                for(int j=tz-AAlength;j<=tz+AAlength;j++)
                {
                    waterheightmaps[i, j] += 0.1f;
                }
            }
        }
        //GameObject.Find("WaterBasicDaytime(Clone)");
        GameObject.Find("WaterBasicDaytime(Clone)").SendMessage("GetWaterheightmaps",waterheightmaps);
        GameObject.Find("WaterBasicDaytime(Clone)").SendMessage("GetTerrainheightmaps", heightmaps);
        GameObject.Find("WaterBasicDaytime(Clone)").SendMessage("GetrealWidth", realWidth);
        GameObject.Find("WaterBasicDaytime(Clone)").SendMessage("GetrealLength", realLength);
        GameObject.Find("WaterBasicDaytime(Clone)").SendMessage("GetrealHeight", realHeight);
        GameObject.Find("WaterBasicDaytime(Clone)").SendMessage("GetheightResolution", heightResolution);

}
    //得到当前地形的高度图。
    void GetHeightmaps()
    {
        width = terrainData.heightmapWidth;
        length = terrainData.heightmapHeight;
        heightmaps = terrainData.GetHeights(0, 0, width, length);
        returnheightmaps = terrainData.GetHeights(0, 0, width, length);
        //print(width + "---" + height);
    }
    //得到鼠标点选的点。
    void GetP(Vector3 P)
    {
        print("调用成功,得到鼠标点击点：  " + P.x + " -- " + P.y + " -- " + P.z);
        //拿到点选的点的信息之后，我们将其保存起来。
        m_vp3River[cnt].x = P.x;
        m_vp3River[cnt].y = P.y;
        m_vp3River[cnt].z = P.z;
        cnt++;
    }
    void RightYes(int value)
    {
        IsRight = value;
    }
    /********************************************************************/





    /********************************************************************/
    //将指定范围内点提升到指定高度。
    void Change()
    {
        for (int i = 0; i < width; i++)
        {
            for (int j = 0; j < length; j++)
            {
                heightmaps[i, j] = 0;
            }
        }
        terrainData.SetHeights(0, 0, heightmaps);
    }
    /********************************************************************/





    /********************************************************************/
    //初步处理出河床
    //首先将所有采集到的点按照高度排序。
    void Psort()
    {
        //我们应该先将收集到的所有点按照高度排序。考虑到当前点的个数不多，我们先按照冒泡排序去处理、
        //将数组高度处理为递减数组（地势高的放在数组前边）。
        for (int i = 0; i < cnt; i++)
        {
            for (int j = i; j < cnt; j++)
            {
                if (j + 1 < cnt && j < cnt)
                {
                    if (m_vp3River[j].y < m_vp3River[j + 1].y)
                    {
                        Vector3 Temp;
                        Temp = m_vp3River[j];
                        m_vp3River[j] = m_vp3River[j + 1];
                        m_vp3River[j + 1] = Temp;
                    }

                }
            }
        }
        int tmpcnt = 0;
        //去重点，防止影响排序等做法的时间复杂度。
        for (int i = 0; i < cnt; i++)
        {
            if (i == 0)
            {
                Tm_vp3River[tmpcnt++] = m_vp3River[i];
            }
            else
            {
                if (m_vp3River[i] == m_vp3River[i - 1])
                {
                    continue;
                }
                else
                {
                    Tm_vp3River[tmpcnt++] = m_vp3River[i];
                }
            }
        }
        for (int i = 0; i < tmpcnt; i++)
        {
            m_vp3River[i] = Tm_vp3River[i];
        }
        cnt = tmpcnt;
        print("所有点选点的信息：");
        for (int i = 0; i < cnt; i++)
        {
            print(m_vp3River[i].x + " - " + m_vp3River[i].y + " - " + m_vp3River[i].z);
        }
    }

    //初步保证河流高度不可逆
    void FirstUpdateRiver()
    {
        print(cnt);
        for (int i = 0; i < cnt; i++)
        {
            int tx = GetiX(m_vp3River[i]);
            int tz = GetiZ(m_vp3River[i]);
            m_vp3River[i].y -= RiverDepth;
            if (i > 0 && m_vp3River[i].y >= m_vp3River[i - 1].y)
            {
                m_vp3River[i].y = m_vp3River[i - 1].y - 0.0001f * realHeight;
            }
            float ty = GetiY(m_vp3River[i]);
            heightmaps[tz, tx] = ty;
        }
        terrainData.SetHeights(0, 0, heightmaps);
    }
    /********************************************************************/




    /********************************************************************/
    void SecondUpdateRiver()
    {
        for (int i = 0; i < cnt; i++)
        {
            int tx = GetiX(m_vp3River[i]);
            int tz = GetiZ(m_vp3River[i]);
            int flag;
            int ccnt = 0;
            while (true)
            {
                ccnt++;
                flag = 0;
                for (int iX = tx - AAwidth; iX <= tx + AAwidth; iX++)
                {
                    for (int iZ = tz - AAlength; iZ <= tz + AAlength; iZ++)
                    {
                        if (iX >= 0 && iX < width && iZ >= 0 && iZ < length)
                        {
                            if (iX == tx && iZ == tz) continue;
                            float Fslope;
                            //两点之间坡度的计算公式：(两点之间高度差)/(两点之间水平距离)
                            //计算两点之间坡度，如果坡度大于预设坡度，那么我们修改这个点的高度。
                            float x1 = (float)((float)(iX) * (float)realWidth) / (float)(heightResolution);
                            float x2 = (float)((float)(tx) * (float)realWidth) / (float)(heightResolution);
                            float z1 = (float)((float)(iZ) * (float)realLength) / (float)(heightResolution);
                            float z2 = (float)((float)(tz) * (float)realLength) / (float)(heightResolution);

                            float Dis = (float)(System.Math.Sqrt((x1 - x2) * (x1 - x2) + (z1 - z2) * (z1 - z2)));
                            Fslope = (heightmaps[iZ, iX] - heightmaps[tz, tx]) * realHeight / Dis;
                            if (Fslope > Slope_Val)
                            {
                                if (heightmaps[iZ, iX] >= Height_Del)
                                {
                                    heightmaps[iZ, iX] -= Height_Del;
                                    flag = 1;
                                }
                            }
                        }
                    }
                }
                if (flag == 0 || ccnt >= 1000000) break;
            }
        }
        terrainData.SetHeights(0, 0, heightmaps);
    }
    void FindEdge()
    {
        Vector3[] Lv = new Vector3[400000];
        Vector3[] Rv = new Vector3[400000];
        int cntl = 0;
        int cntr = 0;
        for (int i = 0; i < cnt; i++)
        {
            int tx = GetiX(m_vp3River[i]);
            int tz = GetiZ(m_vp3River[i]);
            for (int iX = tx - AAwidth; iX <= tx + AAwidth; iX++)
            {
                if (iX >= 0 && iX < width)
                {
                    for (int iZ = tz - AAlength; iZ <= tz + AAlength; iZ++)
                    {
                        if (iZ >= 0 && iZ < length)
                        {
                            float x = (float)(iX) * (float)(realWidth) / (float)(heightResolution);
                            float y = heightmaps[iZ, iX] * realHeight - 0.4f;
                            float z = (float)(iZ) * (float)(realLength) / (float)(heightResolution);
                            Lv[cntl++] = new Vector3(x, y, z);
                        }
                    }
                    break;
                }
            }
        }
        for (int i = 0; i < cnt; i++)
        {
            int tx = GetiX(m_vp3River[i]);
            int tz = GetiZ(m_vp3River[i]);
            for (int iX = tx + AAwidth; iX >= tx - AAwidth; iX--)
            {
                if (iX >= 0 && iX < width)
                {
                    for (int iZ = tz - AAlength; iZ <= tz + AAlength; iZ++)
                    {
                        if (iZ >= 0 && iZ < length)
                        {
                            float x = (float)(iX) * (float)(realWidth) / (float)(heightResolution);
                            float y = heightmaps[iZ, iX] * realHeight - 0.4f;
                            float z = (float)(iZ) * (float)(realLength) / (float)(heightResolution);
                            Rv[cntr++] = new Vector3(x, y, z);
                        }
                    }
                    break;
                }
            }
        }
        terrainData.SetHeights(0, 0, heightmaps);
        GameObject.Find("WaterBasicDaytime(Clone)").SendMessage("GetVL", Lv);
        GameObject.Find("WaterBasicDaytime(Clone)").SendMessage("GetVR", Rv);
        GameObject.Find("WaterBasicDaytime(Clone)").SendMessage("GetVLcnt", cntl);
        GameObject.Find("WaterBasicDaytime(Clone)").SendMessage("GetVRcnt", cntr);
        GameObject.Find("WaterBasicDaytime(Clone)").SendMessage("GetDepth", RiverDepth);
    }

    void FindAllEdge()
    {
        int cnt2 = 0;
        Vector3[] V = new Vector3[150000];
        int[] fx = new int[4];
        int[] fz = new int[4];
        fx[0] = 0;fx[1] = 1;fx[2] = 1;fx[3] = 0;
        fz[0] = 0;fz[1] = 0;fz[2] = 1;fz[3] = 1;
        for(int l=0;l<cnt;l++)
        {
            int tx = GetiX(m_vp3River[l]);
            int tz = GetiZ(m_vp3River[l]);
            for (int i = tx-AAwidth; i <= tx+AAwidth; i++)
            {
                for (int j = tz-AAlength; j <= tz+AAlength; j++)
                {
                    if (i == tx - AAwidth || i == tx + AAwidth || j == tz - AAlength || j == tz + AAlength) continue;
                    Vector3[] D = new Vector3[4];
                    int flags = 1;
                    for (int k = 0; k < 4; k++)
                    {
                        int iX = i + fx[k];
                        int iZ = j + fz[k];
                        if (iX >= 0 && iX < width && iZ >= 0 && iZ < length)
                        {
                            float x = (float)(iX) * (float)(realWidth) / (float)(heightResolution);
                            float y = heightmaps[iZ, iX] * realHeight;
                            float z = (float)(iZ) * (float)(realLength) / (float)(heightResolution);
                            D[k] = new Vector3(x, y, z);
                        }
                        else flags = 0;
                    }
                    if (flags == 1)
                    {
                        for (int k = 0; k < 4; k++)
                        {
                            V[cnt2++] = D[k];
                        }
                    }
                }
            }
        }
        GameObject.Find("WaterBasicDaytime(Clone)").SendMessage("Getcnt",cnt2);
        GameObject.Find("WaterBasicDaytime(Clone)").SendMessage("BuildV",V);
    }
    /********************************************************************/






    /********************************************************************/
    //将地形图的点换算为代码中的（x，y，z）；
    int GetiX(Vector3 P)
    {
        float Bilv1 = (float)(heightResolution) / (float)(realWidth);
        int tx = (int)(P.x * Bilv1);
        return tx;
    }
    int GetiZ(Vector3 P)
    {
        float Bilv2 = (float)(heightResolution) / (float)(realLength);
        int tz = (int)(P.z * Bilv2);
        return tz;
    }
    float GetiY(Vector3 P)
    {
        float Bilv3 = 1.0f / (float)(realHeight);
        float ty = P.y * Bilv3;
        return ty;
    }
    /********************************************************************/
}
BuildRiverPlus2.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BuildRiverPlus2 : MonoBehaviour
{
    int realWidth;
    int realLength;
    int realHeight;
    int heightResolution;
    float[,] waterheightmaps;
    float[,] heightmaps;
    private void Start()
    {
        
    }
    private void Update()
    {
        DrawMoveRiver();
    }
    void DrawMoveRiver()
    {
        int cnt = 0;
        int cnt2 = 0;
        Vector3[] vp3 = new Vector3[1500000];
        int[] array = new int[10500000];
        int[] fx = new int[8];
        int[] fz = new int[8];
        fx[0] = 0; fx[1] = 1; fx[2] = 1; fx[3] = 1; fx[4] = 0; fx[5] = -1; fx[6] = -1; fx[7] = -1;
        fz[0] = 1; fz[1] = 1; fz[2] = 0; fz[3] = -1; fz[4] = -1; fz[5] = -1; fz[6] = 0; fz[7] = 1;
        //把侧面安排好，绘制出来
        
        for (int i=0;i<heightResolution;i++)
        {
            for(int j=0;j<heightResolution;j++)
            {
                if(waterheightmaps[i,j]>0)
                {
                    for(int k=0;k<8;k++)
                    {
                        int ni = i + fx[k];
                        int nj = j + fz[k];
                        if(ni>=0&&ni<heightResolution&&nj>=0&&nj<heightResolution&&waterheightmaps[ni,nj]>0)
                        {
                            Vector3 one = new Vector3(getX(i),getY(heightmaps[i,j]),getZ(j));
                            Vector3 two = new Vector3(getX(ni), getY(heightmaps[ni, nj]), getZ(nj));
                            Vector3 three = new Vector3(getX(i), getY(heightmaps[i, j]+waterheightmaps[i,j]), getZ(j));
                            Vector3 fore= new Vector3(getX(ni), getY(heightmaps[ni, nj]+waterheightmaps[ni,nj]), getZ(nj));
                            vp3[cnt++] = one;
                            vp3[cnt++] = two;
                            vp3[cnt++] = three;
                            vp3[cnt++] = fore;
                            array[cnt2++] = cnt - 2;
                            array[cnt2++] = cnt - 1;
                            array[cnt2++] = cnt - 3;
                            array[cnt2++] = cnt - 2;
                            array[cnt2++] = cnt - 3;
                            array[cnt2++] = cnt - 4;

                            array[cnt2++] = cnt - 3;
                            array[cnt2++] = cnt - 1;
                            array[cnt2++] = cnt - 2;
                            array[cnt2++] = cnt - 4;
                            array[cnt2++] = cnt - 3;
                            array[cnt2++] = cnt - 2;
                            int nni = i + fx[(k + 1) % 8];
                            int nnj = j + fz[(k + 1) % 8];
                            if(nni>=0&&nni<heightResolution&&nnj>=0&&nnj<heightResolution&&waterheightmaps[nni,nnj]>0)
                            {
                                Vector3 pone = new Vector3(getX(i), getY(heightmaps[i, j] + waterheightmaps[i, j]), getZ(j));
                                Vector3 ptwo=new Vector3(getX(ni), getY(heightmaps[ni, nj] + waterheightmaps[ni, nj]), getZ(nj));
                                Vector3 pthree=new Vector3(getX(nni), getY(heightmaps[nni, nnj] + waterheightmaps[nni, nnj]), getZ(nnj));
                                vp3[cnt++] = pone;
                                vp3[cnt++] = ptwo;
                                vp3[cnt++] = pthree;

                                array[cnt2++] = cnt - 3;
                                array[cnt2++] = cnt - 2;
                                array[cnt2++] = cnt - 1;

                                array[cnt2++] = cnt - 1;
                                array[cnt2++] = cnt - 2;
                                array[cnt2++] = cnt - 3;
                            }
                        }
                    }
                }
            }
        }
        
        Vector3[] vpp = new Vector3[cnt];
        int[] ary = new int[cnt2];
        for (int i = 0; i < cnt; i++) vpp[i] = vp3[i];
        for (int i = 0; i < cnt2; i++) ary[i] = array[i];

        Mesh mesh = gameObject.GetComponent<MeshFilter>().mesh;
        mesh.vertices = vpp;
        mesh.triangles = ary;
        gameObject.name = "Water";
    }
    /********************************************************************/
    //换算公式
    float getX(float x)
    {
        return (float)(x) * (float)(realWidth) / (float)(heightResolution);
    }
    float getY(float y)
    {
        return (float)(y) * (float)(realHeight);
    }
    float getZ(float z)
    {
        return (float)(z) * (float)(realLength) / (float)(heightResolution);
    }




    /********************************************************************/




    /********************************************************************/
    //得到一些列参数
    void GetWaterheightmaps(float[,] temp)
    {
        waterheightmaps = temp;
    }
    void GetTerrainheightmaps(float [,] temp)
    {
        heightmaps = temp;
    }
    void GetrealWidth(int temp)
    {
        realWidth = temp;
    }
    void GetrealLength(int temp)
    {
        realLength = temp;
    }
    void GetrealHeight(int temp)
    {
        realHeight = temp;
    }
    void GetheightResolution(int temp)
    {
        heightResolution = temp;
    }
    /********************************************************************/
}

```

实际运行效果图:

![](https://i.loli.net/2018/06/13/5b20b61a76efa.png)
![](https://i.loli.net/2018/06/13/5b20b63875f0e.png)




