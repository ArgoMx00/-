`介绍`

在这里，我们会学习如何将纹理映射到对象。本课程修改了“转换”课程。因此如果您在此处迷路，您可能需要回溯到有关转换的课程。以查看是否遗漏了某些内容。
我会尽力在这里解释每一条新的和修改过的内容。我想提一下，我们已经更改了代码以明确定义框。通过添加顶点来定义每个三角形。虽然这回在创建框和顶点结构
时添加更多的代码。但是在纹理映射方面会更加容易。

在D3D中，我们使用2D（u，v）贴图坐标将纹理映射到对象上。u轴在水平方向上运行到图像。并且v轴垂直运行。其中u是0-1。因此，实际图像长度是256像素。
图像的一半水平长度也就是.5

现在，如果我们将u和v的值更改超过1，会发生什么？会发生重复纹理。

`新的全局变量`

第一个接口是一个对象，他将保存我们从文件加载的纹理。第二个将保存我们的采样器信息，之后将很快进行解释。

```c++
ID3D11ShaderResourceView* CubesTexture;
ID3D11SamplerState* CubesTexSamplerState;
```


`顶点结构/输入布局`

让我们看看我们的顶点结构，我们删除了颜色成员，并用纹理坐标成员来替换他。2D纹理的纹理坐标只需要u和v的值。但是，我们将使用3D纹理作为天空图。
他使用额外的w值。我们还修改了输入布局。以包含纹理坐标的两个浮点元素。他替换了我们的颜色元素。

```c++
struct Vertex    //Overloaded Vertex Structure
{
    Vertex(){}
    Vertex(float x, float y, float z,
        float u, float v)
        : pos(x,y,z), texCoord(u, v){}

    XMFLOAT3 pos;
    XMFLOAT2 texCoord;
};

D3D11_INPUT_ELEMENT_DESC layout[] =
{
    { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },  
    { "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },  
};
```

`顶点结构/缓冲区`

如果我们不为每个三角形顶点分割纹理坐标的话，则只能正确的映射顶部和底部。这就是我们为立方体中的每个三角形添加顶点的原因。因此我们可以设置他们的
纹理坐标。您可以尝适用我们再上一课中使用的八个顶点来设置纹理坐标，但是正如我所说的，纹理将不会在所有六个面上正确的映射。

由于我们添加了更多的顶点，我们还需要更新顶点缓冲区以保证24个顶点而不是之前的8个顶点。

```c++
        Vertex v[] =
        {
            // Front Face
            Vertex(-1.0f, -1.0f, -1.0f, 0.0f, 1.0f),
            Vertex(-1.0f,  1.0f, -1.0f, 0.0f, 0.0f),
            Vertex( 1.0f,  1.0f, -1.0f, 1.0f, 0.0f),
            Vertex( 1.0f, -1.0f, -1.0f, 1.0f, 1.0f),
    
            // Back Face
            Vertex(-1.0f, -1.0f, 1.0f, 1.0f, 1.0f),
            Vertex( 1.0f, -1.0f, 1.0f, 0.0f, 1.0f),
            Vertex( 1.0f,  1.0f, 1.0f, 0.0f, 0.0f),
            Vertex(-1.0f,  1.0f, 1.0f, 1.0f, 0.0f),
    
            // Top Face
            Vertex(-1.0f, 1.0f, -1.0f, 0.0f, 1.0f),
            Vertex(-1.0f, 1.0f,  1.0f, 0.0f, 0.0f),
            Vertex( 1.0f, 1.0f,  1.0f, 1.0f, 0.0f),
            Vertex( 1.0f, 1.0f, -1.0f, 1.0f, 1.0f),
    
            // Bottom Face
            Vertex(-1.0f, -1.0f, -1.0f, 1.0f, 1.0f),
            Vertex( 1.0f, -1.0f, -1.0f, 0.0f, 1.0f),
            Vertex( 1.0f, -1.0f,  1.0f, 0.0f, 0.0f),
            Vertex(-1.0f, -1.0f,  1.0f, 1.0f, 0.0f),
    
            // Left Face
            Vertex(-1.0f, -1.0f,  1.0f, 0.0f, 1.0f),
            Vertex(-1.0f,  1.0f,  1.0f, 0.0f, 0.0f),
            Vertex(-1.0f,  1.0f, -1.0f, 1.0f, 0.0f),
            Vertex(-1.0f, -1.0f, -1.0f, 1.0f, 1.0f),
    
            // Right Face
            Vertex( 1.0f, -1.0f, -1.0f, 0.0f, 1.0f),
            Vertex( 1.0f,  1.0f, -1.0f, 0.0f, 0.0f),
            Vertex( 1.0f,  1.0f,  1.0f, 1.0f, 0.0f),
            Vertex( 1.0f, -1.0f,  1.0f, 1.0f, 1.0f),
        };
    
        DWORD indices[] = {
            // Front Face
            0,  1,  2,
            0,  2,  3,
    
            // Back Face
            4,  5,  6,
            4,  6,  7,
    
            // Top Face
            8,  9, 10,
            8, 10, 11,
    
            // Bottom Face
            12, 13, 14,
            12, 14, 15,
    
            // Left Face
            16, 17, 18,
            16, 18, 19,
    
            // Right Face
            20, 21, 22,
            20, 22, 23
        };
    
        D3D11_BUFFER_DESC indexBufferDesc;
        ZeroMemory( &indexBufferDesc, sizeof(indexBufferDesc) );
    
        indexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
        indexBufferDesc.ByteWidth = sizeof(DWORD) * 12 * 3;
        indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
        indexBufferDesc.CPUAccessFlags = 0;
        indexBufferDesc.MiscFlags = 0;
    
        D3D11_SUBRESOURCE_DATA iinitData;
    
        iinitData.pSysMem = indices;
        d3d11Device->CreateBuffer(&indexBufferDesc, &iinitData, &squareIndexBuffer);
    
        d3d11DevCon->IASetIndexBuffer( squareIndexBuffer, DXGI_FORMAT_R32_UINT, 0);
    
    
        D3D11_BUFFER_DESC vertexBufferDesc;
        ZeroMemory( &vertexBufferDesc, sizeof(vertexBufferDesc) );
    
        vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
        vertexBufferDesc.ByteWidth = sizeof( Vertex ) * 24;
        vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
        vertexBufferDesc.CPUAccessFlags = 0;
        vertexBufferDesc.MiscFlags = 0;
```

`从文件加载纹理`

D3DX11CreateShaderResourceViewFromFile()

这里，在init场景函数的底部，我们使用函数D3DX11CreateShaderResourceViewFromFile()从文件中加载纹理。其定义如下：

```c++
HRESULT D3DX11CreateShaderResourceViewFromFile(
  __in   ID3D11Device *pDevice,
  __in   LPCTSTR pSrcFile,
  __in   D3DX11_IMAGE_LOAD_INFO *pLoadInfo,
  __in   ID3DX11ThreadPump *pPump,
  __out  ID3D11ShaderResourceView **ppShaderResourceView,
  __out  HRESULT *pHResult
);
```

pDevice：指向我们的D3D设备的指针

pSrcFile：我们文件的名称

pLoadInfo：指向D3DX11_IMAGE_LOAD_INFO结构的指针。该结构定义了如何加载纹理。我们可以将其设置为NULL

pPump：指向ID3DX11ThreadPump接口的指针，仅仅在我们需要多线程的时候使用，所以我们设置为NULL

ppShaderResourceView:这是一个着色器资源视图的指针，他将保存来自纹理的数据

pHResult：这是一个返回指针，他将存储此函数的结果。我们之前谈到过HRESULT。

```c++
hr = D3DX11CreateShaderResourceViewFromFile( d3d11Device, L"braynzar.jpg",
    NULL, NULL, &CubesTexture, NULL );
```

`描述样本状态`

D3D11_SAMPLER_DESC

在这里，我们可以描述采样器状态，或者说着色器如何渲染纹理。我们创建一个DED_SAMPLER_DESC对象。

```c++
typedef struct D3D11_SAMPLER_DESC {
  D3D11_FILTER               Filter;
  D3D11_TEXTURE_ADDRESS_MODE AddressU;
  D3D11_TEXTURE_ADDRESS_MODE AddressV;
  D3D11_TEXTURE_ADDRESS_MODE AddressW;
  FLOAT                      MipLODBias;
  UINT                       MaxAnisotropy;
  D3D11_COMPARISON_FUNC      ComparisonFunc;
  FLOAT                      BorderColor[4];
  FLOAT                      MinLOD;
  FLOAT                      MaxLOD;
} D3D11_SAMPLER_DESC;
```

每个成员描述如下：

Filter：过滤器，描述要使用的过滤方法的D3D11_FILTER枚举类型

AddressU：一个D3D11_TEXTURE_ADDRESS_MODE枚举类型，描述如果u值大于1或者小于0该怎么办。

AddressV：一个D3D11_TEXTURE_ADDRESS_MODE类型，描述v值如果大于1或者小于0应该怎么办。

AddressW：一个D3D11_TEXTURE_ADREESS_MODE枚举类型，描述w值如果大于1或者小于0怎么办。

MipLODBias：从计算mipmap级别的便宜。

MaxAnisotropy：暂时不重要。

ComparisonFuc：枚举类型D3D11_COMPARISON_FUNC这将比较采样的mipmap数据与该纹理的另一个mipmaps采样数据

BorderColor[4]：边缘颜色

MinLOD：这是要使用的最低mipmap级别，其中0是最详细和最大的。

MaxLOD：这是要使用的最大mipmap级别，其中0是最详细的，要使用mipmap，您需要指定一个非常大的数字，例如FLT_MAX、

如果未填写任何成员，将使用默认值：

```c++
Filter            MIN_MAG_MIP_LINEAR
AddressU        Clamp
AddressV        Clamp
AddressW        Clamp
MinLOD            -3.402823466e+38F (-FLT_MAX)
MaxLOD            3.402823466e+38F (FLT_MAX)
MipMapLODBias    0.0f
MaxAnisotropy    16
ComparisonFunc    Never
BorderColor        float4(0.0f,0.0f,0.0f,0.0f)
```

我们要填写入的代码为：

```c++
D3D11_SAMPLER_DESC sampDesc;
ZeroMemory( &sampDesc, sizeof(sampDesc) );
sampDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
sampDesc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;
sampDesc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;
sampDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
sampDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
sampDesc.MinLOD = 0;
sampDesc.MaxLOD = D3D11_FLOAT32_MAX;
```





















