`介绍`

在这里，我们将学习如何在3D场景中变换几何体。转换利用矩阵。xna数学库可以方便的提供函数来帮助我们解决问题。

`矩阵转换`

Direct3D中的转换使用4X4矩阵。那是因为他们使用四个维度。三个空间。x，y，z和1变化。这由字母w表示。w通常等于1或者是0.我们不想进入太多的数学运算
所以如果你对矩阵知之甚少，那么如果这让人感到困惑，你应该学到更多。当你想要变换一个物体的时候。你可以得到他的3D矢量(x,y,z)。在w中加上他可以乘以
4X4矩阵，所以他看起来像是(x,y,z,1)。如果你将w设置为1.那么这就意味着他将被转换。然后你将矢量乘以我们诚挚为M的4X4矩阵，VM的结果将是V*M=v'

xna数学库中的矩阵式互娱XMMATRIX类型。

```c++
                                   [M11,M12,M13,M14]
v'[x', y', z', 1]=v[x, y, z, 1] x M[M21,M22,M23,M24]
                                   [M31,M32,M33,M34]
                                   [M41,M42,M43,M44]
                                   
x'=(x*M11) + (y*M21) + (z*M31) + (1*M41)
y'=(x*M12) + (y*M22) + (z*M32) + (1*M42)
z'=(x*M13) + (y*M23) + (z*M33) + (1*M43)
```

`缩放`

缩放矩阵将缩放3D空间中对象的大小。XNA数学库具有为我们计算变换的函数。可以使用以下函数计算缩放矩阵：

```c++
XMMATRIX XMMatrixScaling
(
    FLOAT ScaleX,    // x=axis scale
    FLOAT ScaleY,     // y-axis scale
    FLOAT ScaleZ    // z-axis scale
)
```

该函数的返回矩阵是4X4的一个矩阵：

```c++
    [S1, 0, 0, 0]
S = [ 0,S2, 0, 0]
    [ 0, 0,S3, 0]
    [ 0, 0, 0, 1]
```

`旋转`

旋转矩阵用于3D空间中旋转对象。有三种不同的矩阵可围绕x，y，z轴的每一个轴旋转。以下是创建每个旋转矩阵的三个函数：


```c++
//围绕x轴旋转：
     [ 1,      0,     0, 0]
Rx = [ 0, cos(r),sin(r), 0]
     [ 0,-sin(r),cos(r), 0]
     [ 0,      0,     0, 1]
 
XMMATRIX XMMatrixRotationX(
         FLOAT Angle    //Rotation angle in radians
)
//围绕y轴旋转：
     [cos(r), 0,-sin(r), 0]
Ry = [   0,   1,   0,    0]
     [sin(r), 0, cos(r), 0]
     [   0,   0,   0,    1]
 
XMMATRIX XMMatrixRotationY(
         FLOAT Angle    //Rotation angle in radians
)
//围绕z轴旋转：
     [ cos(r),sin(r), 0, 0]
Rz = [-sin(r),cos(r), 0, 0]
     [      0,     0, 1, 0]
     [      0,     0, 0, 1]
    
XMMATRIX XMMatrixRotationZ(
         FLOAT Angle    //Rotation angle in radians
)
```

也可能你不是总绕着x，y或者z轴旋转。在这种情况下，我们可以组合上边的函数。或者使用xna数学库提供的另一个函数 ，他可以绕向量旋转：

```c++
//围绕向量旋转
XMMATRIX XMMatrixRotationAxis(
         XMVECTOR Axis,    //Vector describing the axis of rotation
         FLOAT Angle    //Rotation angle in radians
)
```

`Translating`

我们可以在我们的三维场景中使用另一种类型的变换。即翻译。翻译格式用于3D空间中移动对象。如果你想把对象定位在[1,2,0]并且在x轴
三个单位上移动他。结果看起来是[4,2,0]。下边是平移矩阵的外观和他的功能。MX是在x轴上的平移单位。my是在y轴上的平移单位，mz
理所当然就是在z轴上的平移单位。

```c++
    [ 1, 0, 0, 0]
T = [ 0, 1, 0, 0]
    [ 0, 0, 1, 0]
    [mx,my,mz, 1]

XMMATRIX XMMatrixTranslation(
         FLOAT OffsetX,    // Units translated on the x-axis
         FLOAT OffsetY,    // Units translated on the y-axis
         FLOAT OffsetZ    // Units translated on the z-axis
)
```

`结合转换`

我们可以将多个变换矩阵组合成一个矩阵。我们通过将每个矩阵相乘来实现这个点。我们必须这样做才能获得理想的结果。我们有一个称为S的缩放矩阵。一个名为R
的旋转矩阵。以及一个名为T的转换矩阵。我们结果是O。O=S*R*T这就是我们必须做的顺序。如果我们把平移矩阵放在第一个位子上，那么O=T*S*R。我们的对象就
会绕着原来的位子旋转。 

在上一课中，我们了解到世界空间是一个矩阵，描述了世界中物体的位子，旋转和大小。与场景中的其他物体相比，要为对象创建世界空间矩阵，我们将使用转换，
我们刚刚学会了如何去做。场景中的每个对象都有自己的世界空间矩阵。在本课中，我们将有两个立方体。一个围绕另一个旋转。我们将为立方体创建两个世界空间
矩阵。每个矩阵一个。称为cube1world以及cube2world。

`新的全局变量`

这里有几个新的声明。前两个是世界矩阵。我们每个立方体都有一个。后三个用于转换，一个用于旋转，缩放和平移。最后一个是用于跟踪旋转的浮子。

```c++
XMMATRIX cube1World;
XMMATRIX cube2World;

XMMATRIX Rotation;
XMMATRIX Scale;
XMMATRIX Translation;
float rot = 0.01f;
```

`立方体`

现在我们来看看我们的初始化场景函数。我们需要更新我们的顶点缓冲区和索引缓冲区以来保存一个立方体而不仅仅是一个正方形。这就是我们再这里做的：

我们第一个语句中2更改为12，因为在之前的课程中，我们有一个正方形，他只由两个三角形来组成。现在我们有六个面
所以一共是12个三角形。

我们将4改成8.因为前面的课程只有四个顶点构成了正方形。现在我们有个顶点构成了立方体。

```c++
indexBufferDesc.ByteWidth = sizeof(DWORD) * 12 * 3;
vertexBufferDesc.ByteWidth = sizeof( Vertex ) * 8;
```

那么这部分要更新的代码为：

```c++
Vertex v[] =
{
    Vertex( -1.0f, -1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 1.0f ),
    Vertex( -1.0f, +1.0f, -1.0f, 0.0f, 1.0f, 0.0f, 1.0f ),
    Vertex( +1.0f, +1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 1.0f ),
    Vertex( +1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 0.0f, 1.0f ),
    Vertex( -1.0f, -1.0f, +1.0f, 0.0f, 1.0f, 1.0f, 1.0f ),
    Vertex( -1.0f, +1.0f, +1.0f, 1.0f, 1.0f, 1.0f, 1.0f ),
    Vertex( +1.0f, +1.0f, +1.0f, 1.0f, 0.0f, 1.0f, 1.0f ),
    Vertex( +1.0f, -1.0f, +1.0f, 1.0f, 0.0f, 0.0f, 1.0f ),
};

DWORD indices[] = {
    // front face
    0, 1, 2,
    0, 2, 3,

    // back face
    4, 6, 5,
    4, 7, 6,

    // left face
    4, 5, 1,
    4, 1, 0,

    // right face
    3, 2, 6,
    3, 6, 7,

    // top face
    1, 5, 6,
    1, 6, 2,

    // bottom face
    4, 0, 3, 
    4, 3, 7
};

D3D11_BUFFER_DESC indexBufferDesc;
ZeroMemory( &indexBufferDesc, sizeof(indexBufferDesc) );

indexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
indexBufferDesc.ByteWidth = sizeof(DWORD) * 12 * 3;
indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
indexBufferDesc.CPUAccessFlags = 0;
indexBufferDesc.MiscFlags = 0;

D3D11_SUBRESOURCE_DATA iinitData;

iinitData.pSysMem = indices;
d3d11Device->CreateBuffer(&indexBufferDesc, &iinitData, &squareIndexBuffer);

d3d11DevCon->IASetIndexBuffer( squareIndexBuffer, DXGI_FORMAT_R32_UINT, 0);

D3D11_BUFFER_DESC vertexBufferDesc;
ZeroMemory( &vertexBufferDesc, sizeof(vertexBufferDesc) );

vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
vertexBufferDesc.ByteWidth = sizeof( Vertex ) * 8;
vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
vertexBufferDesc.CPUAccessFlags = 0;
vertexBufferDesc.MiscFlags = 0;
```

`摄像机的位子`

我们刚刚更新了这一行，将摄像机向后移动了一点点，以便更好的查看两个立方体。

```c++
camPosition = XMVectorSet( 0.0f, 3.0f, -8.0f, 0.0f );
```

`更新场景功能`

这是我们的UpdateScene（）函数，他会再事情发生变化的时候对场景进行所有更新。而在此后的函数只是渲染场景。
将他们分开是一个好主意。

前几行只是更新旋转变量。他告诉我们的立方体旋转多少度，为避免变得太大，我们确保其大于2pi或者6.28.如果他
更大。那么我们将其设置为0

接下来，我们使用XMMatrixIdentity（）函数重置cube1World矩阵。之后，我们创建了转换矩阵，创建变换的时候
第一个行是我们用来旋转对象的向量。我们将其设置为围绕y轴旋转。方法是在第二个参数中设置1.0f。接下来。
我们使用这个描述旋转轴的新向量。描述旋转度数的rot变量。以及根据我们给出的旋转轴和旋转角度创建旋转矩阵的
函数XMMatrixRotationAxis（）。我们将这个矩阵存储在我们用全局变量的旋转矩阵中。接下来，我们使用XMMatrix
Translation（）函数创建平移矩阵。我们将其设置为在Z轴上平移4.0f单位，这将使得立方体移动距离相机4个单位。
我们在平移矩阵中设置了他。

现在我们需要设置cube1World矩阵，他是定义第一个立方体的世界空间矩阵。仔细注意我们相乘的顺序。我们平移对象，
然后旋转对象。在旋转之前进行平移会产生轨道效应。那么现在发生的事情是，这个立方体首先将平移4个单位进入屏幕。
然后旋转。所以这个立方体将围绕第一个立方体旋转，同时保持4个单位的距离。

接下来我们转换第二个立方体。首先我们重置cube2World矩阵，然后定义变换，他们沿着由矢量rotaxis定义的旋转
立方体。-rot度。这将意味着它与第一个立方体的旋转方向相反。然后制作立方体通过MMatirxScaling（）函数在每个
轴上缩放1.3f单位。他比原来的那个立方体更大。

之后我们设置了cube2World矩阵。










