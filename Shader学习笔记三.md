<table><tr><td bgcolor=orange>更复杂的光照</td></tr></table>

一、Unity的渲染路径

在Unity中，渲染路径决定了光照是如何应用到Unity Shader中的。因此，如果想要和光源打交道，我们需要为
每个Pass指定他的渲染路径。我们只有为Shader正确的选择和设置了需要的渲染路径，该Shader才能正确计算
光照的情况。

Unity支持多种类型的渲染路径，在Unity 5.0版本之前，主要有三种：前向渲染路径、延迟渲染路径和定点照明
渲染路径。大多数情况下，一个项目只使用一种渲染路径。不同类型的渲染路径可能会包含多种标签的设置。

之前我们写过类似的标签：

```Shader
Pass{
  Tags{"LightMode"="ForwardBase"}
}
```

上边的代码就是在告诉Unity，该Pass使用前向渲染路径中的ForwardBase路径。而前向渲染路径还有一种路径被
叫做ForwardAdd。下表给出了Pass中LightMode标签所支持的渲染路径的选项：

![](https://i.loli.net/2018/07/04/5b3c4a7d7e91b.png)

接下来，我们就来稍微探讨一下关于渲染路径的内容：

①前向渲染路径的原理：每进行一次完整的前向渲染，我们需要渲染该对象的渲染图元，并计算两个缓冲区的信息：
一个是颜色缓冲区，一个是深度缓冲区。我们利用深度缓冲来决定一个片元是否可见，如果可见就更新颜色缓冲区
中的颜色值。我们可以用下边的伪代码来描述前向渲染路径的大致流程：

```Shader
Pass{
  for(each fragment covered by this primitive){
    if(failed in depth test){
      //如果没有进行深度测试，说明该片元是不可见的。
      discard;
    }
    else {
      //如果该片元可见
      //就进行光照计算
      float4 color=Shading(materialInfo,pos,normal,lightDir,viewDir);
      //更新帧缓冲
      writeFramBuffer(fragment,color);
    }
  }
}
```

根据上边代码我们大概能够了解到，对于逐个像素光源，我们都需要进行上面一次完整的渲染路程。如果一个物体
在多个逐像素光源的影响区域内，那么该物体就需要执行多个Pass，每个Pass计算一个逐像素光源的光照结果，然后
在帧缓冲中把这些光照的结果混合起来的得到最终的颜色值。假设，场景中有N个物体，每个物体受到M个光源的影响，
那么渲染整个场景一共需要N*M个Pass。

②Unity中的前向渲染

在前向渲染中，当我们渲染一个物体的时候，Unity会根据场景中各个光源的设置以及这些光源对物体的影响程度
对这些光源进行一个重要度的排序，其中，一定数目的光源会按照逐像素的方式处理，然后最多有4个光源按照
逐顶点的方式处理，剩下的光源可以按照SH方式进行处理、Unity使用的判断规则大概有：

场景中最亮的平行光总是按照逐像素进行处理的。
渲染模式被设置成Not Important的光源，会按照逐顶点或者SH进行处理。
渲染模式被设置成Important的光源，会按照逐像素处理。

③内置的光照变量和函数。

前边说过，根据我们使用额渲染路径，Unity会把不同的光照变量传递给Shader。

在untiy中，对于前向渲染来说，下表给出了我们可以在Shader中直接访问到的光照变量：

![](https://i.loli.net/2018/07/04/5b3c4dc936678.png)

同时，再列出一个表，列出前向渲染中可以直接使用的内置光照函数：

![](https://i.loli.net/2018/07/04/5b3c4e48ebdb9.png)

④顶点照明渲染路径

顶点照明渲染路径是对硬件配置要求最少、运算性能最高、但同时也是得到的效果最差的一种类型。
这里同时也有能够直接访问的光照变量和函数，就不再贴出了，因为使用的情况很少，需要的话查阅
书籍即可

⑤延迟渲染路径

前向渲染的问题是：当场景中包含大量的实时光照的时候，前向渲染的性能就会急剧下降。例如，如果
我们在场景的某一块区域设置了多个光照，这些光照互相重叠，那么为了得到最终的光照效果，我们就
需要对该区域内的每个物体执行多个Pass来计算不同光源对物体的光照结果，然后还需要把结果混合起
来。然而，每执行一个Pass我们都需要重新渲染一遍物体，单很多计算实际上是重复的。接下来我们讨
论一下其中的原理：

```Shader
//第一个Pass不进行真正的光照计算
//仅仅把光照计算需要的信息存储到G缓冲中
Pass 1{
  for(each primitvie in this model){
    for(each fragment covered by this primitie){
      if(failed in depth test){
        discard;
      }
      else{
        //如果通过了深度测试，表明该片元可见，那么就把需要的信息存储到G缓冲中。
        writeGBuffer(materialInfo,pos,normal,lightDir,viewDir);
      }
    }
  }
}
Pass 2{
  for(each pixel in the Screen){
    //如果该像素是有效的，那么读取他在G缓冲中的信息
    readGBuffer(pixel,materialInfo,pos,normal,lightDir,viewDir);
    
    //根据读取到的信息进行光照计算
    float4 color=Shading(materialInfo,pos,normal,lightDir,viewDir);
    writeFramBuffer(pixel,color);
  }
}
```

可以看出，延迟渲染使用的Pass数目通常就是两个，这跟场景中包含的光源数目是没有关系的
换句话说，延迟渲染的效率不依赖场景的复杂度，而是和我们使用的屏幕空间的大小有关。这是
因为，我们需要的信息都存储在缓冲区中，而这些缓冲区可以理解成是一张张2D图像，我们的计
算实际上就是在这些图像空间中进行的。

可以访问的内置变量和函数：

![](https://i.loli.net/2018/07/04/5b3c528d22ae0.png)

因为更多的应用是前向渲染路径，所以本次学习大多还是专研前向渲染路径方面的问题。

二、Unity的光源类型

Unity中一共支持4种光源类型：平行光、点光源、聚光灯以及面光源。面光源仅在烘焙时才会发挥作用
因此我们不进行深入谈论。由于每种光源的几何定义不同，因此它们对应的光源属性也就各不相同，这就
要求我们要区别对待它们，幸运的是，Unity提供了很多内置函数来帮助我们处理光源。

光源类型有什么影响？最常用德光源属性有光源的位子、方向、颜色、强度以及衰减这五种属性。而这些
属性和它们的几何定义有相关性。接下来我们对于几种光源来讨论一下:

①平行光：它通常是作为太阳这样的角色在场景中出现的。平行光有唯一的一个位子，也就是说，它可以被放在
场景中的任意位子，他的集合属性只有方向，我们可以调整平行光的Transform中的Rotation属性来改变
他的光源方向。光照强度不会随着距离而改变。

②点光源：点光源的照亮空间是有限的；点光源可以表示由一个点发出的，向所有方向延伸的光、点光源是有
位子属性的，它是由属性中的Position定义的。对于方向属性，我们需要用点光源的位子减去某点的位子得到相对
向量方向。而点光源的颜色和强度可以在Light组件面板中进行调整。同时，点光源也是会衰减的。随着物体
远离点光源，它接受到的光源强度也会逐渐减小，点光源求新出的光照强度最强，边缘最弱。其中的衰减值可以
由函数定义，稍后我们会对其进行深入探究。

③聚光灯：聚光灯是最复杂的光源，他照亮空间同样是有限的，但不再是简单的球体。而是由空间中的一块锥形
区域定义的。他的位子属性和光照方向和点光源的定义相同。衰减也是随着物体的距离决定的。探究其衰减值的
函数稍微复杂一些，因为聚光灯的光线是锥形的，我们还需要判断一个点是否在锥形范围内等。

三、在前向渲染中处理不同的光源类型

接下来我们进行实践 。
















