`介绍`

在本课程中，我们将学习如何通过创建深度/模板缓冲区和视图来实现3D场景的深度，然后将其绑定到OM阶段（输出混合阶段）。

`深度/模板视图`

深度/模板视图的作用是让管道的OM阶段检查渲染目标上的所有像素片段的深度/模板值。像素片段是可能被写入屏幕的像素。想象一个球体和一个盒子。
球体位于框的后边。因此当他们被泵入渲染管道的时候，来自球体的像素和来自框的像素都背放置到渲染目标上。这些像素称为像素片段。当像素到了
OM阶段的时候，OM阶段将比较像素片段深度值与该位子中已经存在的像素片段。如果新的像素片段将被丢弃，并且新的像素片段将保留在渲染目标上。
所以回到球体和盒子。假设首先渲染球体。渲染目标上海没有几何体。因此将渲染整个球体。但是当盒子的像素进入OM阶段的时候，OM阶段会比较盒子中
的像素的深度值和球体中的像素、由于框位于球体的前方，因此球体像素片段将被丢弃，并且盒子的像素片段将保留在渲染目标上。绘制完所有几何体后。
渲染目标上留下的像素就是屏幕上显示的像素。

深度视图的模板部分用于高级技术。例如镜像。我们将在后边介绍。

`新的全局变量`

这里我们有两个新的接口对象。一种是存储深度/模板视图。另一种是存储深度/模板缓冲区。

```c++
ID3D11DepthStencilView* depthStencilView;
ID3D11Texture2D* depthStencilBuffer;
```

`深度/模板缓冲区描述`

现在转到我们初始化d3d的地方。在我们创建深度/模板缓冲区之前。我们需要定义他。我们可以通过填写D3D11_TEXTURE2D_DESC来做到这一点。
就像我们填写后台缓冲区一样。这里真正需要提到的唯一事情，因为我们已经涵盖了这个结构，是绑定标志和格式。格式为两个变量提供了空间。
深度为24位，模板为8位。绑定标志表示该纹理将作为深度/模板缓冲区绑定到OM阶段。

```c++
//Describe our Depth/Stencil Buffer
D3D11_TEXTURE2D_DESC depthStencilDesc;
```

```c++
depthStencilDesc.Width     = Width;
depthStencilDesc.Height    = Height;
depthStencilDesc.MipLevels = 1;
depthStencilDesc.ArraySize = 1;
depthStencilDesc.Format    = DXGI_FORMAT_D24_UNORM_S8_UINT;
depthStencilDesc.SampleDesc.Count   = 1;
depthStencilDesc.SampleDesc.Quality = 0;
depthStencilDesc.Usage          = D3D11_USAGE_DEFAULT;
depthStencilDesc.BindFlags      = D3D11_BIND_DEPTH_STENCIL;
depthStencilDesc.CPUAccessFlags = 0; 
depthStencilDesc.MiscFlags      = 0;
```

`创建深度/模板视图`

现在我们已经定义了深度/模板缓冲区。我们需要创建他。我们可以使用设备接口的CreateTexture2D方法来创建他。在我们创建了深度/模板缓冲区之后。
我们需要创建将绑定到管道的OM阶段的深度/模板视图。我们通过从设备接口调用CreateDepthStencilView（）来完成这个操作。第一个参数是深度/模板
缓冲区的描述，第二个参数是深度/模板的状态。我们暂时不设置其他状态，设置为NULL。第三个参数是返回的深度/模板缓冲区。

```
d3d11Device->CreateTexture2D(&depthStencilDesc, NULL, &depthStencilBuffer);
d3d11Device->CreateDepthStencilView(depthStencilBuffer, NULL, &depthStencilView);
```

绑定深度/模板视图

我们需要做的最后一件事就是将它绑定到管道的OM阶段。还记得绑定渲染目标的那个函数吗？在我们调用这个函数并且将第三个参数设置为NULL之前。因为
我们没有深度/模板视图。我们现在有一个。所以我们可以将NULL参数更改为我们从上边创建的depthStencilView对象。

```
d3d11DevCon->OMSetRenderTargets( 1, &renderTargetView, depthStencilView );
```

`将深度值添加到视口`

转到我们创建的位子并描述我们的视口。我们需要告诉管道的OM阶段将像素z值或者深度值转换为0到1之间。其中0是最近的值，1是尽可能远的值。

```
viewport.MinDepth = 0.0f;
viewport.MaxDepth = 1.0f;
```

`释放内存`

不要忘记释放COM对象。

```c++
depthStencilView->Release();
depthStencilBuffer->Release();
```

`清除深度/模板视图`

我们需要做的最后一件事情就是清除每帧的深度/模板视图。就像我们使用渲染目标视图一样。我们通过调用设备上下文几口的ClearDepthStencilView（）
方法来完成这个操作。第一个值是我们想要清除的深度/模板视图、第二个是枚举类型，ored在一起，指定要清除的深度/模板视图的部分，第四个参数是我们
要清除深度的值。我们将其设置为1.0f。因为1.0f是任何东西都可以拥有的最大深度值。这可以确保屏幕上绘制所有对象。如果我们设置0.0f，则不会像屏幕
绘制任何内容，因为像素片段是所有深度值在0-1之间的。最后一个参数是我们设置模板的值。我们将其设置为0，因为我们没有使用他。

```c++
d3d11DevCon->ClearDepthStencilView(depthStencilView, D3D11_CLEAR_DEPTH|D3D11_CLEAR_STENCIL, 1.0f, 0);
```







