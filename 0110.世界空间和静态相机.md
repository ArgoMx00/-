`介绍`

我们将了解3D世界中的不同世界，包括世界，视图，投影，本地以及屏幕空间。我们可以使用这些空间来创建相机效果。这只会显示相机看到的内容。要
使用这些内容，我们将他们发送到效果文件内的常量缓冲区中的变量。顶点着色器将使用该变量来确定构成对象的顶点坐标。

`本地（对象）空间`

局部空间是相对于对象的空间。当我们创建一个对象的时候，我们通常将他放在点（0,0,0）的周围，这样可以更加容易的创建和定义顶点。想象一个立方体。
如果我们要相对于我们实际3D场景的中心点（0,0,0）创建立方体。我们将很难定义其顶点，特别是如果立方体稍微青协的话。不仅如此，我们也许需要建立
森林。创造一大堆定义森林的树木将是一种浪费。当我们所要做的就是创建一次树木并且制作副本。重新定位每个副本。

局部空间定义顶点相对于该对象中其他顶点的位子。局部空间中的顶点位子通常在包含3D对象的文件中定义，该文件是从3D建模程序创建的。

`世界空间` 

世界空间用于在世界空间中相对于彼此定位每个对象。每个对象都有自己独特的世界空间矩阵。世界空间是3D场景中的对象位子，大小和旋转等。
所有对象将围绕单个中心点（0，0,0）来定位，这是世界空间中心。要创建世界空间矩阵，我们需要为我们正在创建世界空间矩阵的对象进行变换

世界空间由每个对象上的单个变换定义。我们将使用世界空间矩阵将对象顶点从其局部空间转换为世界空间，其中顶点位子相对于场景中的其他对象。
我们将在下一节课中讨论这些转换。

`视图空间`

View空间基本上是相机的空间。摄像机位于点（0,0,0），当我们进行变换的时候，它看起来就像摄像机在世界各地的移动，事实上。世界正在移动，
而摄像机仍然在移动。

通过创建描述我们的相机位子，视图方向和向上的矩阵来定义视图空间。我们可以使用三个向量以及函数XMMatrixLookAtLH（）轻松创建View矩阵。

`投影空间`

这基本上是一个空间，如果对象在其中，他们被渲染到屏幕上，如果对象从空间中移除，他们就会被抛弃。这个空间是不同的。因为他由六个平面定义。
即近平面，远平面，顶部，左侧，底部和右侧平面。如果我们将投影空间渲染为几何体，它看起来就像是一个尖端切断的金字塔。金字塔的尖端将是相机
的位子。并且尖端被切除的位子将是近平面。

投影空间定义3D场景中从摄像机的视角可见对象区域。我们可以使用函数XMMatrixPerspectiveFlovLH（）轻松定义投影矩阵。并且将FOV，纵横比。
近z平面和远z平面传递给他。我将解释宽高比和FOV更好一些。宽高比是用于查找近平面和元平面的宽度和高度的值。通常您需要将宽度除以屏幕的高度。
1：1的比例将为您提供精确地平方。当然，远平面将比近平面更大。其更大的数量由FOV定义。FOV越大，背板与近平面相比越大。从而在屏幕上放置更多
的物体。

`屏幕空间`

最后一个空间基本上是后备缓冲区的x和y的值。其中（0,0）标记空间的左上角。这是显示在显示器上的2D空间。

我们不必定义这个空间，他更像是我们显示器的物理空间。但是，当我们使用鼠标进行拾取的时候，我们将使用这个空间概念。我们将屏幕中获取点的坐标，以
查看是否点击了3D对象。

`转换空间`

转换空间通常意味着将顶点从一个空间变换到另外一个空间。渲染管道使用三个我们将定义的空间，世界，视图和投影。我们将这些空间从一个空间转换到
另外一个空间，并将得到的矩阵放入另一个称为MVP（世界视图投影）的矩阵中。为了将他们从一个变换为另一个，我们将它们相乘，但请记住，我们乘以矩阵的顺序
会影响结果。因此我们将顺序乘以他们：World*View*Projection。然后，我们将VMP矩阵发送到效果文件中的常量缓冲区。VS将用于转换对象顶点。所以顺序是
这样的：Local Space中的对象顶点将被发送到Vertex Shader。VS将在我们调用绘制函数之前使用传入其中的MVP，并且将顶点位子与VMP矩阵相乘，这导致
对象位子在我们想要的世界中。并且如果他不在相机的视野中则将其裁剪。

`恒定缓冲区`

常量缓冲区基本上是效果文件中的结构，它保存我们能够从游戏代码更新的变量。我们可以使用Cbufffer类型创建一个常量缓冲区：





























