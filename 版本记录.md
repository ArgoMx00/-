```c++
//附加依赖项和需要的头文件


//Include and link appropriate libraries and headers//
#pragma comment(lib, "d3d11.lib")
#pragma comment(lib, "d3dx11.lib")
#pragma comment(lib, "d3dx10.lib")
#pragma comment (lib, "dinput8.lib")
#pragma comment (lib, "dxguid.lib")



#include <iostream>
#include <string>
#include <windows.h>
#include <d3d11.h>
#include <d3dx11.h>
#include <d3dx10.h>
#include <DirectXMath.h>
#include <dinput.h>



using namespace std;

using namespace DirectX;
//连接器分为两种，ID3D11Device运用到加载到内存中的时候。
//ID3D11DeviceConte运用到渲染的时候
IDXGISwapChain* SwapChain;
ID3D11Device* d3d11Device;
ID3D11DeviceContext* d3d11DevCon;
ID3D11RenderTargetView* renderTargetView;

//画一个正方形需要的接口
ID3D11Buffer* squareIndexBuffer;
ID3D11Buffer* squareVertBuffer;
ID3D11VertexShader* VS;
ID3D11PixelShader* PS;
ID3D10Blob* VS_Buffer;
ID3D10Blob* PS_Buffer;
ID3D11InputLayout* vertLayout;

//画一个地面需要的接口和缓冲区
ID3D11Buffer* FloorIndexBuffer;
ID3D11Buffer* FloorVertBuffer;
ID3D11VertexShader* FloorVS;
ID3D11PixelShader* FloorPS;
ID3D10Blob* FloorVS_Buffer;
ID3D10Blob* FloorPS_Buffer;
ID3D11InputLayout* FloorVertLayout;

//画一个圆柱需要的接口和缓冲区
ID3D11Buffer* CylinderIndexBuffer;
ID3D11Buffer* CylinderVertBuffer;
ID3D11VertexShader* CylinderVS;
ID3D11PixelShader* CylinderPS;
ID3D10Blob* CylinderVS_Buffer;
ID3D10Blob* CylinderPS_Buffer;
ID3D11InputLayout* CylinderVertLayout;


//深度模板视图和缓冲区接口对象
ID3D11DepthStencilView* depthStencilView;
ID3D11Texture2D* depthStencilBuffer;

//常量缓冲区接口，用于传递数据到Shader效果文件中
ID3D11Buffer* cbPerObjectBuffer;

//加载2D贴图的接口，以及采样器,这个贴图和采样器是用来创建地面用的。
ID3D11ShaderResourceView* FloorTexture;
ID3D11SamplerState* FloorTexSamplerState;

ID3D11ShaderResourceView* CubesTexture;
ID3D11SamplerState* CubesTexSamplerState;

//用于检测输入的接口
IDirectInputDevice8* DIKeyboard;
IDirectInputDevice8* DIMouse;



//转换矩阵
XMMATRIX WVP;
XMMATRIX World;
XMMATRIX camView;
XMMATRIX camProjection;

//相机信息
XMVECTOR camPosition;
XMVECTOR camTarget;
XMVECTOR camUp;

//用于计算FPS和移动速度的变量
double Rot = 0;
double Len = 0;

double countsPerSecond = 0.0;
__int64 CounterStart = 0;

int frameCount = 0;
int fps = 0;

__int64 frameTimeOld = 0;
double frameTime;

//车身前方向
XMVECTOR CarForward = XMVectorSet(0.0f, 0.0f, 1.0f, 1.0f);
XMVECTOR DefaultForward = XMVectorSet(0.0f, 0.0f, 1.0f, 1.0f);
XMMATRIX CarRotation = XMMatrixRotationY(0.0f);
XMMATRIX CarTranslation = XMMatrixTranslation(0.0f, 0.0f, 0.0f);
XMMATRIX LastPos = XMMatrixIdentity();

//声明函数模型。第一个函数用于初始化Direct3D，第二个是释放我们不需要放置内存泄漏的对象。
//InitScene用于设置场景
bool InitializeDirect3d11App(HINSTANCE hInstance);
void ReleaseObjects();
bool InitScene();
void UpdateScene(double time);
void DrawScene();
void BuildFloor();
void BuildCylinder();
void StartTimer();
double GetTime();
double GetFrameTime();
bool InitDirectInput(HINSTANCE hInstance);
void DetectInput(double time);

DIMOUSESTATE mouseLastState;
LPDIRECTINPUT8 DirectInput;


HRESULT hr;

LPCTSTR WndClassName = L"firstwindow";

HWND hwnd = NULL;

//定义窗口的大小。宽度和高度
const int Width = 800;
const int Height = 600;

//声明初始化窗口函数
bool InitializeWindow(HINSTANCE hInstance,
	//应该如何显示窗口。一些常见的命令是SW_SHOWMAXIMIZED,SW_SHOW,SW_SHOWMINIMIZED
	int ShowWnd,
	//窗口的宽度和高度
	int width, int height,
	//窗口是否为全屏
	bool windowed);
//声明消息循环函数
int messageloop();

//初始化Windows回调过程。可以捕获窗口信息。例如按键等。
//是处理我们Window消息的函数
LRESULT CALLBACK WndProc(HWND hWnd,
	UINT msg,
	WPARAM wParam,
	LPARAM lParam);
//顶点
struct cbPerObject
{
	XMMATRIX  WVP;
};

cbPerObject cbPerObj;

//几何体的顶点结构
//顶点输入布局
struct Vertex	//Overloaded Vertex Structure
{
	Vertex() {}
	Vertex(float x, float y, float z,
		float u, float v)
		: pos(x, y, z), texCoord(u, v) {}

	XMFLOAT3 pos;
	XMFLOAT2 texCoord;
};

D3D11_INPUT_ELEMENT_DESC layout[] =
{
	{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
	{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },
};
UINT numElements = ARRAYSIZE(layout);




//我们需要一个主函数来启动我们的应用程序。在Windows编程中。这个函数是WinMain（）函数
int WINAPI WinMain(HINSTANCE hInstance,    //Main windows function
	HINSTANCE hPrevInstance,
	LPSTR lpCmdLine,
	int nShowCmd)
{
	if (!InitializeWindow(hInstance, nShowCmd, Width, Height, true))
	{
		MessageBox(0, L"Window Initialization - Failed",
			L"Error", MB_OK);
		return 0;
	}
	if (!InitializeDirect3d11App(hInstance))    //Initialize Direct3D
	{
		MessageBox(0, L"Direct3D Initialization - Failed",
			L"Error", MB_OK);
		return 0;
	}

	if (!InitScene())    //Initialize our scene
	{
		MessageBox(0, L"Scene Initialization - Failed",
			L"Error", MB_OK);
		return 0;
	}
	if (!InitDirectInput(hInstance))
	{
		MessageBox(0, L"Direct Input Initialization - Failed",
			L"Error", MB_OK);
		return 0;
	}



	messageloop();

	ReleaseObjects();
	return 0;
}

//初始化窗口函数
bool InitializeWindow(HINSTANCE hInstance,	//Initialize our window
	int ShowWnd,
	int width, int height,
	bool windowed)
{
	//开始创建一个windows窗口
	//创建一个拓展窗口类

	WNDCLASSEX wc;

	//cbSize应该设置为我们窗口类的大小
	wc.cbSize = sizeof(WNDCLASSEX);	//Size of our windows class
	//当窗口移动或者改变大小的时候，我们设置为重绘
	//style是window类的样式。都以cs_开头
	wc.style = CS_HREDRAW | CS_VREDRAW;	//class styles
	//lpfnWndProc是指向我们想要处理Windows消息的函数指针。他被设置为WndProc，因为
	//他是我们的Windows处理功能的名称
	wc.lpfnWndProc = WndProc;	//Default windows procedure function
	//cbClsExtra是WNDCLASSEX之后分配的额外字节数
	wc.cbClsExtra = NULL;	//Extra bytes after our wc structure
	//cbWindExtra指定在windows实例之后分配的字节数
	wc.cbWndExtra = NULL;	//Extra bytes after our windows instance
	wc.hInstance = hInstance;	//Instance to current application
	//hlcon用于指定标题栏中窗口左上角的图标
	wc.hIcon = LoadIcon(NULL, IDI_WINLOGO);	//Title bar Icon
	//hCursor指定了光标的图标内容
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);	//Default mouse Icon
	//设置背景为黑色。
	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 2);	//Window bg color
	//附加到窗口的菜单名称
	wc.lpszMenuName = NULL;	//Name of the menu attached to our window
	//类名
	wc.lpszClassName = WndClassName;	//Name of our windows class
	//任务栏中的图标，使用和上边相同的IDI图标就行了
	wc.hIconSm = LoadIcon(NULL, IDI_WINLOGO); //Icon in your taskbar

	//我们注册类如果失败，我们将受到错误信息，如果他没有问题，就可以创建出窗口了。
	if (!RegisterClassEx(&wc))	//Register our windows class
	{
		//if registration failed, display error
		MessageBox(NULL, L"Error registering class",
			L"Error", MB_OK | MB_ICONERROR);
		return 1;
	}
	//类似于创建C++一个类的方式，来创建一个窗口
	/*
	hwnd=CreatWindowEx(拓展的样式,
				   我们窗口将使用的类的名称,
				   将出现在标题栏中的文本，
		   窗口的样式，
		   初始X和Y的位子，就是窗口的左上角位子，0,0是屏幕的左上角
		   窗口的高度和宽度
		   处理父级窗口，我们没有设置为NULL
		   处理附加到窗口的菜单，同样设置为NULL，
		   当前程序的实例，
		   如果我们的窗口是MDI客户端，则会使用这个项目，我们同样设置为NULL)
		   );
	*/
	hwnd = CreateWindowEx(	//Create our Extended Window
		NULL,	//Extended style
		WndClassName,	//Name of our windows class
		L"Window Title ",	//Name in the title bar of our window
		WS_OVERLAPPEDWINDOW,	//style of our window
		CW_USEDEFAULT, CW_USEDEFAULT,	//Top left corner of window
		width,	//Width of our window
		height,	//Height of our window
		NULL,	//Handle to parent window
		NULL,	//Handle to a Menu
		hInstance,	//Specifies instance of current program
		NULL	//used for an MDI client window
	);
	//如果创建的是空，进入判断。
	if (!hwnd)	//Make sure our window has been created
	{
		//If not, display error
		MessageBox(NULL, L"Error creating window",
			L"Error", MB_OK | MB_ICONERROR);
		return 1;
	}
	//我们显示窗口的函数。第一个参数是我们要显示的窗口名称，第二个参数是我们希望他显示的方式。
	ShowWindow(hwnd, ShowWnd);	//Shows our window
	//刷新窗口，只有一个参数，参数传递就是窗口的名字。
	UpdateWindow(hwnd);	//Its good to update our window
	//如果没有任何问题，返回true
	return true;	//if there were no errors, return true
}

bool InitializeDirect3d11App(HINSTANCE hInstance)
{
	//首先填写一个后台缓冲区。
	DXGI_MODE_DESC bufferDesc;

	ZeroMemory(&bufferDesc, sizeof(DXGI_MODE_DESC));
	//后台缓冲区的每个成员描述如下：
	/*
	Width：宽度  Height：高度
	RefreshRate:刷新率。这是DXGI_RATIONAL类型，用HZ描述刷新率。我们设置为60/1或者是60HZ。
	Format：格式。这是一个DXGI_FORMAT枚举类型，描述了我们显示的格式。我们可以使用DXGI_FORMAT_R8G8B8A8_UNORM，他是一个
	32位无符号整数，每个都取8位宏，绿，蓝和Aplha
	ScanlineOrdering：DXGI_MODE_SCANLINE_ORDER枚举类型，描述光栅化器渲染到曲面上的方式。由于我们使用双缓冲，通常不会看到，
	因此我们可以将其设置为DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED,这意味着渲染在曲面上的顺序无关紧要。
	Scaling：缩放，这是另一个枚举类型。
	*/
	bufferDesc.Width = Width;
	bufferDesc.Height = Height;
	bufferDesc.RefreshRate.Numerator = 60;
	bufferDesc.RefreshRate.Denominator = 1;
	bufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	bufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
	bufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;

	//后台缓冲区写好后，我们再填写一个交换链
	DXGI_SWAP_CHAIN_DESC swapChainDesc;

	ZeroMemory(&swapChainDesc, sizeof(DXGI_SWAP_CHAIN_DESC));
	//交换链的每个成员描述如下：
	/*
	BufferDesc：这是一个DXGI_MODE_DESC结构，他描述了后台缓冲区。我们将把刚刚填写的后台缓冲区BufferDesc对象放在这里。
	SampleDesc：这是一个DXGI_SAMPLE_DESC结构，描述了多重采样。简单的描述就是在解决抗锯齿问题。
	BufferUsage：这是一个DXGI_USAGE枚举类型，描述cpu对后台缓冲区表面的访问，我们指定DXGI_USAGE_RENDER_TARGET_OUTPUT，因为我们将渲染他。
	BufferCount：这是我们使用后台缓冲区的数量，我们将1设置为双缓冲。设置为2可以变换为三重缓冲。
	OutputWindow：这是我们的窗口句柄，在这里肯定是hwnd。
	Windowed：这是真还是假，取决于我们是否要窗口还是全屏，对于窗口设置是true，如果是全屏是false。
	SwapEffect：这是一个DXGI_SWAP_EFFECT枚举类型，描述了显示驱动程序在将前缓冲区替换到后缓冲区应该对前缓冲区执行的操作。
	Flags：标记，是一个DXGI_SWAP_CHAIN_FLAG枚举类型，这是一个描述交换链行为的额外标志。
	*/
	swapChainDesc.BufferDesc = bufferDesc;
	swapChainDesc.SampleDesc.Count = 1;
	swapChainDesc.SampleDesc.Quality = 0;
	swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
	swapChainDesc.BufferCount = 1;
	swapChainDesc.OutputWindow = hwnd;
	swapChainDesc.Windowed = TRUE;
	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

	//创建设备和交换链
	hr = D3D11CreateDeviceAndSwapChain(NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, NULL, NULL, NULL,
		D3D11_SDK_VERSION, &swapChainDesc, &SwapChain, &d3d11Device, NULL, &d3d11DevCon);

	//创建一个buffer（缓冲区）
	ID3D11Texture2D* BackBuffer;
	hr = SwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (void**)&BackBuffer);

	//创建渲染目标
	hr = d3d11Device->CreateRenderTargetView(BackBuffer, NULL, &renderTargetView);
	BackBuffer->Release();

	//Describe our Depth/Stencil Buffer
	D3D11_TEXTURE2D_DESC depthStencilDesc;

	depthStencilDesc.Width = Width;
	depthStencilDesc.Height = Height;
	depthStencilDesc.MipLevels = 1;
	depthStencilDesc.ArraySize = 1;
	depthStencilDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
	depthStencilDesc.SampleDesc.Count = 1;
	depthStencilDesc.SampleDesc.Quality = 0;
	depthStencilDesc.Usage = D3D11_USAGE_DEFAULT;
	depthStencilDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;
	depthStencilDesc.CPUAccessFlags = 0;
	depthStencilDesc.MiscFlags = 0;

	//Create the Depth/Stencil View
	d3d11Device->CreateTexture2D(&depthStencilDesc, NULL, &depthStencilBuffer);
	d3d11Device->CreateDepthStencilView(depthStencilBuffer, NULL, &depthStencilView);


	//设置渲染目标
	d3d11DevCon->OMSetRenderTargets(1, &renderTargetView, depthStencilView);

	return true;
}
//清空COM对象。
void ReleaseObjects()
{
	//Release the COM Objects we created
	SwapChain->Release();
	d3d11Device->Release();
	d3d11DevCon->Release();
	renderTargetView->Release();
	squareVertBuffer->Release();
	squareIndexBuffer->Release();
	FloorVertBuffer->Release();
	FloorIndexBuffer->Release();
	VS->Release();
	PS->Release();
	FloorVS->Release();
	FloorPS->Release();
	VS_Buffer->Release();
	PS_Buffer->Release();
	FloorVS_Buffer->Release();
	FloorPS_Buffer->Release();

	vertLayout->Release();
	//FloorVertLayout->Release();
	depthStencilView->Release();
	depthStencilBuffer->Release();
	cbPerObjectBuffer->Release();

	DIKeyboard->Unacquire();
	DIMouse->Unacquire();
	DirectInput->Release();



	CylinderIndexBuffer->Release();
	CylinderVertBuffer->Release();
	CylinderVS->Release();
	CylinderPS->Release();
	CylinderVS_Buffer->Release();
	CylinderPS_Buffer->Release();


}
void StartTimer()
{
	LARGE_INTEGER frequencyCount;
	QueryPerformanceFrequency(&frequencyCount);

	countsPerSecond = double(frequencyCount.QuadPart);

	QueryPerformanceCounter(&frequencyCount);
	CounterStart = frequencyCount.QuadPart;
}

double GetTime()
{
	LARGE_INTEGER currentTime;
	QueryPerformanceCounter(&currentTime);
	return double(currentTime.QuadPart - CounterStart) / countsPerSecond;
}

double GetFrameTime()
{
	LARGE_INTEGER currentTime;
	__int64 tickCount;
	QueryPerformanceCounter(&currentTime);

	tickCount = currentTime.QuadPart - frameTimeOld;
	frameTimeOld = currentTime.QuadPart;

	if (tickCount < 0.0f)
		tickCount = 0.0f;

	return float(tickCount) / countsPerSecond;
}
void BuildFloor()
{
	hr = D3DX11CompileFromFile(L"Effects.fx", 0, 0, "VS", "vs_4_0", 0, 0, 0, &FloorVS_Buffer, 0, 0);
	hr = D3DX11CompileFromFile(L"Effects.fx", 0, 0, "PS", "ps_4_0", 0, 0, 0, &FloorPS_Buffer, 0, 0);

	hr = d3d11Device->CreateVertexShader(FloorVS_Buffer->GetBufferPointer(), FloorVS_Buffer->GetBufferSize(), NULL, &FloorVS);
	hr = d3d11Device->CreatePixelShader(FloorPS_Buffer->GetBufferPointer(), FloorPS_Buffer->GetBufferSize(), NULL, &FloorPS);

	Vertex v[] =
	{
		Vertex(+100.0f, -2.0f, +100.0f, 100.0f, 0.0f),
		Vertex(-100.0f, -2.0f, +100.0f, 0.0f, 100.0f),
		Vertex(-100.0f, -2.0f, -100.0f, 0.0f, 0.0f),
		Vertex(+100.0f, -2.0f, -100.0f, 100.0f, 100.0f),
	};
	DWORD indices[] = {
		// front face
		2, 1, 0,
		3, 2, 0,
	};

	//⑤创建一个索引缓冲区
	//	再创建一个顶点缓冲区vertexBufferDesc

	D3D11_BUFFER_DESC indexBufferDesc;
	ZeroMemory(&indexBufferDesc, sizeof(indexBufferDesc));

	indexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
	indexBufferDesc.ByteWidth = sizeof(DWORD) * 2 * 3;
	indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
	indexBufferDesc.CPUAccessFlags = 0;
	indexBufferDesc.MiscFlags = 0;

	D3D11_SUBRESOURCE_DATA iinitData;

	ZeroMemory(&iinitData, sizeof(iinitData));

	iinitData.pSysMem = indices;
	d3d11Device->CreateBuffer(&indexBufferDesc, &iinitData, &FloorIndexBuffer);

	d3d11DevCon->IASetIndexBuffer(FloorIndexBuffer, DXGI_FORMAT_R32_UINT, 0);

	D3D11_BUFFER_DESC vertexBufferDesc;
	ZeroMemory(&vertexBufferDesc, sizeof(vertexBufferDesc));
	vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
	vertexBufferDesc.ByteWidth = sizeof(Vertex) * 4;
	vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	vertexBufferDesc.CPUAccessFlags = 0;
	vertexBufferDesc.MiscFlags = 0;

	//⑥将顶点缓冲区填入数据D3D11_SUBRESOURCE_DATA。并且得到这个顶点缓冲区接口

	D3D11_SUBRESOURCE_DATA vertexBufferData;
	ZeroMemory(&vertexBufferData, sizeof(vertexBufferData));
	vertexBufferData.pSysMem = v;
	hr = d3d11Device->CreateBuffer(&vertexBufferDesc, &vertexBufferData, &FloorVertBuffer);

	hr = D3DX11CreateShaderResourceViewFromFile(d3d11Device, L"grass.jpg",
		NULL, NULL, &FloorTexture, NULL);

	//再创建一个采样器
	D3D11_SAMPLER_DESC sampDesc;
	ZeroMemory(&sampDesc, sizeof(sampDesc));
	sampDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
	sampDesc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;
	sampDesc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;
	sampDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
	sampDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
	sampDesc.MinLOD = 0;
	sampDesc.MaxLOD = D3D11_FLOAT32_MAX;

	//Create the Sample State
	hr = d3d11Device->CreateSamplerState(&sampDesc, &FloorTexSamplerState);

	return;
}
void BuildCylinder()
{
	//我们以点(1.3,-0.5,0)为圆心画轮子
	//侧面点的个数为360个。那么每次我们挪动的角度为1度。
	//首先随便画出来一个内容。
	hr = D3DX11CompileFromFile(L"Effects.fx", 0, 0, "VS", "vs_4_0", 0, 0, 0, &CylinderVS_Buffer, 0, 0);
	hr = D3DX11CompileFromFile(L"Effects.fx", 0, 0, "PS", "ps_4_0", 0, 0, 0, &CylinderPS_Buffer, 0, 0);

	hr = d3d11Device->CreateVertexShader(CylinderVS_Buffer->GetBufferPointer(), CylinderVS_Buffer->GetBufferSize(), NULL, &CylinderVS);
	hr = d3d11Device->CreatePixelShader(CylinderPS_Buffer->GetBufferPointer(), CylinderPS_Buffer->GetBufferSize(), NULL, &CylinderPS);
	int countTemp = 0;
	double Angle = 1.0f;
	Vertex v[720];
	DWORD indices[720 * 6 + 360 * 24];

	//轮子外侧
	v[0] = Vertex(1.3f, -0.5f, 0.0f, 0.0f, 0.0f);
	v[1] = Vertex(1.3f, 0.0f, 0.0f, 0.0f, 0.0f);
	for (int i = 2; i < 360; i++)
	{
		double CosVal = cos(Angle * 3.14f / 180.0f);
		double SinVal = sin(Angle * 3.14f / 180.0f);
		double yy = (v[1].pos.y - v[0].pos.y)* CosVal - (v[1].pos.z - v[0].pos.z)*SinVal + v[0].pos.y;
		double zz = (v[1].pos.z - v[0].pos.z)*CosVal - (v[1].pos.y - v[0].pos.y)*SinVal + v[0].pos.z;
		v[i] = Vertex(1.3f, yy, zz, 0.0f, 0.0f);

		indices[countTemp++] = i - 0;
		indices[countTemp++] = i - 1;
		indices[countTemp++] = 0;

		indices[countTemp++] = 0;
		indices[countTemp++] = i - 1;
		indices[countTemp++] = i - 1;

		Angle = Angle + 1.0f;
	}
	//封口
	indices[countTemp++] = 0;
	indices[countTemp++] = 1;
	indices[countTemp++] = 359;

	indices[countTemp++] = 359;
	indices[countTemp++] = 1;
	indices[countTemp++] = 0;

	//轮子内侧
	Angle = 1.0f;
	v[360] = Vertex(0.7f, -0.5f, 0.0f, 0.0f, 0.0f);
	v[361] = Vertex(0.7f, 0.0f, 0.0f, 0.0f, 0.0f);
	for (int i = 362; i < 720; i++)
	{
		double CosVal = cos(Angle * 3.14f / 180.0f);
		double SinVal = sin(Angle * 3.14f / 180.0f);
		double yy = (v[1].pos.y - v[0].pos.y)* CosVal - (v[1].pos.z - v[0].pos.z)*SinVal + v[0].pos.y;
		double zz = (v[1].pos.z - v[0].pos.z)*CosVal - (v[1].pos.y - v[0].pos.y)*SinVal + v[0].pos.z;
		v[i] = Vertex(0.7f, yy, zz, 0.0f, 0.0f);

		indices[countTemp++] = i - 0;
		indices[countTemp++] = i - 1;
		indices[countTemp++] = 360;

		indices[countTemp++] = 360;
		indices[countTemp++] = i - 1;
		indices[countTemp++] = i - 0;

		Angle = Angle + 1.0f;
	}
	//封口
	indices[countTemp++] = 360;
	indices[countTemp++] = 361;
	indices[countTemp++] = 719;

	indices[countTemp++] = 719;
	indices[countTemp++] = 361;
	indices[countTemp++] = 360;

	//侧面圆柱
	for (int i = 1; i < 359; i++)
	{
		indices[countTemp++] = i;
		indices[countTemp++] = i + 1;
		indices[countTemp++] = i + 360;

		indices[countTemp++] = i + 1;
		indices[countTemp++] = i + 361;
		indices[countTemp++] = i + 360;

	}

	indices[countTemp++] = 359;
	indices[countTemp++] = 0;
	indices[countTemp++] = 359 + 360;

	indices[countTemp++] = 0;
	indices[countTemp++] = 0 + 360;
	indices[countTemp++] = 359 + 360;


	D3D11_BUFFER_DESC indexBufferDesc;
	ZeroMemory(&indexBufferDesc, sizeof(indexBufferDesc));

	indexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
	indexBufferDesc.ByteWidth = sizeof(DWORD) * 720 * 6 + 360 * 24;
	indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
	indexBufferDesc.CPUAccessFlags = 0;
	indexBufferDesc.MiscFlags = 0;

	D3D11_SUBRESOURCE_DATA iinitData;

	ZeroMemory(&iinitData, sizeof(iinitData));

	iinitData.pSysMem = indices;
	d3d11Device->CreateBuffer(&indexBufferDesc, &iinitData, &CylinderIndexBuffer);

	d3d11DevCon->IASetIndexBuffer(CylinderIndexBuffer, DXGI_FORMAT_R32_UINT, 0);

	D3D11_BUFFER_DESC vertexBufferDesc;
	ZeroMemory(&vertexBufferDesc, sizeof(vertexBufferDesc));
	vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
	vertexBufferDesc.ByteWidth = sizeof(Vertex) * 720;
	vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	vertexBufferDesc.CPUAccessFlags = 0;
	vertexBufferDesc.MiscFlags = 0;

	D3D11_SUBRESOURCE_DATA vertexBufferData;
	ZeroMemory(&vertexBufferData, sizeof(vertexBufferData));
	vertexBufferData.pSysMem = v;
	hr = d3d11Device->CreateBuffer(&vertexBufferDesc, &vertexBufferData, &CylinderVertBuffer);

	return;
}
//初始化场景
bool InitScene()
{
	BuildFloor();
	BuildCylinder();
	//①首先使用VS_Buffer编译Effects.fx，并且规定函数入口名字为VS
	hr = D3DX11CompileFromFile(L"Effects.fx", 0, 0, "VS", "vs_4_0", 0, 0, 0, &VS_Buffer, 0, 0);
	hr = D3DX11CompileFromFile(L"Effects.fx", 0, 0, "PS", "ps_4_0", 0, 0, 0, &PS_Buffer, 0, 0);

	//②创建顶点着色器和像素着色器

	hr = d3d11Device->CreateVertexShader(VS_Buffer->GetBufferPointer(), VS_Buffer->GetBufferSize(), NULL, &VS);
	hr = d3d11Device->CreatePixelShader(PS_Buffer->GetBufferPointer(), PS_Buffer->GetBufferSize(), NULL, &PS);

	//③设置顶点着色器和像素着色器


	d3d11DevCon->VSSetShader(VS, 0, 0);
	d3d11DevCon->PSSetShader(PS, 0, 0);


	//④设置顶点和索引顺序

	Vertex v[] =
	{
		// Front Face
		Vertex(-2.0f, 0.0f, -1.0f, 0.0f, 1.0f),
		Vertex(-2.0f,  2.0f, -1.0f, 0.0f, 0.0f),
		Vertex(1.0f,  2.0f, -1.0f, 1.0f, 0.0f),
		Vertex(1.0f, 0.0f, -1.0f, 1.0f, 1.0f),

		// Back Face
		Vertex(-2.0f, 0.0f, 4.0f, 1.0f, 1.0f),
		Vertex(1.0f, 0.0f, 4.0f, 0.0f, 1.0f),
		Vertex(1.0f,  2.0f, 4.0f, 0.0f, 0.0f),
		Vertex(-2.0f,  2.0f, 4.0f, 1.0f, 0.0f),

		// Top Face

		Vertex(-2.0f, 2.0f, -1.0f, 0.0f, 1.0f),
		Vertex(-2.0f, 2.0f,  4.0f, 0.0f, 0.0f),
		Vertex(1.0f, 2.0f,  4.0f, 1.0f, 0.0f),
		Vertex(1.0f, 2.0f, -1.0f, 1.0f, 1.0f),

		// Bottom Face
		Vertex(-2.0f, 0.0f, -1.0f, 1.0f, 1.0f),
		Vertex(1.0f, 0.0f, -1.0f, 0.0f, 1.0f),
		Vertex(1.0f, 0.0f,  4.0f, 0.0f, 0.0f),
		Vertex(-2.0f, 0.0f,  4.0f, 1.0f, 0.0f),

		// Left Face
		Vertex(-2.0f, 0.0f,  4.0f, 0.0f, 1.0f),
		Vertex(-2.0f,  2.0f,  4.0f, 0.0f, 0.0f),
		Vertex(-2.0f,  2.0f, -1.0f, 1.0f, 0.0f),
		Vertex(-2.0f, 0.0f, -1.0f, 1.0f, 1.0f),

		// Right Face
		Vertex(1.0f, 0.0f, -1.0f, 0.0f, 1.0f),
		Vertex(1.0f,  2.0f, -1.0f, 0.0f, 0.0f),
		Vertex(1.0f,  2.0f,  4.0f, 1.0f, 0.0f),
		Vertex(1.0f, 0.0f,  4.0f, 1.0f, 1.0f),
	};
	DWORD indices[] = {
		// front face
		0,  1,  2,
		0,  2,  3,

		// Back Face
		4,  5,  6,
		4,  6,  7,

		// Top Face
		8,  9, 10,
		8, 10, 11,

		// Bottom Face
		12, 13, 14,
		12, 14, 15,

		// Left Face
		16, 17, 18,
		16, 18, 19,

		// Right Face
		20, 21, 22,
		20, 22, 23
	};

	//⑤创建一个索引缓冲区
	//	再创建一个顶点缓冲区vertexBufferDesc

	D3D11_BUFFER_DESC indexBufferDesc;
	ZeroMemory(&indexBufferDesc, sizeof(indexBufferDesc));

	indexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
	indexBufferDesc.ByteWidth = sizeof(DWORD) * 12 * 3;
	indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
	indexBufferDesc.CPUAccessFlags = 0;
	indexBufferDesc.MiscFlags = 0;

	D3D11_SUBRESOURCE_DATA iinitData;

	ZeroMemory(&iinitData, sizeof(iinitData));

	iinitData.pSysMem = indices;
	d3d11Device->CreateBuffer(&indexBufferDesc, &iinitData, &squareIndexBuffer);

	d3d11DevCon->IASetIndexBuffer(squareIndexBuffer, DXGI_FORMAT_R32_UINT, 0);

	D3D11_BUFFER_DESC vertexBufferDesc;
	ZeroMemory(&vertexBufferDesc, sizeof(vertexBufferDesc));
	vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
	vertexBufferDesc.ByteWidth = sizeof(Vertex) * 24;
	vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	vertexBufferDesc.CPUAccessFlags = 0;
	vertexBufferDesc.MiscFlags = 0;

	//⑥将顶点缓冲区填入数据D3D11_SUBRESOURCE_DATA。并且得到这个顶点缓冲区接口

	D3D11_SUBRESOURCE_DATA vertexBufferData;
	ZeroMemory(&vertexBufferData, sizeof(vertexBufferData));
	vertexBufferData.pSysMem = v;
	hr = d3d11Device->CreateBuffer(&vertexBufferDesc, &vertexBufferData, &squareVertBuffer);

	//⑦设置顶点缓冲区接口

	UINT stride = sizeof(Vertex);
	UINT offset = 0;
	d3d11DevCon->IASetVertexBuffers(0, 1, &squareVertBuffer, &stride, &offset);

	//⑧创建输入布局
	d3d11Device->CreateInputLayout(layout, numElements, VS_Buffer->GetBufferPointer(),
		VS_Buffer->GetBufferSize(), &vertLayout);

	//⑨设置输入布局到IA阶段

	d3d11DevCon->IASetInputLayout(vertLayout);

	//⑩设置原始拓扑

	d3d11DevCon->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);


	//10.创建一个视图
	D3D11_VIEWPORT viewport;
	ZeroMemory(&viewport, sizeof(D3D11_VIEWPORT));

	viewport.TopLeftX = 0;
	viewport.TopLeftY = 0;
	viewport.Width = Width;
	viewport.Height = Height;

	viewport.MinDepth = 0.0f;
	viewport.MaxDepth = 1.0f;

	//设置这个视图
	d3d11DevCon->RSSetViewports(1, &viewport);

	//11.创建一个常量缓冲区
	D3D11_BUFFER_DESC cbbd;
	ZeroMemory(&cbbd, sizeof(D3D11_BUFFER_DESC));

	cbbd.Usage = D3D11_USAGE_DEFAULT;
	cbbd.ByteWidth = sizeof(cbPerObject);
	cbbd.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	cbbd.CPUAccessFlags = 0;
	cbbd.MiscFlags = 0;

	//接下来得到这个常量缓冲区的接口
	hr = d3d11Device->CreateBuffer(&cbbd, NULL, &cbPerObjectBuffer);

	//12.创建一个相机

	camPosition = XMVectorSet(0.0f, 5.0f, -8.0f, 0.0f);
	camTarget = XMVectorSet(0.0f, 0.0f, 0.0f, 0.0f);
	camUp = XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f);

	//设置相机矩阵，同时也是在设置视图矩阵
	camView = XMMatrixLookAtLH(camPosition, camTarget, camUp);

	//设置相机视角，同时也是在设置投影矩阵
	camProjection = XMMatrixPerspectiveFovLH(0.4f*3.14f, (float)Width / Height, 1.0f, 1000.0f);

	//从文件中读取贴图
	hr = D3DX11CreateShaderResourceViewFromFile(d3d11Device, L"Car1.jpg",
		NULL, NULL, &CubesTexture, NULL);

	//再创建一个采样器
	D3D11_SAMPLER_DESC sampDesc;
	ZeroMemory(&sampDesc, sizeof(sampDesc));
	sampDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
	sampDesc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;
	sampDesc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;
	sampDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
	sampDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
	sampDesc.MinLOD = 0;
	sampDesc.MaxLOD = D3D11_FLOAT32_MAX;

	//Create the Sample State
	hr = d3d11Device->CreateSamplerState(&sampDesc, &CubesTexSamplerState);
	return true;
}
bool InitDirectInput(HINSTANCE hInstance)
{
	hr = DirectInput8Create(hInstance,
		DIRECTINPUT_VERSION,
		IID_IDirectInput8,
		(void**)&DirectInput,
		NULL);

	hr = DirectInput->CreateDevice(GUID_SysKeyboard,
		&DIKeyboard,
		NULL);

	hr = DirectInput->CreateDevice(GUID_SysMouse,
		&DIMouse,
		NULL);

	hr = DIKeyboard->SetDataFormat(&c_dfDIKeyboard);
	hr = DIKeyboard->SetCooperativeLevel(hwnd, DISCL_FOREGROUND | DISCL_NONEXCLUSIVE);

	hr = DIMouse->SetDataFormat(&c_dfDIMouse);
	hr = DIMouse->SetCooperativeLevel(hwnd, DISCL_EXCLUSIVE | DISCL_NOWINKEY | DISCL_FOREGROUND);

	return true;
}
void DetectInput(double time)
{
	DIMOUSESTATE mouseCurrState;

	BYTE keyboardState[256];

	DIKeyboard->Acquire();
	DIMouse->Acquire();

	DIMouse->GetDeviceState(sizeof(DIMOUSESTATE), &mouseCurrState);

	DIKeyboard->GetDeviceState(sizeof(keyboardState), (LPVOID)&keyboardState);

	

	if (keyboardState[DIK_A] & 0x80)
	{
		Rot -= 1 * time;
		//CarForward = XMVector4Transform(DefaultForward, XMMatrixRotationY(Rot));
		CarRotation = XMMatrixRotationY(Rot);
		//CarTranslation = XMMatrixTranslationFromVector(Len*CarForward);
	}
	if (keyboardState[DIK_D] & 0x80)
	{
		Rot += 1 * time;
		//CarForward = XMVector4Transform(DefaultForward, XMMatrixRotationY(Rot));
		CarRotation = XMMatrixRotationY(Rot);
		//CarTranslation = XMMatrixTranslationFromVector(Len*CarForward);
	}
	if (keyboardState[DIK_W] & 0x80)
	{
		Len = 2*time;
		//CarRotation = XMMatrixRotationY(Rot);
		CarForward = XMVector4Transform(DefaultForward, XMMatrixRotationY(Rot));
		CarTranslation = LastPos* XMMatrixTranslationFromVector(Len * CarForward);
	}
	if (keyboardState[DIK_S] & 0x80)
	{
		Len = -2*time;
		//CarRotation = XMMatrixRotationY(Rot);
		CarForward = XMVector4Transform(DefaultForward, XMMatrixRotationY(Rot));
		CarTranslation = LastPos*XMMatrixTranslationFromVector(Len * CarForward);
	}
	
	LastPos = CarTranslation;
}

void UpdateScene(double time)
{

}
//渲染场景
void DrawScene()
{

	//设置背景颜色
	float bgColor[4] = { (0.0f, 0.0f, 0.0f, 0.0f) };
	d3d11DevCon->ClearRenderTargetView(renderTargetView, bgColor);
	//深度模板
	d3d11DevCon->ClearDepthStencilView(depthStencilView, D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);

	//在InitScene中设置好了视图矩阵和投影矩阵之后，我们再得到世界矩阵就可以设置好相机了。
	//具体相机放在了哪里是怎样摆放的就要交给效果文件（着色器了）
	World = XMMatrixIdentity();



	XMMATRIX world_floor = World * CarRotation * CarTranslation;
	XMMATRIX WVP_floor = world_floor * camView*camProjection;
	cbPerObj.WVP = XMMatrixTranspose(WVP_floor);
	/*
	WVP = World * camView*camProjection;
	cbPerObj.WVP = XMMatrixTranspose(WVP);
	*/
	UINT stride_need = sizeof(Vertex);
	UINT offset_need = 0;

	//画我们的车身
	d3d11DevCon->VSSetShader(VS, 0, 0);
	d3d11DevCon->PSSetShader(PS, 0, 0);
	d3d11DevCon->UpdateSubresource(cbPerObjectBuffer, 0, NULL, &cbPerObj, 0, 0);
	d3d11DevCon->VSSetConstantBuffers(0, 1, &cbPerObjectBuffer);
	d3d11DevCon->IASetVertexBuffers(0, 1, &squareVertBuffer, &stride_need, &offset_need);
	d3d11DevCon->IASetIndexBuffer(squareIndexBuffer, DXGI_FORMAT_R32_UINT, 0);
	d3d11DevCon->PSSetShaderResources(0, 1, &CubesTexture);
	d3d11DevCon->PSSetSamplers(0, 1, &CubesTexSamplerState);
	d3d11DevCon->DrawIndexed(36, 0, 0);



	//画我们的车轮
	world_floor = World * CarRotation * CarTranslation;
	WVP_floor = world_floor * camView*camProjection;
	cbPerObj.WVP = XMMatrixTranspose(WVP_floor);
	d3d11DevCon->VSSetShader(CylinderVS, 0, 0);
	d3d11DevCon->PSSetShader(CylinderPS, 0, 0);
	d3d11DevCon->UpdateSubresource(cbPerObjectBuffer, 0, NULL, &cbPerObj, 0, 0);
	d3d11DevCon->VSSetConstantBuffers(0, 1, &cbPerObjectBuffer);
	d3d11DevCon->IASetVertexBuffers(0, 1, &CylinderVertBuffer, &stride_need, &offset_need);
	d3d11DevCon->IASetIndexBuffer(CylinderIndexBuffer, DXGI_FORMAT_R32_UINT, 0);
	//d3d11DevCon->PSSetShaderResources(0, 1, &CubesTexture);
	//d3d11DevCon->PSSetSamplers(0, 1, &CubesTexSamplerState);
	d3d11DevCon->DrawIndexed(720 * 6 + 360 * 24, 0, 0);

	world_floor = XMMatrixTranslation(-3, 0, 0) * World*CarRotation * CarTranslation;
	WVP_floor = world_floor * camView*camProjection;
	cbPerObj.WVP = XMMatrixTranspose(WVP_floor);
	d3d11DevCon->VSSetShader(CylinderVS, 0, 0);
	d3d11DevCon->PSSetShader(CylinderPS, 0, 0);
	d3d11DevCon->UpdateSubresource(cbPerObjectBuffer, 0, NULL, &cbPerObj, 0, 0);
	d3d11DevCon->VSSetConstantBuffers(0, 1, &cbPerObjectBuffer);
	d3d11DevCon->IASetVertexBuffers(0, 1, &CylinderVertBuffer, &stride_need, &offset_need);
	d3d11DevCon->IASetIndexBuffer(CylinderIndexBuffer, DXGI_FORMAT_R32_UINT, 0);
	//d3d11DevCon->PSSetShaderResources(0, 1, &CubesTexture);
	//d3d11DevCon->PSSetSamplers(0, 1, &CubesTexSamplerState);
	d3d11DevCon->DrawIndexed(720 * 6 + 360 * 24, 0, 0);

	world_floor = XMMatrixTranslation(0, 0, 3) * World*CarRotation * CarTranslation;
	WVP_floor = world_floor * camView*camProjection;
	cbPerObj.WVP = XMMatrixTranspose(WVP_floor);
	d3d11DevCon->VSSetShader(CylinderVS, 0, 0);
	d3d11DevCon->PSSetShader(CylinderPS, 0, 0);
	d3d11DevCon->UpdateSubresource(cbPerObjectBuffer, 0, NULL, &cbPerObj, 0, 0);
	d3d11DevCon->VSSetConstantBuffers(0, 1, &cbPerObjectBuffer);
	d3d11DevCon->IASetVertexBuffers(0, 1, &CylinderVertBuffer, &stride_need, &offset_need);
	d3d11DevCon->IASetIndexBuffer(CylinderIndexBuffer, DXGI_FORMAT_R32_UINT, 0);
	//d3d11DevCon->PSSetShaderResources(0, 1, &CubesTexture);
	//d3d11DevCon->PSSetSamplers(0, 1, &CubesTexSamplerState);
	d3d11DevCon->DrawIndexed(720 * 6 + 360 * 24, 0, 0);

	world_floor = XMMatrixTranslation(-3, 0, 3) * World*CarRotation * CarTranslation;
	WVP_floor = world_floor * camView*camProjection;
	cbPerObj.WVP = XMMatrixTranspose(WVP_floor);
	d3d11DevCon->VSSetShader(CylinderVS, 0, 0);
	d3d11DevCon->PSSetShader(CylinderPS, 0, 0);
	d3d11DevCon->UpdateSubresource(cbPerObjectBuffer, 0, NULL, &cbPerObj, 0, 0);
	d3d11DevCon->VSSetConstantBuffers(0, 1, &cbPerObjectBuffer);
	d3d11DevCon->IASetVertexBuffers(0, 1, &CylinderVertBuffer, &stride_need, &offset_need);
	d3d11DevCon->IASetIndexBuffer(CylinderIndexBuffer, DXGI_FORMAT_R32_UINT, 0);
	//d3d11DevCon->PSSetShaderResources(0, 1, &CubesTexture);
	//d3d11DevCon->PSSetSamplers(0, 1, &CubesTexSamplerState);
	d3d11DevCon->DrawIndexed(720 * 6 + 360 * 24, 0, 0);

	//画我们的地面
	WVP = World * camView*camProjection;
	cbPerObj.WVP = XMMatrixTranspose(WVP);
	d3d11DevCon->VSSetShader(FloorVS, 0, 0);
	d3d11DevCon->PSSetShader(FloorPS, 0, 0);
	d3d11DevCon->UpdateSubresource(cbPerObjectBuffer, 0, NULL, &cbPerObj, 0, 0);
	d3d11DevCon->VSSetConstantBuffers(0, 1, &cbPerObjectBuffer);
	d3d11DevCon->IASetVertexBuffers(0, 1, &FloorVertBuffer, &stride_need, &offset_need);
	d3d11DevCon->IASetIndexBuffer(FloorIndexBuffer, DXGI_FORMAT_R32_UINT, 0);
	d3d11DevCon->PSSetShaderResources(0, 1, &FloorTexture);
	d3d11DevCon->PSSetSamplers(0, 1, &FloorTexSamplerState);

	d3d11DevCon->DrawIndexed(6, 0, 0);

	//DrawFloor();


	SwapChain->Present(0, 0);
}


//消息循环函数
int messageloop() {	//The message loop
	//为MSG结构创建一个实例。
	MSG msg;	//Create a new message structure
	//清除结构，第一个参数是指向要清除的结构的指针。第二个是要清除的结构的大小。
	ZeroMemory(&msg, sizeof(MSG));	//clear message structure to NULL
	//循环判断
	while (true)	//while there is a message
	{
		//if there was a windows message
		//我们用PeekMessage来查看是否有信息其中五个参数的结构和含义为：
		/*
		BOOL PeekMessage(
			LPMSG lpMsg,
			HWND hWnd,
			UINT wMsgFilterMin,
			UINT wMsgFilterMax,
			UINT wRemoveMsg
			);
		lpmsg-这是指向我们的消息结构的指针

		HWND hwnd-这是发送消息的窗口句柄。如果将其设置为NULL，则他将从当前程序的任何窗口获取信息。

		UNIT wmsgFilterMin-指定要检查的消息范围中得第一条消息的值。如果wmsgfiltermin和wmsgfiltermax都设置为0. 那么PeekMessage将检查所有的消息

		UINT wMsgFilterMax-指定要检查的消息范围中的最后一条消息的值。

		UINT wRemoveMsg-指定如何处理消息。我们设置为PM_REMOVE，因此在阅读之后将删除该消息。
		*/
		if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			//如果有信息传入，首先判断是不是退出信息。
			if (msg.message == WM_QUIT)	//if the message was WM_QUIT
				break;	//Exit the message loop
			//如果是Windows信息，我们将其翻译一下
			TranslateMessage(&msg);	//Translate the message
			//Send the message to default windows procedure
			DispatchMessage(&msg);
		}
		else {	//Otherewise, keep the flow going
			// run game code;
			frameCount++;
			if (GetTime() > 1.0f)
			{
				fps = frameCount;
				frameCount = 0;
				StartTimer();
			}

			frameTime = GetFrameTime();

			DetectInput(frameTime);
			UpdateScene(frameTime);
			DrawScene();
		}
	}
	//返回我们的信息情况。
	return (int)msg.wParam;		//return the message

}

//Windows消息处理功能函数
//HWND hwnd是获取消息的窗口的句柄。UINT msg是消息的内容。wParam和IParam是相关消息的额外信息。 我们将使用wParam来检测键盘的输入。
LRESULT CALLBACK WndProc(HWND hwnd,	//Default windows procedure
	UINT msg,
	WPARAM wParam,
	LPARAM lParam)
{
	//这是我们检查事件消息的地方。如果按下退出键，我们会显示一个信息框。询问您是否真的要退出
	switch (msg)	//Check message
	{

	case WM_KEYDOWN:	//For a key down
		//if escape key was pressed, display popup box
		if (wParam == VK_ESCAPE) {
			if (MessageBox(0, L"Are you sure you want to exit?",
				L"Really?", MB_YESNO | MB_ICONQUESTION) == IDYES)

				//Release the windows allocated memory  
				DestroyWindow(hwnd);
		}
		return 0;

	case WM_DESTROY:	//if x button in top right was pressed
		PostQuitMessage(0);
		return 0;
	}
	//最后我们调用DefWindowProc函数，这是默认的Windows过程函数，我们最后称之为处理我们收到的所有信息。
	//return the message for windows to handle it
	return DefWindowProc(hwnd,
		msg,
		wParam,
		lParam);
}

```

```
cbuffer cbPerObject
{
	float4x4 WVP;
};

Texture2D ObjTexture;
SamplerState ObjSamplerState;

struct VS_OUTPUT
{
	float4 Pos : SV_POSITION;
	float2 TexCoord : TEXCOORD;
};

VS_OUTPUT VS(float4 inPos : POSITION, float2 inTexCoord : TEXCOORD)
{
	VS_OUTPUT output;

	output.Pos = mul(inPos, WVP);
	output.TexCoord = inTexCoord;

	return output;
}

float4 PS(VS_OUTPUT input) : SV_TARGET
{
	return ObjTexture.Sample(ObjSamplerState, input.TexCoord);
}
```
















