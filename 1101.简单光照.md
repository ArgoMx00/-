`介绍`

我不相信我需要强调光线对视频游戏的真实外观和感觉的重要性。

由于固定功能管道已经从DirectX 10中删除了，我们现在需要手动操作我们的灯光了。通常情况下，照明模型越准确，计算的成本就越高，渲染起来就越复杂。
相信我，他会变得非常昂贵。在视频游戏中，我们需要找到一种方法来实现光线，同时保持我们游戏以30fps以及以上的速度来运行。在为电影建模场景的时候。
由于每帧都是预先选人的，因此即使不是渲染单个帧的天数，也可以花费数个小时。在本课程中，我们讲学习如何使用最简单的灯光。即定向等。也称为平行灯光。

当进行计算以在光照射像素找到颜色的时候，颜色变量中的颜色值可以大于1或者小于0.为了解决这个问题。我们使用HLSL语言中的一个名为saturate的函数。

`光照类型`

我们可以将不同种类的灯分成四个类型。

`环境光`

使用环境光。因此我们的场景中没有直接被光源接触的部分不会变成黑色。环境光基本上是我们场景的任何部分都可以具有的最低光亮。在现实生活中，环境光光是所有
在每个表面周围反射的光。照亮整个区域。即使并非所有区域都来自光源的直射光。就像我们之前说过的那样，动画电影可以负担得起复杂的照明模型。可以计算房间周围
的所有光线照亮一切。但是在电子游戏中，我们没有时间进行这些计算。所以我们使用简单的hack确保我们场景的所有部分都能获得一点光线。这样我们就可以看到一切了
为了找到这个值，我们对光的环境颜色和材料的漫反射颜色进行了组件方式的乘法运算。

例如：LightAmbient(0.5, 0.5, 0.5) * MaterialDiffuse(0.75, 1.0, 0.5) = (0.375, 0.5, 0.25)

`漫反射`

为了使事情变得简单和性能友好。我们假设当光线照射到表面的时候，他会以相同的角度从表面反射。这样，我们就不需要考虑相机的位子了。当我们看到这种光线
撞击物体的时候，并且进入我们的眼睛，为了找到这个值，首先我们使用朗播的余弦定理来确定像素是否直接位于来自光源的光中以及多少：inLight = max(lightDirection * surfaceNormal, 0)
然后我们进行组件的乘法运算。我们光的漫反射值，我们的材料漫反射的值，以及光在表面上的多少，如果是的话。例如：inLight = lightDirection(1.0, 1.0, 1.0) * surfaceNormal(1.0, 1.0, 1.0) = 1 (surfaceNormal and lightDirection are the same here to make it simple)
1 * LightDiffuse(1.0, 1.0, 1.0) * MaterialDiffuse(0.75, 1.0, 0.5) = (0.75, 1.0, 0.5)

`镜面`

这是最好的灯光种类，如果使用的恰当，他们可以使得场景美观逼真。当光源的光线直接从光泽表面反射到您的眼睛中的时候，您可以从光泽物体上获得“眩光”。为了
简单起见，我们把这一部分留在本课程中，以后会介绍。

`Emissive`

`光源类型`

有三种常见的不同种类光源：定向光、聚光灯和点光源。

`新的全局变量`

我们这里唯一拥有的缓冲区是用来保存我们的cbperframe内容，因此我们可以将其发送到像素着色器。

```c++
ID3D11Buffer* cbPerFrameBuffer;
```

`更新常量缓冲区`

现在。我们将开始将对象的“world Space”矩阵发送到效果文件中。我们这样做是为了确保我们的照明从“世界空间”中的方向或者位子撞击物体。
我们将使用world矩阵在“世界空间”中重新定位对象的法线。我认为解释这个的最好方法是通过样例来说明。因此，当我们开始使用相机的时候，
整整发生的事情是整个世界将围绕相机移动。而不是相机在世界各地移动。因此，当我们实现定向照明的时候，光线的方向不会随着世界其他地方
的变化而变化，因此我们需要计算世界空间中的光线，或者看起来像光线的方向随着相机移动。

```c++
struct cbPerObject
{
    XMMATRIX  WVP;
    XMMATRIX  World;
};

```

`灯光结构`

我们需要创建要一个灯光结构，他基本上匹配我们将放在效果文件中的灯光结构。我们将此结构发送到像素着色器以填充效果文件中的灯光结构以实现光纤。首先我们
在创建新的灯光结构的时候清除内存。然后我们有一个方向，一个pad，一个环境和一个漫反射属性。

我们知道dir，ambient和diffuse变量的用途。但是pad是什么呢？HLSL将结构打包成4D向量。不允许在两个4D向量之间拆分单个向量。这是我们使用pad变量的原因。
看看代码，该结构的第一个成员是XMFLOAT3类型。这是一个3D矢量。但是请记住HLSL如何将所有内容打包成4D矢量？下面的一个成员是XMFLOAT4变量。他是一个4D
向量。如果没有他们之间被打包到dir成员的4D向量中。因此，为了防止这种情况发生。我们有pad变量。因此被打包到包含dir成员的4D向量中的第四个点。

在我们创建结构之后，我们声明一个新的Light对象，。

```c++
struct Light
{
    Light()
    {
        ZeroMemory(this, sizeof(Light));
    }
    XMFLOAT3 dir;
    float pad;
    XMFLOAT4 ambient;
    XMFLOAT4 diffuse;
};

Light light;

cbPerFrame Structure
```

这是我们将发送到Pixel Shader常量缓冲区的结构，正如您可以通过名称看到的那样，我们将每帧更新并且将其发送到PS常量缓冲区，这与我们拥有的另一个不同。我们
每个对象发送一次VS，我们现在唯一拥有的是Light对象。

```c++
struct cbPerFrame
{
    Light  light;
};

cbPerFrame constbuffPerFrame;
The UpdateScene() Functions New Parameter
```

time是UpdateScene（）接收的新变量。我们将传入值GetFrameTime（）返回，然后使用time变量更新我们的场景。

```c++
void UpdateScene(double time)
```

`更新顶点结构和顶点布局`

现在由于我们正在瞄准光。我们需要在顶点结构中包含一个新的成员。该成员将保存正常数据。因此我们可以决定是否以及有多少个光照照射表面。

```c++
struct Vertex    //Overloaded Vertex Structure
{
    Vertex(){}
    Vertex(float x, float y, float z,
        float u, float v,
        float nx, float ny, float nz)
        : pos(x,y,z), texCoord(u, v), normal(nx, ny, nz){}

    XMFLOAT3 pos;
    XMFLOAT2 texCoord;
    XMFLOAT3 normal;
};

D3D11_INPUT_ELEMENT_DESC layout[] =
{
    { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },  
    { "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },  
    { "NORMAL",     0, DXGI_FORMAT_R32G32B32_FLOAT,    0, 20, D3D11_INPUT_PER_VERTEX_DATA, 0}
};
```

同时不要忘记对申请的接口进行清空。

```c++
void CleanUp()
{
    //Release the COM Objects we created
    SwapChain->Release();
    d3d11Device->Release();
    d3d11DevCon->Release();
    renderTargetView->Release();
    squareVertBuffer->Release();
    squareIndexBuffer->Release();
    VS->Release();
    PS->Release();
    VS_Buffer->Release();
    PS_Buffer->Release();
    vertLayout->Release();
    depthStencilView->Release();
    depthStencilBuffer->Release();
    cbPerObjectBuffer->Release();
    Transparency->Release();
    CCWcullMode->Release();
    CWcullMode->Release();

    d3d101Device->Release();
    keyedMutex11->Release();
    keyedMutex10->Release();
    D2DRenderTarget->Release();    
    Brush->Release();
    BackBuffer11->Release();
    sharedTex11->Release();
    DWriteFactory->Release();
    TextFormat->Release();
    d2dTexture->Release();

    ///////////////**************new**************////////////////////
    cbPerFrameBuffer->Release();
    ///////////////**************new**************////////////////////
}
```

`定义光照`

接下来转到initScene（）函数，我们现在将定义灯光的方向，环境和漫反射成员。我们将给他一个白光（漫反射）和一个黑暗的环境。

```c++
light.dir = XMFLOAT3(0.25f, 0.5f, -1.0f);
light.ambient = XMFLOAT4(0.2f, 0.2f, 0.2f, 1.0f);
light.diffuse = XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f);
```

`将数据更新`

因为我们更改了顶点结构，所以我们还要添加数据进去。你可能想知道我是如何得到这些法线的。好吧，我所做的只是取每个顶点的位子，因为他们距离
立方体的中心（0,0,0）都是相等的距离。大多数情况下，你不会幸运的做到这一点。但是当我们开始加载模型的时候，通常你到处模型的程序也会导出
法线，他们很多时候回导出面法线，你需要平均才能使得顶点正常。

```c++
Vertex v[] =
{
    // Front Face
    Vertex(-1.0f, -1.0f, -1.0f, 0.0f, 1.0f,-1.0f, -1.0f, -1.0f),
    Vertex(-1.0f,  1.0f, -1.0f, 0.0f, 0.0f,-1.0f,  1.0f, -1.0f),
    Vertex( 1.0f,  1.0f, -1.0f, 1.0f, 0.0f, 1.0f,  1.0f, -1.0f),
    Vertex( 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f),

    // Back Face
    Vertex(-1.0f, -1.0f, 1.0f, 1.0f, 1.0f,-1.0f, -1.0f, 1.0f),
    Vertex( 1.0f, -1.0f, 1.0f, 0.0f, 1.0f, 1.0f, -1.0f, 1.0f),
    Vertex( 1.0f,  1.0f, 1.0f, 0.0f, 0.0f, 1.0f,  1.0f, 1.0f),
    Vertex(-1.0f,  1.0f, 1.0f, 1.0f, 0.0f,-1.0f,  1.0f, 1.0f),

    // Top Face
    Vertex(-1.0f, 1.0f, -1.0f, 0.0f, 1.0f,-1.0f, 1.0f, -1.0f),
    Vertex(-1.0f, 1.0f,  1.0f, 0.0f, 0.0f,-1.0f, 1.0f,  1.0f),
    Vertex( 1.0f, 1.0f,  1.0f, 1.0f, 0.0f, 1.0f, 1.0f,  1.0f),
    Vertex( 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f),

    // Bottom Face
    Vertex(-1.0f, -1.0f, -1.0f, 1.0f, 1.0f,-1.0f, -1.0f, -1.0f),
    Vertex( 1.0f, -1.0f, -1.0f, 0.0f, 1.0f, 1.0f, -1.0f, -1.0f),
    Vertex( 1.0f, -1.0f,  1.0f, 0.0f, 0.0f, 1.0f, -1.0f,  1.0f),
    Vertex(-1.0f, -1.0f,  1.0f, 1.0f, 0.0f,-1.0f, -1.0f,  1.0f),

    // Left Face
    Vertex(-1.0f, -1.0f,  1.0f, 0.0f, 1.0f,-1.0f, -1.0f,  1.0f),
    Vertex(-1.0f,  1.0f,  1.0f, 0.0f, 0.0f,-1.0f,  1.0f,  1.0f),
    Vertex(-1.0f,  1.0f, -1.0f, 1.0f, 0.0f,-1.0f,  1.0f, -1.0f),
    Vertex(-1.0f, -1.0f, -1.0f, 1.0f, 1.0f,-1.0f, -1.0f, -1.0f),

    // Right Face
    Vertex( 1.0f, -1.0f, -1.0f, 0.0f, 1.0f, 1.0f, -1.0f, -1.0f),
    Vertex( 1.0f,  1.0f, -1.0f, 0.0f, 0.0f, 1.0f,  1.0f, -1.0f),
    Vertex( 1.0f,  1.0f,  1.0f, 1.0f, 0.0f, 1.0f,  1.0f,  1.0f),
    Vertex( 1.0f, -1.0f,  1.0f, 1.0f, 1.0f, 1.0f, -1.0f,  1.0f),
};
```

接下来，你会看到我们创建了一个新的缓冲区，他将保存我们的cbPerFram结构。他保存了我们的光数据。我们已经了解到这了一点。所以我们不会通过他。
接下来，我们将此缓冲区发送到像素着色器，以便为每个像素实现光照。

```c++
ZeroMemory(&cbbd, sizeof(D3D11_BUFFER_DESC));

cbbd.Usage = D3D11_USAGE_DEFAULT;
cbbd.ByteWidth = sizeof(cbPerFrame);
cbbd.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
cbbd.CPUAccessFlags = 0;
cbbd.MiscFlags = 0;

hr = d3d11Device->CreateBuffer(&cbbd, NULL, &cbPerFrameBuffer);
```

`D2D的FPS Square的世界空间矩阵`

确保为D2D的方形纹理设置世界矩阵，否则他将使用最后设置的世界矩阵。他的World矩阵也是一个空的矩阵，因为他在屏幕空间中，所以你可以使用空
的WVP矩阵。

```c++
WVP =  XMMatrixIdentity();
    ///////////////**************new**************////////////////////
cbPerObj.World = XMMatrixTranspose(WVP);    
///////////////**************new**************////////////////////
cbPerObj.WVP = XMMatrixTranspose(WVP);    
d3d11DevCon->UpdateSubresource( cbPerObjectBuffer, 0, NULL, &cbPerObj, 0, 0 );
d3d11DevCon->VSSetConstantBuffers( 0, 1, &cbPerObjectBuffer );
d3d11DevCon->PSSetShaderResources( 0, 1, &d2dTexture );
d3d11DevCon->PSSetSamplers( 0, 1, &CubesTexSamplerState );
```

`设置灯光`

我们现在需要做的最后一件事情就是将包含我们的光数据的缓冲区发送到像素着色器常量缓冲区。我们只需要每帧执行一次，因为场景中的每个对象的光照
都是相同的。事实上，由于我们光线根本没有变化，我们可以在初始化场景时候完成此操作，但是如果你愿意，这可以让你改变光线，现在进入效果文件。

```c++
constbuffPerFrame.light = light;
d3d11DevCon->UpdateSubresource( cbPerFrameBuffer, 0, NULL, &constbuffPerFrame, 0, 0 );
d3d11DevCon->PSSetConstantBuffers(0, 1, &cbPerFrameBuffer);    
```

`设置世界矩阵`

现在我们需要将WVP和Wolrd矩阵发送到效果文件。我们将使用World矩阵来转换世界空间中的对象发现，以便我们可以实现正确的照明。

```c++
WVP = cube1World * camView * camProjection;    
cbPerObj.World = XMMatrixTranspose(cube1World);    
cbPerObj.WVP = XMMatrixTranspose(WVP);    
d3d11DevCon->UpdateSubresource( cbPerObjectBuffer, 0, NULL, &cbPerObj, 0, 0 );
d3d11DevCon->VSSetConstantBuffers( 0, 1, &cbPerObjectBuffer );
d3d11DevCon->PSSetShaderResources( 0, 1, &CubesTexture );
d3d11DevCon->PSSetSamplers( 0, 1, &CubesTexSamplerState );

d3d11DevCon->RSSetState(CWcullMode);
d3d11DevCon->DrawIndexed( 36, 0, 0 );

WVP = cube2World * camView * camProjection;    
cbPerObj.World = XMMatrixTranspose(cube2World);    
cbPerObj.WVP = XMMatrixTranspose(WVP);    
d3d11DevCon->UpdateSubresource( cbPerObjectBuffer, 0, NULL, &cbPerObj, 0, 0 );
d3d11DevCon->VSSetConstantBuffers( 0, 1, &cbPerObjectBuffer );
d3d11DevCon->PSSetShaderResources( 0, 1, &CubesTexture );
d3d11DevCon->PSSetSamplers( 0, 1, &CubesTexSamplerState );

d3d11DevCon->RSSetState(CWcullMode);
d3d11DevCon->DrawIndexed( 36, 0, 0 );
```

`效果文件`

在这里，我们将创建一个Light结构，以便在我们的程序将光数据发送到着色器时保存我们的光数据、这种光结构非常简单，仅仅包含方向，环境和漫反射。

```HLSL
struct Light
{
    float3 dir;
    float4 ambient;
    float4 diffuse;
};
```

下边的内容是我们的新的cbPerObject常量缓冲区，他现在为我们的对象世界空间保存一个矩阵。

```HLSL
cbuffer cbPerObject
{
    float4x4 WVP;
    float4x4 World;
};
```

还记得我们说根据他们的更新频率来分割常量缓冲区吗？我们为灯光创建一个新的常量缓冲区，因为我们只需要每帧更新一次这个常量缓冲区。因为场景中
的所有对象都将使用灯光。

```
cbuffer cbPerFrame
{
    Light light;
};
```

我们需要在VS_OUTPUT结构中包含一个新的成员，这是发送到像素着色器的每个顶点的法线。我们将使用这些法线来计算撞击物体表面的光线量。

现在我们需要将对象发现与对象世界空间相乘。以便照明正确。如果我们将发现与WVP矩阵相乘，则光线不正确。当我们使用相机的时候，他看起来
定向光随着相机移动，因为从技术上来讲，WVP是相机空间。

```c++
struct VS_OUTPUT
{
    float4 Pos : SV_POSITION;
    float2 TexCoord : TEXCOORD;
    float3 normal : NORMAL;
};

VS_OUTPUT VS(float4 inPos : POSITION, float2 inTexCoord : TEXCOORD, float3 normal : NORMAL)
{
    VS_OUTPUT output;

    output.Pos = mul(inPos, WVP);

    output.normal = mul(normal, World);

    output.TexCoord = inTexCoord;

    return output;
}
```

现在终于实际计算了我们场景中的灯光。首先我们规范化法线，因为它可能不是单位长度。然后，就像之前我们从纹理中找到漫反射颜色一样。之后我们创建一个新变量，它将在完成光照计算后保留我们的最终颜色。

然后，我们使用照明模型的环境光计算像素的颜色。这将确保我们仍然可以看到我们场景中不是直接在光线下的部分（当然，也许某些游戏会让你无法看到光线之外的什么）。

然后我们在检查了多少光线照射后计算了像素的最终颜色。我们通过第一个点将光的方向与表面的法线相乘，然后将其与光的漫反射颜色相乘，最后将像素纹理的漫反射颜色相乘。我们将其饱和以确保没有值高于1.0f，然后将其添加到finalColor，后者已经使用环境光照保持像素的颜色。

最后，我们返回颜色。注意我们如何返回颜色。我们必须始终从像素着色器返回一个float4，它包含颜色和alpha值。我们所做的就是返回返回值的前三个值的finalColor，以及我们用像素纹理化的纹理的alpha值。

```HLSL
float4 PS(VS_OUTPUT input) : SV_TARGET
{
    input.normal = normalize(input.normal);

    float4 diffuse = ObjTexture.Sample( ObjSamplerState, input.TexCoord );

    float3 finalColor;

    finalColor = diffuse * light.ambient;
    finalColor += saturate(dot(light.dir, input.normal) * light.diffuse * diffuse);
    
    return float4(finalColor, diffuse.a);
}
```

我希望你现在能够更好的理解灯光。这是非常简单的灯光效果，但是很快我们将涵盖高光照明以及其他两个照明模型，聚光灯等。














