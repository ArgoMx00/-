真实的场景、梦幻的需求。

现在任务目标大概形成了一个新的需求：

①首先读入一个高度图（灰度图），然后还需要读入另外一个相关的2D贴图，这个2D贴图呢，是通过绘图工具画出来的一条河道。然后我们需要将这个大致方向，
映射到高度图中，将沿河道部分的高度图，进行一个数据处理。

真实的场景、梦幻的需求、、、、、、、、、、

基于小波的分层高度图压缩方法

在本文中，我们提出了一种基于小波的有损方法压缩高度图地形的数据。它保持重建每个样本绝对误差范围内的数据绑定可由用户调整。这个方法接受尺寸为2n*2n
的样本块。在输入端，它可以执行渐进式的mip-map解压缩。压缩256*256块需要大约30毫秒，减压越1毫秒。多亏了这些属性，该方法可用于实时进行渲染器，它
能够达到压缩比37:1对整个地球进行压缩。

关键词：高度图、有损压缩、小波

整个地球的实时渲染需要工作具有大型地形的数据，其存储和分配。多分辨率(LOD)的方法是必不可少的，达到合理的帧速率。在文献中，一项调查总结了最常见的
多分辨率渲染的论文方法。其中一些还包含数据压缩。

例如，在C-BDAM和P-BDAM中，压缩发生在节点的细化中LOD层次结构。子节点内的值是尽可能准确地从父节点预测。这些预测与实际价值之间的差异被称为残差、然
后量化这些残差并通过解码器压缩。因此，压缩是有损的。这两种方法都略有修改小波提升方案，确保错误重建数据的数据保持在最大误差范围之内。

作为案例研究，我们将此方法实施为插入应用程序，转换高度行星表面为256*256块的32位浮点样本以米为单位，然后单独存储并且在运行期间进入基于四叉树的LOD
层次结构。

小波的介绍

基本上，存在两代小波，第一代是基于扩张和翻译的计算小波函数，第二代是基于滤波器组，高通和地通滤波，它有已经证明这两种方法使计算上的东西。

我们将描述第二代离散与这项共组相关的小波变换。基础的这种变换的步骤称为提升-分解输入的信号样本的计数是两个相同大小的部分的功率-低通和高通、
然后地柜的应用该步骤到产生的低通部分，直到其长度为1,与提升相反的就是重建-通过高通信息来丰富低通样本以获得两倍详细的样本集合。它与提升完全
相反。该变化广泛用于压缩数据，这可以通过量化产生的高通部分来实现。

在信号样本的输入集上，递归的应用于低通，由前一次迭代产生的部分，知道最新的低通部分长度为1.方法的输入必须是一定的2次幂。如果输入的
长度是2^n，那么当前方法就要执行n次提升迭代。提升越来越小的输入被称为自下而上的传递。我们可以想象这是建立一个低通输出金字塔的第一层
是输入本身，然后后续更高层是提升低通输出适用于下边的等级，每一层都是前一层一半的宽度，在紫霞而上通过后，最高层的宽度为1.

要重建输入信号样本，我们所需要的只是最高层的低通信息，以及所有高通层。这可以在随后的自上而下传球，从顶部建立低通金字塔至底部。从前
一个生成较低层以其相关的高通信息称为重建，它是与之前完全相反的。

一维数据的地柜小波分解的一个例子样品，如下图。在左侧，有一个低通的金字塔，底部就是输入的高度图本身。虚线表示分解在第一个自下而上的
通道内和第二个自上而下的通道内的逆成分。在样本上，他也标记为哪个样品行程较小的低通部分，以及较小的高通部分。橙色的是偶数的，作为
索引样品从0开始。

![](https://i.loli.net/2018/07/28/5b5bd29618c3c.jpg)

现在我们简要介绍一下这个原理如何拓展到2尺寸的图像数据。基本上，这个拓展只引入了一个变化，所描述的原理-当提升应用于具有尺寸为2^n的图像的时候，它
产生四个大小相等的输出，尺寸为2^(n-1)：一个低通部分，和三个高通部分（图2.2）。这些高通部件中的每一个都包含不同的信息，例如，第一个可能包含
垂直信息，第二个水平边缘和第三个对角线边缘。随后的重建，所有者四个部分都用来产生更大的低通部分。分辨率就提升了两倍。

事实上，自上而下的传球只需要高通信息完全重建输入。这些信息往往稀疏而且依赖于输入。输入越平滑，它包含的高通信息就越少。如果我们压缩它，我们
可以节省很多存储空间。如果我们不需要为了精确地重建输入，我们甚至可以对残差进行抽取（量化）。因为这些信息通常只包含细节，所以它会仔细抽取。
不会使重建变形太多并确保更好的压缩比。另一个有趣的事实是，残差与金字塔的较低层相连，比那些绑定到更高的细节的细节更精细，多亏了这个。可以
更加积极地压缩更详细（更大）的残差集合。而不是那些不那么详细的。这称为渐进式压缩和它用于例如JPEG标准。

在以下部分中，我们将描述提升和重建的步骤。让我们设定，提升是输入样品Xk，它将他们分成偶数和奇数部分。X2k=Xe。X2k+1=X0。这种分裂尚未基于
样本的任何频率属性，它仅仅基于他们的情况。但是，这两组样本将随后被修改。以便偶数将包含低通信息。以及奇数部分会变成残差-高通信息。这会是
在两个公式操作的帮助下执行：预测算子P（高通过滤器）和更新操作符U（低通滤波器）。P将用于生产来自x0的残差d，并且U将用于生产来自xe的低通部分。

到目前为止，仅描述了第二代方法的共同属性。现在他们之间会有分歧。他们唯一不同的是他们进行提升和重建的方式。方式执行提升步骤清楚地确定了重建
的执行方式，因为重建必须是提升的精确倒数。提升步骤以应用运算符P和U的顺序变化。据此，这些方法可以分成两大类-预测优先组合更新优先。

在预测优先方法中，首先应用预测：

![](https://i.loli.net/2018/07/28/5b5bd6e305fd3.jpg)

重建就必须相反，以及更新优先的公式和其重建内容：

 ![](https://i.loli.net/2018/07/28/5b5bd7de96143.jpg)

差不多引入了一堆概念，我们接下来要开始实现，也就是先得到方法的大纲：

自下而上的传递计算目标mip-maps-从最大的一个到最小的一个。那些将是mip-map，用于衡量重建的准确性。最大的mip-map是输入本身。每个较小
的mip-map都是从之前较大的mip-map计算出来的。这些mip-maps会在压缩过程中仅用作临时引用，不以任何方式存储。

自上而下的传递执行这些参考mip-map的压缩。在此过程中，它已经完全按照他们的方式构建了mip-maps在减压之后，从最小的一个到最大的一个，
然而，当与mipmap或者高度一起使用的时候，术语“压缩”和“解压缩”是等效的。这个技巧确保在不进行任何进一步矫正的情况下遵守最大的偏差，因
为逐步构建所需的数据。这些残差是根据在解压缩过程中可用的mip-map直接计算出的参考。压缩从最小的mip-map计算这些残差对于最大的一个，量
化他们，无损的编码他们并且保存他们。

第一个压缩的mip-map只是最小参考mip-map的唯一量化值。然后，首先从先前的压缩映射预测每个后续的mip-map。然后从相应的相同大小的目标mip-map
中减去这些预测以获得残差。然后尽可能地量化这些残差，以便仍然遵守当前压缩的mip映射的最大偏差。然后，他们被无损编码和存储。

![](https://i.loli.net/2018/07/28/5b5be19d96929.jpg)

![](https://i.loli.net/2018/07/28/5b5be1b69f7e0.jpg)

![](https://i.loli.net/2018/07/28/5b5be1c54cf7a.jpg)

关于压缩高度图的正式说明部分（要尽量认真弄懂，哪怕稍微朦朦胧胧的了解也行）：

更准确地说，第一遍给出浮动高度图样本的输入方块Ln；大小是2^nX2^n，并且要生成N层纹理贴图（mip-map）Ln-1,n-2.....0。一个接一个的生成出来。
对于尺寸来讲，Li是Li+1的一半宽度。因为Li是从L+1计算而来的。计算方式通过直观的像素平均值而来（具体做法之后会有所详解）。

Details of the method
Details of the method
Details of the method

在本章中，将更加详细的描述该方法。与前边的大纲不太相同，此描述足以让读者自己实现出细节的方法。
先是介绍了第一个自下而上通道内的mip-map的构造以及我们还有哪些替代结构需要考虑。接下来会介绍预测
P的公式以及预测运算符构造的方法。以便计算从较粗的mip-map重构更加精细的mip-map所需的残差并借助这些
残差进行重建。请注意，此方法不适用更新运算符。更详细的内容之后还会有说明。


如前一章所述，在第一个 - 自下而上 - 通过，我们只是从最大的一个 - 输入本身逐个构造目标mip-maps
 - 最小的一个，大小为1个像素。在每一步，我们构造一个较小的mipmap从最后构建的。新mip-map的维度是一半
最后一个的维度，换句话说，它是详细和包含的一半像素减少四倍。通常，我们可以通过任何形式构建新的mip-map
平均较大的mip-map的像素。在前一章中，我们解释过重建的最大绝对误差不取决于如何mip-maps看起来，只要它们包含有效值

但是，mip-map的外观会影响压缩比。相邻mip-map之间的高度差异越小，它们之间的过渡残差越低，因此压缩越高
比例是。另外，如介绍中所述，在渲染器内部在应用该方法的情况下，仔细选择某个地形方块的mip-map，以便最小化混叠。
此决定基于投影到屏幕的正方形区域。

我们知道，Li是从Li+1计算得来的，那么有平均值的公式：

![](https://i.loli.net/2018/07/30/5b5e6676c952d.jpg)

我们需要讨论的重点还是从上到下的通道，在这种情况下，我们需要计算残差。接下来我们更加详细的探讨从上到下的重建过程。

当从L-i构造（重建）较大的压缩mip-map L-i+1的时候。我们可以想象一下，因为L-i中的每个像素p被L-i1中的四个像素a，b
，c，d所代替，如图所示，我们将应用预测算子和后续残差计算和发夹三次以计算值。四个像素重点额一个和在解压缩期间从p重建
他们所需的残差。

![](https://i.loli.net/2018/07/30/5b5e692652704.jpg)

Prediction of a pixels
Prediction of a pixels
Prediction of a pixels

预测过程现在看来需要分成三步，第一步我们打算预测标记为a的像素。预测他们来自L-i内的相应p像素，我们使用一个简单的预测公式：
Pa (L-i) = p. 我们计算残差Ea和E-a相对于目标值在L-i+1中，然后分配最终值a-。很明显，MaxDev（a-，at）<=D,这部分是为了保证
误差不大于D的证明。那么我们求值a-的公式为：

![](https://i.loli.net/2018/07/30/5b5e6af946515.jpg)

Prediction of b pixels
Prediction of b pixels
Prediction of b pixels

在第二步骤中，我们计算预测因子b，这次我们不再从L-i中来对因子进行预测了，但是我们会从之前已经准备好了的a-进行相关预测计算。
用与此的预测因子Pb现在具有直线导向的Neville的形式。类似于一种2阶内插滤波器。它所做的就是当它被要求预测时在某个像素的高度，
它只是平局其四个相邻的高度像素，如下图所示。很容易就能看出，只要它被要求预测像素b处的高度。它总是平均已知的a值。所以从图中
我们可以大概了解到，我们首先遍历一次图，先将a-的预测因子全部求出来之后，来预测b因子的时候，再遍历一次数组，我们才能够平均
它的值。得到每一个b位子上预测因子的值。一旦知道了b像素的预测，我们就进行类比计算残差Eb以及其量子化的值E-b；和之前求的a-
过程相差无几，再次针对相应的目标值。最后，我们再给b指定其最终值b-：

![](https://i.loli.net/2018/07/30/5b5e72147d00a.jpg)

![](https://i.loli.net/2018/07/30/5b5e722fb73b2.jpg)

Prediction of c pixels
Prediction of c pixels
Prediction of c pixels

在这个通道的最后一步，我们需要最后预测一下因子C.用于预测因子pc，现在具有对角线形式的二阶的Neville插值滤波器。它与之前预测的因子
b很相像，只是方向有所不同。它旋转45度并且平均应用点的四个邻居。如下图所示。一旦得到了c像素的高度预测值之后呢，我们就会执行残差计算
以及类比计算，最终得到值c-：

![](https://i.loli.net/2018/07/30/5b5e7420da665.jpg)

![](https://i.loli.net/2018/07/30/5b5e74420dc8e.jpg)

与b像素的预测类似，我们使用二阶的滤波器来预测所有c像素的高度，甚至是内部那些。相邻c像素的后续预测可以再次缓存到备用一些计算。但是，使用Pc
的遍历现在是类似于下图那种对角线方式的遍历，为了使这种缓存称为可能：

![](https://i.loli.net/2018/07/30/5b5e757f9b7d7.jpg)

现在，让我们用几句话来总结一下我们已经完成的事情。我们已经在计算的压缩高度上以不同形式（Pa，Pb，Pc）执行预测算子的所有三个后续应用。
以便获得未知高度的预测。在每个部分应用之后，我们计算了位于相同位子的目标mip-map的预测和目标值之前的差异，作为原始残差Ea，Eb和Ec。
然后我们用QD量化这些残差-均匀量化器遵循最大偏差D，这确保了当量化残差加回预测的时候，所有这些求和将在相应目标高度的偏差D内。然后这些
量化残差值叫做E-a，E-b和E-c。他们一起形成E-i+1，从先前压缩的L-i重建较大的压缩Mip-Map L-i，需要这些残差值。

压缩与解压缩
压缩与解压缩
压缩与解压缩

最后，在计算出所有量化残差的情况下，我们无损压缩他们并且存储他们。我们首先压缩并且存储：E-0=QD（L0）；以此类推，得到E-1.E-2.....
当我们想要运行时解压缩任何L-i的时候，我们将需要只读取压缩数据的起始连续快E-0.1.2....i即可。这被称为渐进式减压。解压缩本身以类似的
方式执行。唯一的区别是不再计算量化残差，只需读取和解压缩他们。所以当我们有了L-i的时候，需要获取L-i+1.通过在L-i+1中用标记为a，b，c
的四个相邻像素替换L-i中的每个像素标记为p的像素。其高度应该分为三步计算。在每个步骤中，我们将使用相关的预测算子预测像素的高度。只有
将读取和解压缩的残差添加到预测中才会出现这种情况。

量化残差的无损压缩分成两步执行-Zlib后进行无损压缩。在打包期间，我们将所有残差与量化间隔分开。然后我们将他们向上移动最小量。已确定
他们都是非负的。然后我们将每个残差的位数裁剪为最大值的位数。显然，我们还存储了再重建中执行打包反转所需的信息。量化间隔和上移量。
只有在这种打包之后，Zlib才能无损编码残差。证明包装是有用的，因为他们还增加了压缩比率。解压缩只是Zlib的逆无损解压缩，随后是解包。将
残差扩展回浮点数，将他们向下移动位移量并且将他们与量化相乘间隔。

到此结束，基本上所有内容的讲解就需要告一段落了。我们后续学习过程中，需要了解每个因子的计算方式，以及考量量化的方法，得到全部内容的
方式之后，进行调试解决这个问题。

那么我们开始尝试对这部分的内容进行一个编码测试。

首先需求很明确，我肯定要学会输出高度图。那么一开始，我们尝试学习一下输出一个纯色图：

```C#
/*
创建一个128*128的红色纯色图。
*/
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Collections;
using System.IO;
public class TexTrue2D_To_Png : MonoBehaviour {

	// Use this for initialization
	void Start () {
        Deal();
	}
	
	// Update is called once per frame
	void Update () {
		
	}
    public void Deal()
    {
        Texture2D texture = new Texture2D(128, 128);
        for(int i=0;i<texture.height;i++)
        {
            for(int j=0;j<texture.width;j++)
            {
                texture.SetPixel(i, j, Color.red);
            }
        }
        texture.Apply();
        SaveThisTextureToPng(texture);
    }
    public void SaveThisTextureToPng(Texture2D texture)
    {
        
        SaveTextureToPng(texture, Application.dataPath + "/temp", "Out2.png");
    }
    public void SaveTextureToPng(Texture2D inputTex, string contents,string pngName)
    {
        RenderTexture temp = RenderTexture.GetTemporary(inputTex.width, inputTex.height, 0, RenderTextureFormat.ARGB32);
        Graphics.Blit(inputTex, temp);
        SaveRenderTextureToPng(temp, contents, pngName);
    }
    public void SaveRenderTextureToPng(RenderTexture rt,string contents,string pngName)
    {
        RenderTexture prev = RenderTexture.active;
        RenderTexture.active = rt;
        Texture2D png = new Texture2D(rt.width, rt.height, TextureFormat.ARGB32, false);
        png.ReadPixels(new Rect(0, 0, rt.width, rt.height), 0, 0);
        byte[] bytes = png.EncodeToPNG();
        if (!Directory.Exists(contents))
            Directory.CreateDirectory(contents);
        FileStream file = File.Open(contents + "/" + pngName + ".png", FileMode.Create);
        BinaryWriter writer = new BinaryWriter(file);
        writer.Write(bytes);
        file.Close();
        Texture2D.DestroyImmediate(png);
        png = null;
        RenderTexture.active = prev;
    }
}

```
































