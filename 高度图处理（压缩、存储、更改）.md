真实的场景、梦幻的需求。

现在任务目标大概形成了一个新的需求：

①首先读入一个高度图（灰度图），然后还需要读入另外一个相关的2D贴图，这个2D贴图呢，是通过绘图工具画出来的一条河道。然后我们需要将这个大致方向，
映射到高度图中，将沿河道部分的高度图，进行一个数据处理。

真实的场景、梦幻的需求、、、、、、、、、、

基于小波的分层高度图压缩方法

在本文中，我们提出了一种基于小波的有损方法压缩高度图地形的数据。它保持重建每个样本绝对误差范围内的数据绑定可由用户调整。这个方法接受尺寸为2n*2n
的样本块。在输入端，它可以执行渐进式的mip-map解压缩。压缩256*256块需要大约30毫秒，减压越1毫秒。多亏了这些属性，该方法可用于实时进行渲染器，它
能够达到压缩比37:1对整个地球进行压缩。

关键词：高度图、有损压缩、小波

整个地球的实时渲染需要工作具有大型地形的数据，其存储和分配。多分辨率(LOD)的方法是必不可少的，达到合理的帧速率。在文献中，一项调查总结了最常见的
多分辨率渲染的论文方法。其中一些还包含数据压缩。

例如，在C-BDAM和P-BDAM中，压缩发生在节点的细化中LOD层次结构。子节点内的值是尽可能准确地从父节点预测。这些预测与实际价值之间的差异被称为残差、然
后量化这些残差并通过解码器压缩。因此，压缩是有损的。这两种方法都略有修改小波提升方案，确保错误重建数据的数据保持在最大误差范围之内。

作为案例研究，我们将此方法实施为插入应用程序，转换高度行星表面为256*256块的32位浮点样本以米为单位，然后单独存储并且在运行期间进入基于四叉树的LOD
层次结构。

小波的介绍

基本上，存在两代小波，第一代是基于扩张和翻译的计算小波函数，第二代是基于滤波器组，高通和地通滤波，它有已经证明这两种方法使计算上的东西。

我们将描述第二代离散与这项共组相关的小波变换。基础的这种变换的步骤称为提升-分解输入的信号样本的计数是两个相同大小的部分的功率-低通和高通、
然后地柜的应用该步骤到产生的低通部分，直到其长度为1,与提升相反的就是重建-通过高通信息来丰富低通样本以获得两倍详细的样本集合。它与提升完全
相反。该变化广泛用于压缩数据，这可以通过量化产生的高通部分来实现。

在信号样本的输入集上，递归的应用于低通，由前一次迭代产生的部分，知道最新的低通部分长度为1.方法的输入必须是一定的2次幂。如果输入的
长度是2^n，那么当前方法就要执行n次提升迭代。提升越来越小的输入被称为自下而上的传递。我们可以想象这是建立一个低通输出金字塔的第一层
是输入本身，然后后续更高层是提升低通输出适用于下边的等级，每一层都是前一层一半的宽度，在紫霞而上通过后，最高层的宽度为1.

要重建输入信号样本，我们所需要的只是最高层的低通信息，以及所有高通层。这可以在随后的自上而下传球，从顶部建立低通金字塔至底部。从前
一个生成较低层以其相关的高通信息称为重建，它是与之前完全相反的。

一维数据的地柜小波分解的一个例子样品，如下图。在左侧，有一个低通的金字塔，底部就是输入的高度图本身。虚线表示分解在第一个自下而上的
通道内和第二个自上而下的通道内的逆成分。在样本上，他也标记为哪个样品行程较小的低通部分，以及较小的高通部分。橙色的是偶数的，作为
索引样品从0开始。

![](https://i.loli.net/2018/07/28/5b5bd29618c3c.jpg)

现在我们简要介绍一下这个原理如何拓展到2尺寸的图像数据。基本上，这个拓展只引入了一个变化，所描述的原理-当提升应用于具有尺寸为2^n的图像的时候，它
产生四个大小相等的输出，尺寸为2^(n-1)：一个低通部分，和三个高通部分（图2.2）。这些高通部件中的每一个都包含不同的信息，例如，第一个可能包含
垂直信息，第二个水平边缘和第三个对角线边缘。随后的重建，所有者四个部分都用来产生更大的低通部分。分辨率就提升了两倍。

事实上，自上而下的传球只需要高通信息完全重建输入。这些信息往往稀疏而且依赖于输入。输入越平滑，它包含的高通信息就越少。如果我们压缩它，我们
可以节省很多存储空间。如果我们不需要为了精确地重建输入，我们甚至可以对残差进行抽取（量化）。因为这些信息通常只包含细节，所以它会仔细抽取。
不会使重建变形太多并确保更好的压缩比。另一个有趣的事实是，残差与金字塔的较低层相连，比那些绑定到更高的细节的细节更精细，多亏了这个。可以
更加积极地压缩更详细（更大）的残差集合。而不是那些不那么详细的。这称为渐进式压缩和它用于例如JPEG标准。

在以下部分中，我们将描述提升和重建的步骤。让我们设定，提升是输入样品Xk，它将他们分成偶数和奇数部分。X2k=Xe。X2k+1=X0。这种分裂尚未基于
样本的任何频率属性，它仅仅基于他们的情况。但是，这两组样本将随后被修改。以便偶数将包含低通信息。以及奇数部分会变成残差-高通信息。这会是
在两个公式操作的帮助下执行：预测算子P（高通过滤器）和更新操作符U（低通滤波器）。P将用于生产来自x0的残差d，并且U将用于生产来自xe的低通部分。

到目前为止，仅描述了第二代方法的共同属性。现在他们之间会有分歧。他们唯一不同的是他们进行提升和重建的方式。方式执行提升步骤清楚地确定了重建
的执行方式，因为重建必须是提升的精确倒数。提升步骤以应用运算符P和U的顺序变化。据此，这些方法可以分成两大类-预测优先组合更新优先。

在预测优先方法中，首先应用预测：

![](https://i.loli.net/2018/07/28/5b5bd6e305fd3.jpg)

重建就必须相反，以及更新优先的公式和其重建内容：

 ![](https://i.loli.net/2018/07/28/5b5bd7de96143.jpg)

差不多引入了一堆概念，我们接下来要开始实现，也就是先得到方法的大纲：

自下而上的传递计算目标mip-maps-从最大的一个到最小的一个。那些将是mip-map，用于衡量重建的准确性。最大的mip-map是输入本身。每个较小
的mip-map都是从之前较大的mip-map计算出来的。这些mip-maps会在压缩过程中仅用作临时引用，不以任何方式存储。

自上而下的传递执行这些参考mip-map的压缩。在此过程中，它已经完全按照他们的方式构建了mip-maps在减压之后，从最小的一个到最大的一个，
然而，当与mipmap或者高度一起使用的时候，术语“压缩”和“解压缩”是等效的。这个技巧确保在不进行任何进一步矫正的情况下遵守最大的偏差，因
为逐步构建所需的数据。这些残差是根据在解压缩过程中可用的mip-map直接计算出的参考。压缩从最小的mip-map计算这些残差对于最大的一个，量
化他们，无损的编码他们并且保存他们。

第一个压缩的mip-map只是最小参考mip-map的唯一量化值。然后，首先从先前的压缩映射预测每个后续的mip-map。然后从相应的相同大小的目标mip-map
中减去这些预测以获得残差。然后尽可能地量化这些残差，以便仍然遵守当前压缩的mip映射的最大偏差。然后，他们被无损编码和存储。

![](https://i.loli.net/2018/07/28/5b5be19d96929.jpg)

![](https://i.loli.net/2018/07/28/5b5be1b69f7e0.jpg)

![](https://i.loli.net/2018/07/28/5b5be1c54cf7a.jpg)

关于压缩高度图的正式说明部分（要尽量认真弄懂，哪怕稍微朦朦胧胧的了解也行）：

更准确地说，第一遍给出浮动高度图样本的输入方块Ln；大小是2^nX2^n，并且要生成N层纹理贴图（mip-map）Ln-1,n-2.....0。一个接一个的生成出来。
对于尺寸来讲，Li是Li+1的一半宽度。因为Li是从L+1计算而来的。计算方式通过直观的像素平均值而来（具体做法之后会有所详解）。

Details of the method
Details of the method
Details of the method

在本章中，将更加详细的描述该方法。与前边的大纲不太相同，此描述足以让读者自己实现出细节的方法。
先是介绍了第一个自下而上通道内的mip-map的构造以及我们还有哪些替代结构需要考虑。接下来会介绍预测
P的公式以及预测运算符构造的方法。以便计算从较粗的mip-map重构更加精细的mip-map所需的残差并借助这些
残差进行重建。请注意，此方法不适用更新运算符。更详细的内容之后还会有说明。


如前一章所述，在第一个 - 自下而上 - 通过，我们只是从最大的一个 - 输入本身逐个构造目标mip-maps
 - 最小的一个，大小为1个像素。在每一步，我们构造一个较小的mipmap从最后构建的。新mip-map的维度是一半
最后一个的维度，换句话说，它是详细和包含的一半像素减少四倍。通常，我们可以通过任何形式构建新的mip-map
平均较大的mip-map的像素。在前一章中，我们解释过重建的最大绝对误差不取决于如何mip-maps看起来，只要它们包含有效值

但是，mip-map的外观会影响压缩比。相邻mip-map之间的高度差异越小，它们之间的过渡残差越低，因此压缩越高
比例是。另外，如介绍中所述，在渲染器内部在应用该方法的情况下，仔细选择某个地形方块的mip-map，以便最小化混叠。
此决定基于投影到屏幕的正方形区域。

我们知道，Li是从Li+1计算得来的，那么有平均值的公式：

![](https://i.loli.net/2018/07/30/5b5e6676c952d.jpg)

我们需要讨论的重点还是从上到下的通道，在这种情况下，我们需要计算残差。接下来我们更加详细的探讨从上到下的重建过程。

当从L-i构造（重建）较大的压缩mip-map L-i+1的时候。我们可以想象一下，因为L-i中的每个像素p被L-i1中的四个像素a，b
，c，d所代替，如图所示，我们将应用预测算子和后续残差计算和发夹三次以计算值。四个像素重点额一个和在解压缩期间从p重建
他们所需的残差。

![](https://i.loli.net/2018/07/30/5b5e692652704.jpg)

Prediction of a pixels
Prediction of a pixels
Prediction of a pixels

预测过程现在看来需要分成三步，第一步我们打算预测标记为a的像素。预测他们来自L-i内的相应p像素，我们使用一个简单的预测公式：
Pa (L-i) = p. 我们计算残差Ea和E-a相对于目标值在L-i+1中，然后分配最终值a-。很明显，MaxDev（a-，at）<=D,这部分是为了保证
误差不大于D的证明。那么我们求值a-的公式为：

![](https://i.loli.net/2018/07/30/5b5e6af946515.jpg)




























































