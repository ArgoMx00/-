真实的场景、梦幻的需求。

现在任务目标大概形成了一个新的需求：

①首先读入一个高度图（灰度图），然后还需要读入另外一个相关的2D贴图，这个2D贴图呢，是通过绘图工具画出来的一条河道。然后我们需要将这个大致方向，
映射到高度图中，将沿河道部分的高度图，进行一个数据处理。

真实的场景、梦幻的需求、、、、、、、、、、

基于小波的分层高度图压缩方法

在本文中，我们提出了一种基于小波的有损方法压缩高度图地形的数据。它保持重建每个样本绝对误差范围内的数据绑定可由用户调整。这个方法接受尺寸为2n*2n
的样本块。在输入端，它可以执行渐进式的mip-map解压缩。压缩256*256块需要大约30毫秒，减压越1毫秒。多亏了这些属性，该方法可用于实时进行渲染器，它
能够达到压缩比37:1对整个地球进行压缩。

关键词：高度图、有损压缩、小波

整个地球的实时渲染需要工作具有大型地形的数据，其存储和分配。多分辨率(LOD)的方法是必不可少的，达到合理的帧速率。在文献中，一项调查总结了最常见的
多分辨率渲染的论文方法。其中一些还包含数据压缩。

例如，在C-BDAM和P-BDAM中，压缩发生在节点的细化中LOD层次结构。子节点内的值是尽可能准确地从父节点预测。这些预测与实际价值之间的差异被称为残差、然
后量化这些残差并通过解码器压缩。因此，压缩是有损的。这两种方法都略有修改小波提升方案，确保错误重建数据的数据保持在最大误差范围之内。

作为案例研究，我们将此方法实施为插入应用程序，转换高度行星表面为256*256块的32位浮点样本以米为单位，然后单独存储并且在运行期间进入基于四叉树的LOD
层次结构。

小波的介绍

基本上，存在两代小波，第一代是基于扩张和翻译的计算小波函数，第二代是基于滤波器组，高通和地通滤波，它有已经证明这两种方法使计算上的东西。

我们将描述第二代离散与这项共组相关的小波变换。基础的这种变换的步骤称为提升-分解输入的信号样本的计数是两个相同大小的部分的功率-低通和高通、
然后地柜的应用该步骤到产生的低通部分，直到其长度为1,与提升相反的就是重建-通过高通信息来丰富低通样本以获得两倍详细的样本集合。它与提升完全
相反。该变化广泛用于压缩数据，这可以通过量化产生的高通部分来实现。

在信号样本的输入集上，递归的应用于低通，由前一次迭代产生的部分，知道最新的低通部分长度为1.方法的输入必须是一定的2次幂。如果输入的
长度是2^n，那么当前方法就要执行n次提升迭代。提升越来越小的输入被称为自下而上的传递。我们可以想象这是建立一个低通输出金字塔的第一层
是输入本身，然后后续更高层是提升低通输出适用于下边的等级，每一层都是前一层一半的宽度，在紫霞而上通过后，最高层的宽度为1.

要重建输入信号样本，我们所需要的只是最高层的低通信息，以及所有高通层。这可以在随后的自上而下传球，从顶部建立低通金字塔至底部。从前
一个生成较低层以其相关的高通信息称为重建，它是与之前完全相反的。

一维数据的地柜小波分解的一个例子样品，如下图。在左侧，有一个低通的金字塔，底部就是输入的高度图本身。虚线表示分解在第一个自下而上的
通道内和第二个自上而下的通道内的逆成分。在样本上，他也标记为哪个样品行程较小的低通部分，以及较小的高通部分。橙色的是偶数的，作为
索引样品从0开始。

![](https://i.loli.net/2018/07/28/5b5bd29618c3c.jpg)

现在我们简要介绍一下这个原理如何拓展到2尺寸的图像数据。基本上，这个拓展只引入了一个变化，所描述的原理-当提升应用于具有尺寸为2^n的图像的时候，它
产生四个大小相等的输出，尺寸为2^(n-1)：一个低通部分，和三个高通部分（图2.2）。这些高通部件中的每一个都包含不同的信息，例如，第一个可能包含
垂直信息，第二个水平边缘和第三个对角线边缘。随后的重建，所有者四个部分都用来产生更大的低通部分。分辨率就提升了两倍。

事实上，自上而下的传球只需要高通信息完全重建输入。这些信息往往稀疏而且依赖于输入。输入越平滑，它包含的高通信息就越少。如果我们压缩它，我们
可以节省很多存储空间。如果我们不需要为了精确地重建输入，我们甚至可以对残差进行抽取（量化）。因为这些信息通常只包含细节，所以它会仔细抽取。
不会使重建变形太多并确保更好的压缩比。另一个有趣的事实是，残差与金字塔的较低层相连，比那些绑定到更高的细节的细节更精细，多亏了这个。可以
更加积极地压缩更详细（更大）的残差集合。而不是那些不那么详细的。这称为渐进式压缩和它用于例如JPEG标准。

在以下部分中，我们将描述提升和重建的步骤。让我们设定，提升是输入样品Xk，它将他们分成偶数和奇数部分。X2k=Xe。X2k+1=X0。这种分裂尚未基于
样本的任何频率属性，它仅仅基于他们的情况。但是，这两组样本将随后被修改。以便偶数将包含低通信息。以及奇数部分会变成残差-高通信息。这会是
在两个公式操作的帮助下执行：预测算子P（高通过滤器）和更新操作符U（低通滤波器）。P将用于生产来自x0的残差d，并且U将用于生产来自xe的低通部分。

到目前为止，仅描述了第二代方法的共同属性。现在他们之间会有分歧。他们唯一不同的是他们进行提升和重建的方式。方式执行提升步骤清楚地确定了重建
的执行方式，因为重建必须是提升的精确倒数。提升步骤以应用运算符P和U的顺序变化。据此，这些方法可以分成两大类-预测优先组合更新优先。

在预测优先方法中，首先应用预测：

![](https://i.loli.net/2018/07/28/5b5bd6e305fd3.jpg)

重建就必须相反，以及更新优先的公式和其重建内容：

 ![](https://i.loli.net/2018/07/28/5b5bd7de96143.jpg)

差不多引入了一堆概念，我们接下来要开始实现，也就是先得到方法的大纲：

自下而上的传递计算目标mip-maps-从最大的一个到最小的一个。那些将是mip-map，用于衡量重建的准确性。最大的mip-map是输入本身。每个较小
的mip-map都是从之前较大的mip-map计算出来的。这些mip-maps会在压缩过程中仅用作临时引用，不以任何方式存储。

自上而下的传递执行这些参考mip-map的压缩。在此过程中，它已经完全按照他们的方式构建了mip-maps在减压之后，从最小的一个到最大的一个，
然而，当与mipmap或者高度一起使用的时候，术语“压缩”和“解压缩”是等效的。这个技巧确保在不进行任何进一步矫正的情况下遵守最大的偏差，因
为逐步构建所需的数据。这些残差是根据在解压缩过程中可用的mip-map直接计算出的参考。压缩从最小的mip-map计算这些残差对于最大的一个，量
化他们，无损的编码他们并且保存他们。

第一个压缩的mip-map只是最小参考mip-map的唯一量化值。然后，首先从先前的压缩映射预测每个后续的mip-map。然后从相应的相同大小的目标mip-map
中减去这些预测以获得残差。然后尽可能地量化这些残差，以便仍然遵守当前压缩的mip映射的最大偏差。然后，他们被无损编码和存储。

![](https://i.loli.net/2018/07/28/5b5be19d96929.jpg)

![](https://i.loli.net/2018/07/28/5b5be1b69f7e0.jpg)

![](https://i.loli.net/2018/07/28/5b5be1c54cf7a.jpg)

关于压缩高度图的正式说明部分（要尽量认真弄懂，哪怕稍微朦朦胧胧的了解也行）：

更准确地说，第一遍给出浮动高度图样本的输入方块Ln；大小是2^nX2^n，并且要生成N层纹理贴图（mip-map）Ln-1,n-2.....0。一个接一个的生成出来。
对于尺寸来讲，Li是Li+1的一半宽度。因为Li是从L+1计算而来的。计算方式通过直观的像素平均值而来（具体做法之后会有所详解）。

























































提升以下列方式进行：

输入样本我们设定为Xk，它被分成偶数：X2K=Xe，也有被分成奇数的：X2k+1=X0；接下来两种操作被介绍：
用于从X0产生最终高通部分d（残差）的预测算子P和用于从Xe产生无效通过部分s的更新操作者。预测-第一种
方法首先应用预测运算符，然后应用更新运算符：

![](https://i.loli.net/2018/07/28/5b5bc2d86b68a.jpg)

接下来这部分不是很能看懂，我先放在一边不看了。








接下来我们先跳过小波部分，来直接探讨当前压缩方法的框架。以下是压缩的工作原理：

我们在输入高度图上执行两次传递。在第一个底部顶部传递中，我们计算目标mip-maps---从最大的一个到最小的一个。在第二个
上下通道中，我们构造了相对于目标mip-map从最小到最大的有所mip映射，以便保留最大误差界限。对于每个构建的mip-map，我
门存储需要的siduals来自前一个解压缩的mip-map。稍微详细的一点说，给定大小为2nx2n的浮点高度图样本Ln的输入方块，从其
种构造n个mip-maps。L0，L1,L2.......Ln-1；其中，Li是Li+1的一半，并且Li是从Li+1计算过来的。计算方法大概是平均像素

在第二个通道中，我们讨论L0....n的由来。我们计算最终L0.....n的映射。Li和L0i具有相同的大小。并且他们的相应样本之间的
最大绝对偏差不大于用户的D参数。我们用公式描述起来就是：

![](https://i.loli.net/2018/07/28/5b5bc5a3ae2ac.jpg)

我们在统一量化器QD的帮助下，构造这些Mip-map，并且考虑到这个误差范围：

![](https://i.loli.net/2018/07/28/5b5bc605213ec.png)

并且L0i+1计算是从L0i来的。听过量化目标值和预测之间的差异，我们有公式：

![](https://i.loli.net/2018/07/28/5b5bc67b3c9b5.jpg)


其中P是预测算子，Ei +是差值，E•i +是量化差异。注意，由于量化器将最大绝对误差保持在界限D内，并且残差Ei +是相对于目标mip-map Li + computed，maxdev（L•i +，Li +）≤D计算的，否则是什么值inL•i和预测算子P的形式是什么。所有量化残差E·..n然后在熵编解码器（Zlib）的帮助下压缩并保存（E•= L• ），因此P越准确，压缩比越好。下一节将介绍此方法中使用的预测运算符的详细信息。在解压缩期间，读取量化残差并用于逐步重建mip映射水平L·..n（等式1）。

详细的做法：

mip-map的下采样可以通过任何形式的平均值来执行。正如我们在钱一章看到的那样，最大绝对误差不依赖于mip-map的外观，只要他们
包含有效值即可。但是，构建mip-map的方式会影响压缩比。此外，各种mip-map结构产生不同的视觉伪像。就视觉伪像来讲，对mip-map
进行下采样的最佳方法使将Li+1中的周围四个格子的平均值进行计算，来得到Li。



























