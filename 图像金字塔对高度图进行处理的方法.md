一、了解图像金字塔

图像金字塔就类似于之前我们接触过的高度图压缩过程的每一个分层结构整体构成的内容。那么我们接下来了解一下图像金字塔的基本原理：

由于图像的拉普拉斯金字塔的构成是在高斯金字塔的基础上演变而来的，因此首先得对图像进行高斯金字塔分解。

二、高斯金字塔分解

高斯金字塔分解就是术语中的采样。说白了，这部分的内容就是将高度图进行不断缩小的过程。
相比于之前的预测做法，缩小的同时会保留更多的内容。我们设定原图像为G0，以G0作为高斯金字塔的第0层（底层，输入层）。对原始输入图像
进行高斯低通滤波和隔行隔列的下采样，得到高斯金字塔的第一层。再对第一层图像低通滤波和下采样，得到第二层，重复过程，构成高斯金字塔。
高斯金字塔的构建过程为：假设高斯金字塔的第l层图像为Gl,那么我们采样的公式如下：

![](https://i.loli.net/2018/08/01/5b615515915f5.jpg)

对于其中的w（m，n），它是一个5*5的窗口，窗口值分别为：

![](https://i.loli.net/2018/08/01/5b61557f0dfdf.jpg)

由此，我们可以从G0开始重复操作，构成高斯金字塔。

三、图像的拉普拉斯金字塔分解

将Gl内插值的方法，得到放大图像G-l，使得G-l的尺寸大小和Gl-1的尺寸大小相同。表示为：

![](https://i.loli.net/2018/08/01/5b6155dfcc028.jpg)

![](https://i.loli.net/2018/08/01/5b615605c609f.jpg)

那么我们就得到了残差金字塔。也就是拉普拉斯金字塔。它的每一层图像是高斯金字塔本层图像与其高一图像经内插放大后图像的差。此过程相当于
带通滤波，因此拉普拉斯金字塔又被称为带通金字塔分解。

四、重建图像金字塔

既然我们已经有了残差金字塔，那么我们就很容易得到金字塔的重建方式了，我们只要有当前图像，那么就可以计算下一图像的预测值，然后加上残差
图像就能够得到下一个图像。所以我们有公式：

![](https://i.loli.net/2018/08/01/5b6159836e9f5.jpg)

五、实现

那么我们接下来用Unity和C#来实现上述算法过程。

测试第一版本的代码（操作效果还行，不过展示的结果和之前的结果还是有差别，按道理来讲不应该有差别啊）：

六、值得注意的点

我们计算的残差矩阵是有负值的，因为Texture2D当中的图像的像素颜色区间是在【0,1】之间的，所以我们需要考虑将残差矩阵中的赋值进行一个量化操作使得其值【0,1】之间。

做法也很简单，因为残差的值在区间【-1,1】之间的，所以我们要把值X∈【-1，1】规划到【0，1】之间，那么我们对值（X+1）/2即可，我们用来保存的方式有了一种量化映射的方法，那么在使用残差矩阵重构矩阵的时候呢，我们再将值逆运算即可。

实现的代码如下：

```C#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
public class Guss_Compress_HeightMap : MonoBehaviour
{

    public Texture2D heightmap;
    public int N;
    public float[][][] heightmaps = new float[15][][];
    public float[,] W = new float[5, 5];
    public void Start()
    {
        Compress_Init();
        for (int i = N - 1; i >= 1; i--) Compress_HeightMap(i);
        Print_Png();
    }
    public void Print_Png()
    {
        for (int z = N; z >= 1; z--)
        {
            int n = (int)Mathf.Pow(2, z);
            Texture2D texture = new Texture2D(n, n);
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    Color color = new Color(heightmaps[z][i][j], heightmaps[z][i][j], heightmaps[z][i][j], 1f);
                    texture.SetPixel(i, j, color);
                }
            }
            texture.Apply();
            SaveThisTextureToPng(texture, z);
        }
    }
    public void SaveThisTextureToPng(Texture2D texture, int NowLevel)
    {
        string Name = "GussOut";
        Name += NowLevel.ToString();
        Name += ".png";
        print(Name);
        SaveTextureToPng(texture, Application.dataPath + "/Resources", Name);
    }
    public void SaveTextureToPng(Texture2D inputTex, string contents, string pngName)
    {
        RenderTexture temp = RenderTexture.GetTemporary(inputTex.width, inputTex.height, 0, RenderTextureFormat.ARGB32);
        Graphics.Blit(inputTex, temp);
        SaveRenderTextureToPng(temp, contents, pngName);
    }
    public void SaveRenderTextureToPng(RenderTexture rt, string contents, string pngName)
    {
        RenderTexture prev = RenderTexture.active;
        RenderTexture.active = rt;
        Texture2D png = new Texture2D(rt.width, rt.height, TextureFormat.ARGB32, false);
        png.ReadPixels(new Rect(0, 0, rt.width, rt.height), 0, 0);
        byte[] bytes = png.EncodeToPNG();
        if (!Directory.Exists(contents))
            Directory.CreateDirectory(contents);
        FileStream file = File.Open(contents + "/" + pngName + ".png", FileMode.Create);
        BinaryWriter writer = new BinaryWriter(file);
        writer.Write(bytes);
        file.Close();
        Texture2D.DestroyImmediate(png);
        png = null;
        RenderTexture.active = prev;
    }
    public void Compress_HeightMap(int NowLevel)
    {
        int tempLen = (int)Mathf.Pow(2, NowLevel);
        for (int i = 0; i < tempLen; i++)
        {
            for (int j = 0; j < tempLen; j++)
            {
                float sum = 0;
                float beilv = 256;
                for (int m = -2; m <= 2; m++)
                {
                    for (int n = -2; n <= 2; n++)
                    {
                        int ni = i * 2 + m;
                        int nj = j * 2 + n;
                        if (ni >= 0 && ni < tempLen * 2 && nj >= 0 && nj < tempLen * 2)
                        {
                            sum += W[m + 2, n + 2] * heightmaps[NowLevel + 1][ni][nj];
                        }
                    }
                }
                sum = sum / beilv;
                heightmaps[NowLevel][i][j] = sum;
            }
        }
    }
    public void Compress_Init()
    {
        //得到窗口函数
        W[0, 0] = 1; W[0, 1] = 4; W[0, 2] = 6; W[0, 3] = 4; W[0, 4] = 1;
        W[1, 0] = 4; W[1, 1] = 16; W[1, 2] = 24; W[1, 3] = 16; W[1, 4] = 4;
        W[2, 0] = 6; W[2, 1] = 24; W[2, 2] = 36; W[2, 3] = 24; W[2, 4] = 6;
        W[3, 0] = 4; W[3, 1] = 16; W[3, 2] = 24; W[3, 3] = 16; W[3, 4] = 4;
        W[4, 0] = 1; W[4, 1] = 4; W[4, 2] = 6; W[4, 3] = 4; W[4, 4] = 1;


        //得到原图的高度二维值
        for (int z = N; z >= 1; z--)
        {
            int n = (int)Mathf.Pow(2, z);
            //print(n);
            heightmaps[z] = new float[n + 2][];
            for (int j = 0; j < n; j++)
            {
                heightmaps[z][j] = new float[n + 2];
            }
        }

        int tempLen = (int)Mathf.Pow(2, N);
        for (int i = 0; i < tempLen; i++)
        {
            for (int j = 0; j < tempLen; j++)
            {
                float Bx = (float)(1.0f / (float)tempLen);
                float Bz = (float)(1.0f / (float)tempLen);
                float tempi = i * Bx;
                float tempj = j * Bz;

                heightmaps[N][i][j] = GetCellHeight(heightmap, new Vector2(tempi, tempj));
            }
        }
    }
    public float GetCellHeight(Texture2D map, Vector2 uv)
    {
        // 如果贴图不为空
        if (map != null)
        {
            Color c = GetCellColor(map, uv);
            float gray = c.grayscale;
            float h = 1f * gray;
            return h;
        }
        else return 0;
    }
    public Color GetCellColor(Texture2D map, Vector2 uv)
    {
        Color color = map.GetPixel(Mathf.FloorToInt(map.width * uv.x), Mathf.FloorToInt(map.height * uv.y));
        return color;
    }
}
```

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
public class Laplace_Pyramid_Build_E : MonoBehaviour
{
    //公式中的Gl
    private float[][][] heightmaps = new float[15][][];
    //公式中的G-l
    private float[][][] Nexheightmaps = new float[15][][];
    private float[][][] E = new float[15][][];
    public int N;
    private float[,] W = new float[5, 5];
    public void Start()
    {
        //首先我们开辟空间
        Init_RAM_W();
        //然后我们需要对高斯金字塔中的每个缩小图的图片导入并且获得高度图信息
        for (int i = 1; i <= N; i++) Get_Init_HeightMaps(i);

        //接下来开始计算拉普拉斯金字塔
        for (int i = 1; i <= N - 1; i++) Get_Laplace_Pyramid(i);
        //倒数第二步计算得到残差图像
        for (int i = 1; i <= N; i++) Get_Laplace_E(i);
        //最后我们打印出残差图像出来
        Print_Png();
    }


    public void Init_RAM_W()
    {
        //开辟不规则三维数组的空间。
        for (int z = N; z >= 1; z--)
        {
            int n = (int)Mathf.Pow(2, z);
            //print(n);
            heightmaps[z] = new float[n + 2][];
            Nexheightmaps[z] = new float[n + 2][];
            E[z] = new float[n + 2][];
            for (int j = 0; j < n; j++)
            {
                heightmaps[z][j] = new float[n + 2];
                Nexheightmaps[z][j] = new float[n + 2];
                E[z][j] = new float[n + 2];
            }
        }
        //得到窗口函数
        W[0, 0] = 1; W[0, 1] = 4; W[0, 2] = 6; W[0, 3] = 4; W[0, 4] = 1;
        W[1, 0] = 4; W[1, 1] = 16; W[1, 2] = 24; W[1, 3] = 16; W[1, 4] = 4;
        W[2, 0] = 6; W[2, 1] = 24; W[2, 2] = 36; W[2, 3] = 24; W[2, 4] = 6;
        W[3, 0] = 4; W[3, 1] = 16; W[3, 2] = 24; W[3, 3] = 16; W[3, 4] = 4;
        W[4, 0] = 1; W[4, 1] = 4; W[4, 2] = 6; W[4, 3] = 4; W[4, 4] = 1;
    }
    public void Get_Init_HeightMaps(int NowLevel)
    {

        string PngName = "GussOut";
        PngName += NowLevel.ToString();
        PngName += ".png";
        Texture2D texture = ((Texture2D)Resources.Load(PngName));

        int tempLen = (int)Mathf.Pow(2, NowLevel);
        for (int i = 0; i < tempLen; i++)
        {
            for (int j = 0; j < tempLen; j++)
            {
                float Bx = (float)(1.0f / (float)tempLen);
                float Bz = (float)(1.0f / (float)tempLen);
                float tempi = i * Bx;
                float tempj = j * Bz;

                heightmaps[NowLevel][i][j] = GetCellHeight(texture, new Vector2(tempi, tempj));
            }
        }
    }
    public float GetCellHeight(Texture2D map, Vector2 uv)
    {
        // 如果贴图不为空
        if (map != null)
        {
            Color c = GetCellColor(map, uv);
            float gray = c.grayscale;
            float h = 1f * gray;
            return h;
        }
        else return 0;
    }
    public Color GetCellColor(Texture2D map, Vector2 uv)
    {
        Color color = map.GetPixel(Mathf.FloorToInt(map.width * uv.x), Mathf.FloorToInt(map.height * uv.y));
        return color;
    }
    public void Get_Laplace_Pyramid(int NowLevel)
    {
        int nextempLen = (int)Mathf.Pow(2, NowLevel + 1);
        for (int i = 0; i < nextempLen; i++)
        {
            for (int j = 0; j < nextempLen; j++)
            {
                float sum = 0;
                float beilv = 256;
                for (int m = -2; m <= 2; m++)
                {
                    for (int n = -2; n <= 2; n++)
                    {
                        if (i + m >= 0 && j + n >= 0)
                        {
                            if ((i + m) % 2 == 0 && (j + n) % 2 == 0)
                            {
                                int ni = (i + m) / 2;
                                int nj = (j + n) / 2;
                                if (ni >= 0 && ni < nextempLen / 2 && nj >= 0 && nj < nextempLen / 2)
                                {
                                    sum += 4.0f * W[m + 2, n + 2] * heightmaps[NowLevel][ni][nj];
                                }
                            }
                        }
                    }
                }
                sum = sum / beilv;
                Nexheightmaps[NowLevel + 1][i][j] = sum;
            }
        }
    }
    public void Get_Laplace_E(int NowLevel)
    {
        if (NowLevel == 1)
        {
            int tempLen = (int)Mathf.Pow(2, NowLevel);
            for (int i = 0; i < tempLen; i++)
            {
                for (int j = 0; j < tempLen; j++)
                {
                    E[NowLevel][i][j] = heightmaps[NowLevel][i][j];
                }
            }
        }
        else
        {
            int tempLen = (int)Mathf.Pow(2, NowLevel);
            for (int i = 0; i < tempLen; i++)
            {
                for (int j = 0; j < tempLen; j++)
                {
                    E[NowLevel][i][j] = heightmaps[NowLevel][i][j] - Nexheightmaps[NowLevel][i][j];
                }
            }
        }
    }
    public void Print_Png()
    {
        for (int z = N; z >= 1; z--)
        {
            int n = (int)Mathf.Pow(2, z);
            Texture2D texture = new Texture2D(n, n);
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    E[z][i][j] = E[z][i][j] + 1;
                    E[z][i][j] = (float)(E[z][i][j] / 2.0f);
                    Color color = new Color(E[z][i][j], E[z][i][j], E[z][i][j], 1.0f);
                    texture.SetPixel(i, j, color);
                }
            }
            texture.Apply();
            SaveThisTextureToPng(texture, z);
        }
    }
    public void SaveThisTextureToPng(Texture2D texture, int NowLevel)
    {
        string Name = "EOut";
        Name += NowLevel.ToString();
        Name += ".png";
        print(Name);
        SaveTextureToPng(texture, Application.dataPath + "/E pyramid", Name);
    }
    public void SaveTextureToPng(Texture2D inputTex, string contents, string pngName)
    {
        RenderTexture temp = RenderTexture.GetTemporary(inputTex.width, inputTex.height, 0, RenderTextureFormat.ARGB32);
        Graphics.Blit(inputTex, temp);
        SaveRenderTextureToPng(temp, contents, pngName);
    }
    public void SaveRenderTextureToPng(RenderTexture rt, string contents, string pngName)
    {
        RenderTexture prev = RenderTexture.active;
        RenderTexture.active = rt;
        Texture2D png = new Texture2D(rt.width, rt.height, TextureFormat.ARGB32, false);
        png.ReadPixels(new Rect(0, 0, rt.width, rt.height), 0, 0);
        byte[] bytes = png.EncodeToPNG();
        if (!Directory.Exists(contents))
            Directory.CreateDirectory(contents);
        FileStream file = File.Open(contents + "/" + pngName + ".png", FileMode.Create);
        BinaryWriter writer = new BinaryWriter(file);
        writer.Write(bytes);
        file.Close();
        Texture2D.DestroyImmediate(png);
        png = null;
        RenderTexture.active = prev;
    }
}
```

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
//我们直接实现出来整个从最小图像到最大图像的重建。
public class ReBuild_ : MonoBehaviour
{

    public int N;
    public float[][][] heightmaps = new float[15][][];
    public float[][][] E = new float[15][][];
    private float[,] W = new float[5, 5];
    public void Start()
    {
        //首先我们开辟空间
        Init_RAM();
        //然后我们读取全部的残差图出来
        for (int i = 1; i <= N; i++) Get_E_HeightMaps(i);
        //接下来我们要开始按照顺序得到重构图
        for (int i = 1; i <= N; i++) Get_Rebuild_HeightMaps(i);
        //输出重构图
        Print_Png();
    }

    public void Init_RAM()
    {
        //开辟不规则三维数组的空间。
        for (int z = N; z >= 1; z--)
        {
            int n = (int)Mathf.Pow(2, z);
            //print(n);
            heightmaps[z] = new float[n + 2][];
            E[z] = new float[n + 2][];
            for (int j = 0; j < n; j++)
            {
                heightmaps[z][j] = new float[n + 2];
                E[z][j] = new float[n + 2];
            }
        }
        //得到窗口函数
        W[0, 0] = 1; W[0, 1] = 4; W[0, 2] = 6; W[0, 3] = 4; W[0, 4] = 1;
        W[1, 0] = 4; W[1, 1] = 16; W[1, 2] = 24; W[1, 3] = 16; W[1, 4] = 4;
        W[2, 0] = 6; W[2, 1] = 24; W[2, 2] = 36; W[2, 3] = 24; W[2, 4] = 6;
        W[3, 0] = 4; W[3, 1] = 16; W[3, 2] = 24; W[3, 3] = 16; W[3, 4] = 4;
        W[4, 0] = 1; W[4, 1] = 4; W[4, 2] = 6; W[4, 3] = 4; W[4, 4] = 1;
    }
    public void Get_E_HeightMaps(int NowLevel)
    {
        Texture2D texture = GetEtexture(NowLevel);
        int tempLen = (int)Mathf.Pow(2, NowLevel);
        for (int i = 0; i < tempLen; i++)
        {
            for (int j = 0; j < tempLen; j++)
            {
                float Bx = (float)(1.0f / (float)tempLen);
                float Bz = (float)(1.0f / (float)tempLen);
                float tempi = i * Bx;
                float tempj = j * Bz;

                E[NowLevel][i][j] = GetCellHeight(texture, new Vector2(tempi, tempj));
                E[NowLevel][i][j] = E[NowLevel][i][j] * 2;
                E[NowLevel][i][j] = E[NowLevel][i][j] - 1;
            }
        }
    }
    public float GetCellHeight(Texture2D map, Vector2 uv)
    {
        // 如果贴图不为空
        if (map != null)
        {
            Color c = GetCellColor(map, uv);
            float gray = c.grayscale;
            float h = 1f * gray;
            return h;
        }
        else return 0;
    }
    public Color GetCellColor(Texture2D map, Vector2 uv)
    {
        Color color = map.GetPixel(Mathf.FloorToInt(map.width * uv.x), Mathf.FloorToInt(map.height * uv.y));
        return color;
    }
    public Texture2D GetEtexture(int NowLevel)
    {
        double startTime = (double)Time.time;
        //创建文件读取流
        string PathName = Application.dataPath + "/E pyramid";
        PathName += "/EOut";
        PathName += NowLevel.ToString();
        PathName += ".png.png";
        //print(PathName);
        FileStream fileStream = new FileStream(PathName, FileMode.Open, FileAccess.Read);
        fileStream.Seek(0, SeekOrigin.Begin);
        //创建文件长度缓冲区
        byte[] bytes = new byte[fileStream.Length];
        //读取文件
        fileStream.Read(bytes, 0, (int)fileStream.Length);
        //释放文件读取流
        fileStream.Close();
        fileStream.Dispose();
        fileStream = null;
        int Val = (int)Mathf.Pow(2, NowLevel);
        Texture2D texture = new Texture2D(Val, Val);
        texture.LoadImage(bytes);
        return texture;
    }
    public void Get_Rebuild_HeightMaps(int NowLevel)
    {
        if (NowLevel == 1)
        {
            //如果当前是最小的那张图，那么我们直接定义结果就是它残差图本身。
            int tempLen = (int)Mathf.Pow(2, NowLevel);
            for (int i = 0; i < tempLen; i++)
            {
                for (int j = 0; j < tempLen; j++)
                {
                    heightmaps[NowLevel][i][j] = E[NowLevel][i][j];
                }
            }
        }
        else
        {
            //如果不是最小那张图，那么用上一级的结果图，来加上残差得到当前层结果图。
            int tempLen = (int)Mathf.Pow(2, NowLevel);
            for (int i = 0; i < tempLen; i++)
            {
                for (int j = 0; j < tempLen; j++)
                {
                    float sum = 0;
                    float beilv = 256;
                    for (int m = -2; m <= 2; m++)
                    {
                        for (int n = -2; n <= 2; n++)
                        {
                            if (i + m >= 0 && j + n >= 0)
                            {
                                if ((i + m) % 2 == 0 && (j + n) % 2 == 0)
                                {
                                    int ni = (i + m) / 2;
                                    int nj = (j + n) / 2;
                                    if (ni >= 0 && ni < tempLen / 2 && nj >= 0 && nj < tempLen / 2)
                                    {
                                        sum += 4.0f * W[m + 2, n + 2] * heightmaps[NowLevel - 1][ni][nj];
                                    }
                                }
                            }
                        }
                    }
                    sum = sum / beilv;
                    heightmaps[NowLevel][i][j] = sum;
                }
            }
            for (int i = 0; i < tempLen; i++)
            {
                for (int j = 0; j < tempLen; j++)
                {
                    heightmaps[NowLevel][i][j] = heightmaps[NowLevel][i][j] + E[NowLevel][i][j];
                }
            }
        }
    }
    public void Print_Png()
    {
        for (int z = N; z >= 1; z--)
        {
            int n = (int)Mathf.Pow(2, z);
            Texture2D texture = new Texture2D(n, n);
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    Color color = new Color(heightmaps[z][i][j], heightmaps[z][i][j], heightmaps[z][i][j], 1.0f);
                    texture.SetPixel(i, j, color);
                }
            }
            texture.Apply();
            SaveThisTextureToPng(texture, z);
        }
    }
    public void SaveThisTextureToPng(Texture2D texture, int NowLevel)
    {
        string Name = "ReBuildOut";
        Name += NowLevel.ToString();
        Name += ".png";
        print(Name);
        SaveTextureToPng(texture, Application.dataPath + "/ReBuild pyramid", Name);
    }
    public void SaveTextureToPng(Texture2D inputTex, string contents, string pngName)
    {
        RenderTexture temp = RenderTexture.GetTemporary(inputTex.width, inputTex.height, 0, RenderTextureFormat.ARGB32);
        Graphics.Blit(inputTex, temp);
        SaveRenderTextureToPng(temp, contents, pngName);
    }
    public void SaveRenderTextureToPng(RenderTexture rt, string contents, string pngName)
    {
        RenderTexture prev = RenderTexture.active;
        RenderTexture.active = rt;
        Texture2D png = new Texture2D(rt.width, rt.height, TextureFormat.ARGB32, false);
        png.ReadPixels(new Rect(0, 0, rt.width, rt.height), 0, 0);
        byte[] bytes = png.EncodeToPNG();
        if (!Directory.Exists(contents))
            Directory.CreateDirectory(contents);
        FileStream file = File.Open(contents + "/" + pngName + ".png", FileMode.Create);
        BinaryWriter writer = new BinaryWriter(file);
        writer.Write(bytes);
        file.Close();
        Texture2D.DestroyImmediate(png);
        png = null;
        RenderTexture.active = prev;
    }
}
```

残差效果图展示(展示可见的后边的结果):

![](https://i.loli.net/2018/08/01/5b61946e1bf90.png)
![](https://i.loli.net/2018/08/01/5b61946e1e975.png)
![](https://i.loli.net/2018/08/01/5b61946e288e0.png)
![](https://i.loli.net/2018/08/01/5b61946e3ae86.png)
