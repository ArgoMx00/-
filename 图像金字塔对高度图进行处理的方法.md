一、了解图像金字塔

图像金字塔就类似于之前我们接触过的高度图压缩过程的每一个分层结构整体构成的内容。那么我们接下来了解一下图像金字塔的基本原理：

由于图像的拉普拉斯金字塔的构成是在高斯金字塔的基础上演变而来的，因此首先得对图像进行高斯金字塔分解。

二、高斯金字塔分解

高斯金字塔分解就是术语中的采样。说白了，这部分的内容就是将高度图进行不断缩小的过程。
相比于之前的预测做法，缩小的同时会保留更多的内容。我们设定原图像为G0，以G0作为高斯金字塔的第0层（底层，输入层）。对原始输入图像
进行高斯低通滤波和隔行隔列的下采样，得到高斯金字塔的第一层。再对第一层图像低通滤波和下采样，得到第二层，重复过程，构成高斯金字塔。
高斯金字塔的构建过程为：假设高斯金字塔的第l层图像为Gl,那么我们采样的公式如下：

![](https://i.loli.net/2018/08/01/5b615515915f5.jpg)

对于其中的w（m，n），它是一个5*5的窗口，窗口值分别为：

![](https://i.loli.net/2018/08/01/5b61557f0dfdf.jpg)

由此，我们可以从G0开始重复操作，构成高斯金字塔。

三、图像的拉普拉斯金字塔分解

将Gl内插值的方法，得到放大图像G-l，使得G-l的尺寸大小和Gl-1的尺寸大小相同。表示为：

![](https://i.loli.net/2018/08/01/5b6155dfcc028.jpg)

![](https://i.loli.net/2018/08/01/5b615605c609f.jpg)

那么我们就得到了残差金字塔。也就是拉普拉斯金字塔。它的每一层图像是高斯金字塔本层图像与其高一图像经内插放大后图像的差。此过程相当于
带通滤波，因此拉普拉斯金字塔又被称为带通金字塔分解。

四、重建图像金字塔

既然我们已经有了残差金字塔，那么我们就很容易得到金字塔的重建方式了，我们只要有当前图像，那么就可以计算下一图像的预测值，然后加上残差
图像就能够得到下一个图像。所以我们有公式：

![](https://i.loli.net/2018/08/01/5b6159836e9f5.jpg)

五、实现

那么我们接下来用Unity和C#来实现上述算法过程。

测试第一版本的代码（操作效果还行，不过展示的结果和之前的结果还是有差别，按道理来讲不应该有差别啊）：

六、值得注意的点

我们计算的残差矩阵是有负值的，因为Texture2D当中的图像的像素颜色区间是在【0,1】之间的，所以我们需要考虑将残差矩阵中的赋值进行一个量化操作使得其值【0,1】之间。

做法也很简单，因为残差的值在区间【-1,1】之间的，所以我们要把值X∈【-1，1】规划到【0，1】之间，那么我们对值（X+1）/2即可，我们用来保存的方式有了一种量化映射的方法，那么在使用残差矩阵重构矩阵的时候呢，我们再将值逆运算即可。

实现的代码如下：

```C#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
public class Guss_Compress_HeightMap : MonoBehaviour
{

    public Texture2D heightmap;
    public int N;
    public float[][][] heightmaps = new float[15][][];
    public float[,] W = new float[5, 5];
    public void Start()
    {
        Compress_Init();
        for (int i = N - 1; i >= 1; i--) Compress_HeightMap(i);
        Print_Png();
    }
    public void Print_Png()
    {
        for (int z = N; z >= 1; z--)
        {
            int n = (int)Mathf.Pow(2, z);
            Texture2D texture = new Texture2D(n, n);
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    Color color = new Color(heightmaps[z][i][j], heightmaps[z][i][j], heightmaps[z][i][j], 1f);
                    texture.SetPixel(i, j, color);
                }
            }
            texture.Apply();
            SaveThisTextureToPng(texture, z);
        }
    }
    public void SaveThisTextureToPng(Texture2D texture, int NowLevel)
    {
        string Name = "GussOut";
        Name += NowLevel.ToString();
        Name += ".png";
        print(Name);
        SaveTextureToPng(texture, Application.dataPath + "/Resources", Name);
    }
    public void SaveTextureToPng(Texture2D inputTex, string contents, string pngName)
    {
        RenderTexture temp = RenderTexture.GetTemporary(inputTex.width, inputTex.height, 0, RenderTextureFormat.ARGB32);
        Graphics.Blit(inputTex, temp);
        SaveRenderTextureToPng(temp, contents, pngName);
    }
    public void SaveRenderTextureToPng(RenderTexture rt, string contents, string pngName)
    {
        RenderTexture prev = RenderTexture.active;
        RenderTexture.active = rt;
        Texture2D png = new Texture2D(rt.width, rt.height, TextureFormat.ARGB32, false);
        png.ReadPixels(new Rect(0, 0, rt.width, rt.height), 0, 0);
        byte[] bytes = png.EncodeToPNG();
        if (!Directory.Exists(contents))
            Directory.CreateDirectory(contents);
        FileStream file = File.Open(contents + "/" + pngName + ".png", FileMode.Create);
        BinaryWriter writer = new BinaryWriter(file);
        writer.Write(bytes);
        file.Close();
        Texture2D.DestroyImmediate(png);
        png = null;
        RenderTexture.active = prev;
    }
    public void Compress_HeightMap(int NowLevel)
    {
        int tempLen = (int)Mathf.Pow(2, NowLevel);
        for (int i = 0; i < tempLen; i++)
        {
            for (int j = 0; j < tempLen; j++)
            {
                float sum = 0;
                float beilv = 256;
                for (int m = -2; m <= 2; m++)
                {
                    for (int n = -2; n <= 2; n++)
                    {
                        int ni = i * 2 + m;
                        int nj = j * 2 + n;
                        if (ni >= 0 && ni < tempLen * 2 && nj >= 0 && nj < tempLen * 2)
                        {
                            sum += W[m + 2, n + 2] * heightmaps[NowLevel + 1][ni][nj];
                        }
                    }
                }
                sum = sum / beilv;
                heightmaps[NowLevel][i][j] = sum;
            }
        }
    }
    public void Compress_Init()
    {
        //得到窗口函数
        W[0, 0] = 1; W[0, 1] = 4; W[0, 2] = 6; W[0, 3] = 4; W[0, 4] = 1;
        W[1, 0] = 4; W[1, 1] = 16; W[1, 2] = 24; W[1, 3] = 16; W[1, 4] = 4;
        W[2, 0] = 6; W[2, 1] = 24; W[2, 2] = 36; W[2, 3] = 24; W[2, 4] = 6;
        W[3, 0] = 4; W[3, 1] = 16; W[3, 2] = 24; W[3, 3] = 16; W[3, 4] = 4;
        W[4, 0] = 1; W[4, 1] = 4; W[4, 2] = 6; W[4, 3] = 4; W[4, 4] = 1;


        //得到原图的高度二维值
        for (int z = N; z >= 1; z--)
        {
            int n = (int)Mathf.Pow(2, z);
            //print(n);
            heightmaps[z] = new float[n + 2][];
            for (int j = 0; j < n; j++)
            {
                heightmaps[z][j] = new float[n + 2];
            }
        }

        int tempLen = (int)Mathf.Pow(2, N);
        for (int i = 0; i < tempLen; i++)
        {
            for (int j = 0; j < tempLen; j++)
            {
                float Bx = (float)(1.0f / (float)tempLen);
                float Bz = (float)(1.0f / (float)tempLen);
                float tempi = i * Bx;
                float tempj = j * Bz;

                heightmaps[N][i][j] = GetCellHeight(heightmap, new Vector2(tempi, tempj));
            }
        }
    }
    public float GetCellHeight(Texture2D map, Vector2 uv)
    {
        // 如果贴图不为空
        if (map != null)
        {
            Color c = GetCellColor(map, uv);
            float gray = c.grayscale;
            float h = 1f * gray;
            return h;
        }
        else return 0;
    }
    public Color GetCellColor(Texture2D map, Vector2 uv)
    {
        Color color = map.GetPixel(Mathf.FloorToInt(map.width * uv.x), Mathf.FloorToInt(map.height * uv.y));
        return color;
    }
}
```

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
public class Laplace_Pyramid_Build_E : MonoBehaviour
{
    //公式中的Gl
    private float[][][] heightmaps = new float[15][][];
    //公式中的G-l
    private float[][][] Nexheightmaps = new float[15][][];
    private float[][][] E = new float[15][][];
    public int N;
    private float[,] W = new float[5, 5];
    public void Start()
    {
        //首先我们开辟空间
        Init_RAM_W();
        //然后我们需要对高斯金字塔中的每个缩小图的图片导入并且获得高度图信息
        for (int i = 1; i <= N; i++) Get_Init_HeightMaps(i);

        //接下来开始计算拉普拉斯金字塔
        for (int i = 1; i <= N - 1; i++) Get_Laplace_Pyramid(i);
        //倒数第二步计算得到残差图像
        for (int i = 1; i <= N; i++) Get_Laplace_E(i);
        //最后我们打印出残差图像出来
        Print_Png();
    }


    public void Init_RAM_W()
    {
        //开辟不规则三维数组的空间。
        for (int z = N; z >= 1; z--)
        {
            int n = (int)Mathf.Pow(2, z);
            //print(n);
            heightmaps[z] = new float[n + 2][];
            Nexheightmaps[z] = new float[n + 2][];
            E[z] = new float[n + 2][];
            for (int j = 0; j < n; j++)
            {
                heightmaps[z][j] = new float[n + 2];
                Nexheightmaps[z][j] = new float[n + 2];
                E[z][j] = new float[n + 2];
            }
        }
        //得到窗口函数
        W[0, 0] = 1; W[0, 1] = 4; W[0, 2] = 6; W[0, 3] = 4; W[0, 4] = 1;
        W[1, 0] = 4; W[1, 1] = 16; W[1, 2] = 24; W[1, 3] = 16; W[1, 4] = 4;
        W[2, 0] = 6; W[2, 1] = 24; W[2, 2] = 36; W[2, 3] = 24; W[2, 4] = 6;
        W[3, 0] = 4; W[3, 1] = 16; W[3, 2] = 24; W[3, 3] = 16; W[3, 4] = 4;
        W[4, 0] = 1; W[4, 1] = 4; W[4, 2] = 6; W[4, 3] = 4; W[4, 4] = 1;
    }
    public void Get_Init_HeightMaps(int NowLevel)
    {

        string PngName = "GussOut";
        PngName += NowLevel.ToString();
        PngName += ".png";
        Texture2D texture = ((Texture2D)Resources.Load(PngName));

        int tempLen = (int)Mathf.Pow(2, NowLevel);
        for (int i = 0; i < tempLen; i++)
        {
            for (int j = 0; j < tempLen; j++)
            {
                float Bx = (float)(1.0f / (float)tempLen);
                float Bz = (float)(1.0f / (float)tempLen);
                float tempi = i * Bx;
                float tempj = j * Bz;

                heightmaps[NowLevel][i][j] = GetCellHeight(texture, new Vector2(tempi, tempj));
            }
        }
    }
    public float GetCellHeight(Texture2D map, Vector2 uv)
    {
        // 如果贴图不为空
        if (map != null)
        {
            Color c = GetCellColor(map, uv);
            float gray = c.grayscale;
            float h = 1f * gray;
            return h;
        }
        else return 0;
    }
    public Color GetCellColor(Texture2D map, Vector2 uv)
    {
        Color color = map.GetPixel(Mathf.FloorToInt(map.width * uv.x), Mathf.FloorToInt(map.height * uv.y));
        return color;
    }
    public void Get_Laplace_Pyramid(int NowLevel)
    {
        int nextempLen = (int)Mathf.Pow(2, NowLevel + 1);
        for (int i = 0; i < nextempLen; i++)
        {
            for (int j = 0; j < nextempLen; j++)
            {
                float sum = 0;
                float beilv = 256;
                for (int m = -2; m <= 2; m++)
                {
                    for (int n = -2; n <= 2; n++)
                    {
                        if (i + m >= 0 && j + n >= 0)
                        {
                            if ((i + m) % 2 == 0 && (j + n) % 2 == 0)
                            {
                                int ni = (i + m) / 2;
                                int nj = (j + n) / 2;
                                if (ni >= 0 && ni < nextempLen / 2 && nj >= 0 && nj < nextempLen / 2)
                                {
                                    sum += 4.0f * W[m + 2, n + 2] * heightmaps[NowLevel][ni][nj];
                                }
                            }
                        }
                    }
                }
                sum = sum / beilv;
                Nexheightmaps[NowLevel + 1][i][j] = sum;
            }
        }
    }
    public void Get_Laplace_E(int NowLevel)
    {
        if (NowLevel == 1)
        {
            int tempLen = (int)Mathf.Pow(2, NowLevel);
            for (int i = 0; i < tempLen; i++)
            {
                for (int j = 0; j < tempLen; j++)
                {
                    E[NowLevel][i][j] = heightmaps[NowLevel][i][j];
                }
            }
        }
        else
        {
            int tempLen = (int)Mathf.Pow(2, NowLevel);
            for (int i = 0; i < tempLen; i++)
            {
                for (int j = 0; j < tempLen; j++)
                {
                    E[NowLevel][i][j] = heightmaps[NowLevel][i][j] - Nexheightmaps[NowLevel][i][j];
                }
            }
        }
    }
    public void Print_Png()
    {
        for (int z = N; z >= 1; z--)
        {
            int n = (int)Mathf.Pow(2, z);
            Texture2D texture = new Texture2D(n, n);
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    E[z][i][j] = E[z][i][j] + 1;
                    E[z][i][j] = (float)(E[z][i][j] / 2.0f);
                    Color color = new Color(E[z][i][j], E[z][i][j], E[z][i][j], 1.0f);
                    texture.SetPixel(i, j, color);
                }
            }
            texture.Apply();
            SaveThisTextureToPng(texture, z);
        }
    }
    public void SaveThisTextureToPng(Texture2D texture, int NowLevel)
    {
        string Name = "EOut";
        Name += NowLevel.ToString();
        Name += ".png";
        print(Name);
        SaveTextureToPng(texture, Application.dataPath + "/E pyramid", Name);
    }
    public void SaveTextureToPng(Texture2D inputTex, string contents, string pngName)
    {
        RenderTexture temp = RenderTexture.GetTemporary(inputTex.width, inputTex.height, 0, RenderTextureFormat.ARGB32);
        Graphics.Blit(inputTex, temp);
        SaveRenderTextureToPng(temp, contents, pngName);
    }
    public void SaveRenderTextureToPng(RenderTexture rt, string contents, string pngName)
    {
        RenderTexture prev = RenderTexture.active;
        RenderTexture.active = rt;
        Texture2D png = new Texture2D(rt.width, rt.height, TextureFormat.ARGB32, false);
        png.ReadPixels(new Rect(0, 0, rt.width, rt.height), 0, 0);
        byte[] bytes = png.EncodeToPNG();
        if (!Directory.Exists(contents))
            Directory.CreateDirectory(contents);
        FileStream file = File.Open(contents + "/" + pngName + ".png", FileMode.Create);
        BinaryWriter writer = new BinaryWriter(file);
        writer.Write(bytes);
        file.Close();
        Texture2D.DestroyImmediate(png);
        png = null;
        RenderTexture.active = prev;
    }
}
```

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
//我们直接实现出来整个从最小图像到最大图像的重建。
public class ReBuild_ : MonoBehaviour
{

    public int N;
    public float[][][] heightmaps = new float[15][][];
    public float[][][] E = new float[15][][];
    private float[,] W = new float[5, 5];
    public void Start()
    {
        //首先我们开辟空间
        Init_RAM();
        //然后我们读取全部的残差图出来
        for (int i = 1; i <= N; i++) Get_E_HeightMaps(i);
        //接下来我们要开始按照顺序得到重构图
        for (int i = 1; i <= N; i++) Get_Rebuild_HeightMaps(i);
        //输出重构图
        Print_Png();
    }

    public void Init_RAM()
    {
        //开辟不规则三维数组的空间。
        for (int z = N; z >= 1; z--)
        {
            int n = (int)Mathf.Pow(2, z);
            //print(n);
            heightmaps[z] = new float[n + 2][];
            E[z] = new float[n + 2][];
            for (int j = 0; j < n; j++)
            {
                heightmaps[z][j] = new float[n + 2];
                E[z][j] = new float[n + 2];
            }
        }
        //得到窗口函数
        W[0, 0] = 1; W[0, 1] = 4; W[0, 2] = 6; W[0, 3] = 4; W[0, 4] = 1;
        W[1, 0] = 4; W[1, 1] = 16; W[1, 2] = 24; W[1, 3] = 16; W[1, 4] = 4;
        W[2, 0] = 6; W[2, 1] = 24; W[2, 2] = 36; W[2, 3] = 24; W[2, 4] = 6;
        W[3, 0] = 4; W[3, 1] = 16; W[3, 2] = 24; W[3, 3] = 16; W[3, 4] = 4;
        W[4, 0] = 1; W[4, 1] = 4; W[4, 2] = 6; W[4, 3] = 4; W[4, 4] = 1;
    }
    public void Get_E_HeightMaps(int NowLevel)
    {
        Texture2D texture = GetEtexture(NowLevel);
        int tempLen = (int)Mathf.Pow(2, NowLevel);
        for (int i = 0; i < tempLen; i++)
        {
            for (int j = 0; j < tempLen; j++)
            {
                float Bx = (float)(1.0f / (float)tempLen);
                float Bz = (float)(1.0f / (float)tempLen);
                float tempi = i * Bx;
                float tempj = j * Bz;

                E[NowLevel][i][j] = GetCellHeight(texture, new Vector2(tempi, tempj));
                E[NowLevel][i][j] = E[NowLevel][i][j] * 2;
                E[NowLevel][i][j] = E[NowLevel][i][j] - 1;
            }
        }
    }
    public float GetCellHeight(Texture2D map, Vector2 uv)
    {
        // 如果贴图不为空
        if (map != null)
        {
            Color c = GetCellColor(map, uv);
            float gray = c.grayscale;
            float h = 1f * gray;
            return h;
        }
        else return 0;
    }
    public Color GetCellColor(Texture2D map, Vector2 uv)
    {
        Color color = map.GetPixel(Mathf.FloorToInt(map.width * uv.x), Mathf.FloorToInt(map.height * uv.y));
        return color;
    }
    public Texture2D GetEtexture(int NowLevel)
    {
        double startTime = (double)Time.time;
        //创建文件读取流
        string PathName = Application.dataPath + "/E pyramid";
        PathName += "/EOut";
        PathName += NowLevel.ToString();
        PathName += ".png.png";
        //print(PathName);
        FileStream fileStream = new FileStream(PathName, FileMode.Open, FileAccess.Read);
        fileStream.Seek(0, SeekOrigin.Begin);
        //创建文件长度缓冲区
        byte[] bytes = new byte[fileStream.Length];
        //读取文件
        fileStream.Read(bytes, 0, (int)fileStream.Length);
        //释放文件读取流
        fileStream.Close();
        fileStream.Dispose();
        fileStream = null;
        int Val = (int)Mathf.Pow(2, NowLevel);
        Texture2D texture = new Texture2D(Val, Val);
        texture.LoadImage(bytes);
        return texture;
    }
    public void Get_Rebuild_HeightMaps(int NowLevel)
    {
        if (NowLevel == 1)
        {
            //如果当前是最小的那张图，那么我们直接定义结果就是它残差图本身。
            int tempLen = (int)Mathf.Pow(2, NowLevel);
            for (int i = 0; i < tempLen; i++)
            {
                for (int j = 0; j < tempLen; j++)
                {
                    heightmaps[NowLevel][i][j] = E[NowLevel][i][j];
                }
            }
        }
        else
        {
            //如果不是最小那张图，那么用上一级的结果图，来加上残差得到当前层结果图。
            int tempLen = (int)Mathf.Pow(2, NowLevel);
            for (int i = 0; i < tempLen; i++)
            {
                for (int j = 0; j < tempLen; j++)
                {
                    float sum = 0;
                    float beilv = 256;
                    for (int m = -2; m <= 2; m++)
                    {
                        for (int n = -2; n <= 2; n++)
                        {
                            if (i + m >= 0 && j + n >= 0)
                            {
                                if ((i + m) % 2 == 0 && (j + n) % 2 == 0)
                                {
                                    int ni = (i + m) / 2;
                                    int nj = (j + n) / 2;
                                    if (ni >= 0 && ni < tempLen / 2 && nj >= 0 && nj < tempLen / 2)
                                    {
                                        sum += 4.0f * W[m + 2, n + 2] * heightmaps[NowLevel - 1][ni][nj];
                                    }
                                }
                            }
                        }
                    }
                    sum = sum / beilv;
                    heightmaps[NowLevel][i][j] = sum;
                }
            }
            for (int i = 0; i < tempLen; i++)
            {
                for (int j = 0; j < tempLen; j++)
                {
                    heightmaps[NowLevel][i][j] = heightmaps[NowLevel][i][j] + E[NowLevel][i][j];
                }
            }
        }
    }
    public void Print_Png()
    {
        for (int z = N; z >= 1; z--)
        {
            int n = (int)Mathf.Pow(2, z);
            Texture2D texture = new Texture2D(n, n);
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    Color color = new Color(heightmaps[z][i][j], heightmaps[z][i][j], heightmaps[z][i][j], 1.0f);
                    texture.SetPixel(i, j, color);
                }
            }
            texture.Apply();
            SaveThisTextureToPng(texture, z);
        }
    }
    public void SaveThisTextureToPng(Texture2D texture, int NowLevel)
    {
        string Name = "ReBuildOut";
        Name += NowLevel.ToString();
        Name += ".png";
        print(Name);
        SaveTextureToPng(texture, Application.dataPath + "/ReBuild pyramid", Name);
    }
    public void SaveTextureToPng(Texture2D inputTex, string contents, string pngName)
    {
        RenderTexture temp = RenderTexture.GetTemporary(inputTex.width, inputTex.height, 0, RenderTextureFormat.ARGB32);
        Graphics.Blit(inputTex, temp);
        SaveRenderTextureToPng(temp, contents, pngName);
    }
    public void SaveRenderTextureToPng(RenderTexture rt, string contents, string pngName)
    {
        RenderTexture prev = RenderTexture.active;
        RenderTexture.active = rt;
        Texture2D png = new Texture2D(rt.width, rt.height, TextureFormat.ARGB32, false);
        png.ReadPixels(new Rect(0, 0, rt.width, rt.height), 0, 0);
        byte[] bytes = png.EncodeToPNG();
        if (!Directory.Exists(contents))
            Directory.CreateDirectory(contents);
        FileStream file = File.Open(contents + "/" + pngName + ".png", FileMode.Create);
        BinaryWriter writer = new BinaryWriter(file);
        writer.Write(bytes);
        file.Close();
        Texture2D.DestroyImmediate(png);
        png = null;
        RenderTexture.active = prev;
    }
}
/*
我们有最初的高度图，首先我们计算出高度图对应的二维网格。
然后我们在对二维网格进行计算，输出一张新的Texture2D结果图。
*/

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
public class BuildRiverBed : MonoBehaviour
{

    public Texture2D heightmap;

    public Texture2D rivermap;
    //河道路径点
    public List<Vector3> m_vp3River = new List<Vector3>();
    //河道深度
    public float RiverDepth;
    //河道坡度
    public float Slope_Val;
    //河道在处理过程中每次下降的高度
    private const float Height_Del = 0.005f;
    //河流宽度
    public int AAwidth;

    private int width;
    private int length;
    private int realWidth;
    private int realLength;
    private int realHeight;
    private int heightResolution;

    private float[,] heightmaps;


    public void AddPoint(Vector3 PP)
    {
        m_vp3River.Add(PP);
    }
    public void Build_This_RiverBed()
    {

        //首先得到地形的初始信息值。
        GetInitVal();
        //然后我们要得到地形的高度图。
        GetInitHeightmaps();
        //对河道图进行读取信息。
        
        GetRiverPoint();

        
        //然后对路径点的高度进行减少。
        FirstUpdateRiverBed();

        //接下来对路径点周围的高度进行减少，以形成凹槽河道。
        SecondUpdateRiverBed();


        //最后输出结果的高度图。

        Print_This_Result();
        
        
    }
    public void ClearPoint()
    {
        m_vp3River.Clear();
    }
    public void GetRiverPoint()
    {
        int cnt = 0;
        if(rivermap!=null)
        {
            for(int i = 0; i < rivermap.width; i++)
            {
                for(int j = 0; j < rivermap.height; j++)
                {
                    cnt++;
                    Color color = rivermap.GetPixel(i, j);
                    if (color.r == 1f && color.g == 1f && color.b == 1f && color.a == 1f) continue;
                    else
                    {
                        Vector3 Pp = new Vector3();
                        Pp.x = (float)((float)i*(float)rivermap.width / (float)width);
                        Pp.z = (float)((float)j*(float)rivermap.height / (float)length);
                        Pp.y = heightmaps[(int)Pp.x, (int)Pp.z];
                        print(getX(Pp.x)+" "+ Pp.y+" "+ getZ(Pp.z));
                        m_vp3River.Add(new Vector3(getX(Pp.x), Pp.y, getZ(Pp.z)));
                    }
                }
            }
        }
        print(cnt);
        print(m_vp3River.Count);
        print(rivermap.width + "  " + rivermap.height);
    }

    /********************************************************************/
    //输出结果
    public void Print_This_Result()
    {
        Texture2D texture = new Texture2D(width, length);
        for (int i = 0; i < width; i++)
        {
            for (int j = 0; j < length; j++)
            {
                float Val = heightmaps[i, j] / realHeight;
                //print(Val);
                Color color = new Color(Val, Val, Val, 1.0f);
                texture.SetPixel(i, j, color);
            }
        }
        texture.Apply();
        SaveThisTextureToPng(texture);
    }
    public void SaveThisTextureToPng(Texture2D texture)
    {
        string Name = "NewHeightMap.png";
        print(Name);
        SaveTextureToPng(texture, Application.dataPath + "/temp", Name);
    }
    public void SaveTextureToPng(Texture2D inputTex, string contents, string pngName)
    {
        RenderTexture temp = RenderTexture.GetTemporary(inputTex.width, inputTex.height, 0, RenderTextureFormat.ARGB32);
        Graphics.Blit(inputTex, temp);
        SaveRenderTextureToPng(temp, contents, pngName);
    }
    public void SaveRenderTextureToPng(RenderTexture rt, string contents, string pngName)
    {
        RenderTexture prev = RenderTexture.active;
        RenderTexture.active = rt;
        Texture2D png = new Texture2D(rt.width, rt.height, TextureFormat.ARGB32, false);
        png.ReadPixels(new Rect(0, 0, rt.width, rt.height), 0, 0);
        byte[] bytes = png.EncodeToPNG();
        if (!Directory.Exists(contents))
            Directory.CreateDirectory(contents);
        FileStream file = File.Open(contents + "/" + pngName + ".png", FileMode.Create);
        BinaryWriter writer = new BinaryWriter(file);
        writer.Write(bytes);
        file.Close();
        Texture2D.DestroyImmediate(png);
        png = null;
        RenderTexture.active = prev;
    }
    /********************************************************************/




    /********************************************************************/
    //改变河道形状
    public void FirstUpdateRiverBed()
    {
        for (int i = 0; i < m_vp3River.Count; i++)
        {
            int tx = GetiX(m_vp3River[i]);
            int tz = GetiZ(m_vp3River[i]);
            float ty = m_vp3River[i].y;
            ty -= RiverDepth;
            heightmaps[tx, tz] = ty;
        }
    }
    public void SecondUpdateRiverBed()
    {
        for (int z = 0; z < m_vp3River.Count; z++)
        {
            //print("Yes");
            int tx = GetiX(m_vp3River[z]);
            int tz = GetiZ(m_vp3River[z]);
            int flag;
            int ccnt = 0;
            int AAlength = AAwidth;
            while (true)
            {
                ccnt++;
                flag = 0;
                for (int iX = tx - AAwidth; iX <= tx + AAwidth; iX++)
                {
                    for (int iZ = tz - AAlength; iZ <= tz + AAlength; iZ++)
                    {
                        if (iX >= 0 && iX < width && iZ >= 0 && iZ < length)
                        {
                            if (iX == tx && iZ == tz) continue;
                            float Fslope;
                            //两点之间坡度的计算公式：(两点之间高度差)/(两点之间水平距离)
                            //计算两点之间坡度，如果坡度大于预设坡度，那么我们修改这个点的高度。
                            float x1 = (float)((float)(iX) * (float)realWidth) / (float)(heightResolution);
                            float x2 = (float)((float)(tx) * (float)realWidth) / (float)(heightResolution);
                            float z1 = (float)((float)(iZ) * (float)realLength) / (float)(heightResolution);
                            float z2 = (float)((float)(tz) * (float)realLength) / (float)(heightResolution);

                            float Dis = (float)(System.Math.Sqrt((x1 - x2) * (x1 - x2) + (z1 - z2) * (z1 - z2)));
                            Fslope = (heightmaps[iX, iZ] - heightmaps[tx, tz]) / Dis;
                            if (Fslope > Slope_Val)
                            {
                                if (heightmaps[iX, iZ] >= Height_Del * realHeight)
                                {
                                    heightmaps[iX, iZ] -= Height_Del * realHeight;
                                    flag = 1;
                                }
                            }
                        }
                    }
                }
                if (flag == 0 || ccnt >= 1000000) break;
            }
            //print(ccnt);
        }
    }


    /********************************************************************/

    /********************************************************************/
    //初始化一些高度图的信息
    public void GetInitVal()
    {
        width = GameObject.Find("Huge Terrain").GetComponent<LowerTerrain>().N;
        length = GameObject.Find("Huge Terrain").GetComponent<LowerTerrain>().N;
        realHeight = GameObject.Find("Huge Terrain").GetComponent<LowerTerrain>().H;
        width--;
        length--;
        // print(width + "  " + length);
        realWidth = width;
        realLength = length;
        heightResolution = width;
    }
    //得到初始高度图（真实地形高度，并非映射的0-1值，是0-H值）
    public void GetInitHeightmaps()
    {
        heightmaps = new float[width + 2, length + 2];
        for (int i = 0; i < width; i++)
        {
            for (int j = 0; j < length; j++)
            {
                float Bx = (float)(1.0f / (float)width);
                float Bz = (float)(1.0f / (float)length);
                float tempi = i * Bx;
                float tempj = j * Bz;
                heightmaps[i, j] = GetCellHeight(heightmap, new Vector2(tempi, tempj));
            }
        }
    }
    public float GetCellHeight(Texture2D map, Vector2 uv)
    {
        // 如果贴图不为空
        if (map != null)
        {
            Color c = GetCellColor(map, uv);
            float gray = c.grayscale;
            float h = realHeight * gray;
            return h;
        }
        else return 0;
    }
    public Color GetCellColor(Texture2D map, Vector2 uv)
    {
        Color color = map.GetPixel(Mathf.FloorToInt(map.width * uv.x), Mathf.FloorToInt(map.height * uv.y));
        return color;
    }
    /********************************************************************/




    /********************************************************************/
    //将地形图的点换算为代码中的（x，y，z）；
    int GetiX(Vector3 P)
    {
        float Bilv1 = (float)(heightResolution) / (float)(realWidth);
        int tx = (int)(P.x * Bilv1);
        return tx;
    }
    int GetiZ(Vector3 P)
    {
        float Bilv2 = (float)(heightResolution) / (float)(realLength);
        int tz = (int)(P.z * Bilv2);
        return tz;
    }
    float GetiY(Vector3 P)
    {
        float Bilv3 = 1.0f / (float)(realHeight);
        float ty = P.y * Bilv3;
        return ty;
    }
    float getX(float x)
    {
        return (float)(x) * (float)(realWidth) / (float)(heightResolution);
    }
    float getY(float y)
    {
        return (float)(y) * (float)(realHeight);
    }
    float getZ(float z)
    {
        return (float)(z) * (float)(realLength) / (float)(heightResolution);
    }
    /********************************************************************/

}
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
[CustomEditor(typeof(BuildRiverBed)),CanEditMultipleObjects]
public class BuildRiverBedEditor : Editor {

    Texture2D logo;
    BuildRiverBed bed;
    Vector2 scrollPos;
    bool showPositions = false;

    [MenuItem("GameObject/3D Object/Build River Bed")]
    static public void Build_River_Bed()
    {
        GameObject gameobject = new GameObject("River_Bed");
        gameobject.AddComponent<BuildRiverBed>();
        Selection.activeGameObject = gameobject;
    }
    public override void OnInspectorGUI()
    {
        bed = (BuildRiverBed)target;
        logo = (Texture2D)Resources.Load("");
        scrollPos = EditorGUILayout.BeginScrollView(scrollPos);
        {
            GUIContent btnTxt = new GUIContent(logo);
            var rt = GUILayoutUtility.GetRect(btnTxt, GUI.skin.label, GUILayout.ExpandWidth(false));

            //设置一个编辑模块
            rt.center = new Vector2(EditorGUIUtility.currentViewWidth / 2, rt.center.y);
            GUI.Button(rt, btnTxt, GUI.skin.label);
            EditorGUI.indentLevel++;
            bed.RiverDepth = EditorGUILayout.Slider("河流深度", bed.RiverDepth, 0f, 100f);
            bed.Slope_Val = EditorGUILayout.Slider("河流坡度", bed.Slope_Val, 0f, 50f);
            bed.AAwidth = EditorGUILayout.IntSlider("处理点周围宽度（河流宽度）", bed.AAwidth, 0, 150);
            bed.heightmap = (Texture2D)EditorGUILayout.ObjectField("高度图", bed.heightmap,typeof(Texture2D));
            bed.rivermap = (Texture2D)EditorGUILayout.ObjectField("河床图", bed.rivermap, typeof(Texture2D));
            EditorGUILayout.BeginHorizontal();
            showPositions = EditorGUILayout.Foldout(showPositions, "Points");
            EditorGUILayout.EndHorizontal();
            if(showPositions)
            {
                for(int i = 0; i < bed.m_vp3River.Count; i++)
                {
                    EditorGUILayout.BeginHorizontal();
                    bed.m_vp3River[i] = EditorGUILayout.Vector3Field("", bed.m_vp3River[i]);
                    if (GUILayout.Button(new GUIContent("R", "Remove this Point")))
                    {
                        Undo.RecordObject(bed, "Remove point");
                    }
                    EditorGUILayout.EndHorizontal();
                }
            }
            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button(new GUIContent("Build RiverBed", "Build this RiverBed")))
            {
                Undo.RecordObject(bed, "BuildRiverBed");
                bed.Build_This_RiverBed();
            }
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button(new GUIContent("Clear Point", "Clear River Point")))
            {
                Undo.RecordObject(bed, "Clear Point");
                bed.ClearPoint();
            }
            EditorGUILayout.EndHorizontal();
        }
        EditorGUILayout.EndScrollView();
    }
    protected virtual void OnSceneGUI()
    {
        int controlID = GUIUtility.GetControlID(FocusType.Passive);
        /*
        if (bed != null)
        {
            for(int i = 0; i < bed.m_vp3River.Count; i++)
            {
                EditorGUI.BeginChangeCheck();
                Handles.color = new Color32(147, 225, 58, 255);
                Vector3 handlePos = (Vector3)bed.m_vp3River[i] + bed.transform.position;
                if (Tools.current == Tool.Move)
                {
                    float size = 0.6f;

                    Handles.color = Handles.xAxisColor;
                    Vector3 pos = Handles.Slider((Vector3)bed.m_vp3River[i] + bed.transform.position, Vector3.right, HandleUtility.GetHandleSize(handlePos) * size, Handles.ArrowHandleCap, 0.01f) - bed.transform.position;

                    pos = Handles.Slider((Vector3)pos + bed.transform.position, Vector3.up, HandleUtility.GetHandleSize(handlePos) * size, Handles.ArrowHandleCap, 0.01f) - bed.transform.position;

                    pos = Handles.Slider((Vector3)pos + bed.transform.position, Vector3.forward, HandleUtility.GetHandleSize(handlePos) * size, Handles.ArrowHandleCap, 0.01f) - bed.transform.position;

                    bed.m_vp3River[i] = pos;
                }
                if (Tools.current == Tool.Scale)
                {
                    Handles.color = Color.red;
                    Vector3 pos = bed.m_vp3River[i];
                    bed.m_vp3River[i] = pos;
                }
            }
        }
        */
        //监听鼠标和crtl键是否同时按下，如果是，得到shaded中的那个点、
        if (Event.current.type == EventType.MouseDown && Event.current.button == 0 && Event.current.control)
        {
            Vector3 screenPosition = Event.current.mousePosition;
            screenPosition.y = Camera.current.pixelHeight - screenPosition.y;
            Ray ray = Camera.current.ScreenPointToRay(screenPosition);
            RaycastHit hit;

            if (Physics.Raycast(ray, out hit))
            {
                Undo.RecordObject(bed, "Add point");

                Vector4 position = hit.point - bed.transform.position;
                position.w = 1;
                bed.AddPoint(position);

                GUIUtility.hotControl = controlID;
                Event.current.Use();
                HandleUtility.Repaint();
            }
        }
        if (Event.current.type == EventType.MouseUp && Event.current.button == 0 && Event.current.control)
        {
            GUIUtility.hotControl = 0;
        }
    }


}
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
//我们的二维网格图左上角第一个位子为（0，0），编码为0；
[RequireComponent(typeof(MeshFilter))]
[RequireComponent(typeof(MeshRenderer))]
[RequireComponent(typeof(MeshCollider))]
class TreeNode
{
    //Id换算到二维网格图中的时候的换算公式：
    //x=Id/N;
    //y=Id-(Id/N)*N;
    public int Id;

    //当前点控制的层级
    //级别换算到真正地形上的大小公式：
    //Mianji=(N*N)/(Pow(4,Level));

    public int Level;
    //左上角
    public TreeNode Child1;
    //右上角
    public TreeNode Child2;
    //左下角
    public TreeNode Child3;
    //右上角
    public TreeNode Child4;
    //构造函数
    public TreeNode(int num, TreeNode a, TreeNode b, TreeNode c, TreeNode d)
    {
        Id = num;

        Child1 = a;
        Child2 = b;
        Child3 = c;
        Child4 = d;
    }
    //构造函数
    public TreeNode(int num)
    {
        Id = num;

        Child1 = null;
        Child2 = null;
        Child3 = null;
        Child4 = null;
    }
}
//我们首先建立一个纯平坦地形，根据摄像头高度之类的相关内容，搞出来一个地形先看着。
public class LowerTerrain : MonoBehaviour
{
    //8193 12 0.12
    //1025 9 5 存在断层
    //129 6 5


    //从灰度图中提取一个地形
    public Texture2D heightmaps;

    public Material tempmaterial;
    private float tim = 0;
    public float C = 0.02f;

    //长宽
    public int N = 1025;
    //高
    public int H = 150;
    public int LOD = 9;
    private bool[,] IsOpen = new bool[15000, 15000];
    TreeNode root;

    // Use this for initialization
    public void Start()
    {
        BuildBaseTerrain();
        BuildHugeTerrain();
    }
    public void BuildBaseTerrain()
    {
        for (int i = 0; i < N; i++)
        {
            for (int j = 0; j < N; j++)
            {
                IsOpen[i, j] = false;
            }
        }
        int All = (N) * (N);
        GameObject camera = GameObject.Find("Main Camera");
        //得到摄像机镜头的位子。
        Vector3 Pos = camera.transform.position;
        //print(Pos.x + " " + Pos.y + " " + Pos.z);
        //然后Bfs得到这颗树。
        //同时能够得到IsOpen的情况

        int need = 0;
        Queue<TreeNode> S = new Queue<TreeNode>();
        S.Clear();
        TreeNode temp = new TreeNode(All / 2);
        temp.Level = 0;
        S.Enqueue(temp);
        root = temp;
        while (S.Count > 0)
        {
            TreeNode Now = S.Dequeue();

            int nx = Now.Id / N;
            int ny = Now.Id - (int)(Now.Id / N) * N;
            float Bx = (float)(1.0f / (float)N);
            float Bz = (float)(1.0f / (float)N);
            float L = GetDistance(Pos, new Vector3(Now.Id / N, GetCellHeight(heightmaps, new Vector2(nx * Bx, ny * Bz)), (float)(Now.Id - (int)(Now.Id / N) * N)));
            float D = (float)N * N / Mathf.Pow(4, Now.Level);

            float c = L / D;
            //print(L +  "  " + D);
            if (c < C && Now.Level + 1 <= LOD)
            {

                int cx = (int)Mathf.Pow(2, LOD - Now.Level - 1);
                int cy = (int)Mathf.Pow(2, LOD - Now.Level - 1);
                TreeNode C1 = new TreeNode(N * (nx - cx) + (ny - cy));
                TreeNode C2 = new TreeNode(N * (nx - cx) + (ny + cy));
                TreeNode C3 = new TreeNode(N * (nx + cx) + (ny - cy));
                TreeNode C4 = new TreeNode(N * (nx + cx) + (ny + cy));
                C1.Level = Now.Level + 1;
                C2.Level = Now.Level + 1;
                C3.Level = Now.Level + 1;
                C4.Level = Now.Level + 1;
                Now.Child1 = C1;
                Now.Child2 = C2;
                Now.Child3 = C3;
                Now.Child4 = C4;
                //print("继续分裂:" + nx + " " + ny);
                IsOpen[nx, ny] = true;
                S.Enqueue(C1);
                S.Enqueue(C2);
                S.Enqueue(C3);
                S.Enqueue(C4);
            }
            else
            {
                IsOpen[nx, ny] = false;
            }
        }
    }
    public void BuildHugeTerrain()
    {
        int cnt = 0;
        int cnt1 = 0;
        int cnt2 = 0;
        List<Vector3> vp3 = new List<Vector3>();
        List<Vector2> UV = new List<Vector2>();
        List<int> array = new List<int>();
        Queue<TreeNode> S = new Queue<TreeNode>();
        S.Enqueue(root);
        int Ans = 0;
        while (S.Count > 0)
        {
            Ans = Mathf.Max(Ans, S.Count);
            TreeNode Now = S.Dequeue();
            int nx = Now.Id / N;
            int ny = Now.Id - (int)(Now.Id / N) * N;
            if (Now.Child1 != null && Now.Child2 != null && Now.Child3 != null && Now.Child4 != null&&IsOpen[nx,ny]==true)
            {
                TreeNode c1 = Now.Child1;
                TreeNode c2 = Now.Child2;
                TreeNode c3 = Now.Child3;
                TreeNode c4 = Now.Child4;
                S.Enqueue(c1);
                S.Enqueue(c2);
                S.Enqueue(c3);
                S.Enqueue(c4);
            }
            else
            {
                //我们是根据灰度图的高度图来计算点，需要提前做好UV点坐标，才能够得到每个点的真正高度
                //这个点值得注意一下。、
                int cx = (int)Mathf.Pow(2, LOD - Now.Level);
                int cy = (int)Mathf.Pow(2, LOD - Now.Level);
                Vector3 one = new Vector3(nx - cx, 0, ny - cy);
                Vector3 two = new Vector3(nx - cx, 0, ny + cy);
                Vector3 three = new Vector3(nx + cx, 0, ny - cy);
                Vector3 fore = new Vector3(nx + cx, 0, ny + cy);
                float Bx = (float)(1.0f / (float)N);
                float Bz = (float)(1.0f / (float)N);
                UV.Add(new Vector2(one.x * Bx, one.z * Bz));
                UV.Add(new Vector2(two.x * Bx, two.z * Bz));
                UV.Add(new Vector2(three.x * Bx, three.z * Bz));
                UV.Add(new Vector2(fore.x * Bx, fore.z * Bz));
                one.y = GetCellHeight(heightmaps, new Vector2(one.x * Bx, one.z * Bz));
                two.y = GetCellHeight(heightmaps, new Vector2(two.x * Bx, two.z * Bz));
                three.y = GetCellHeight(heightmaps, new Vector2(three.x * Bx, three.z * Bz));
                fore.y = GetCellHeight(heightmaps, new Vector2(fore.x * Bx, fore.z * Bz));

                int top = (int)(two.z - one.z);
                int down = (int)(fore.z - three.z);
                int left = (int)(three.x - one.x);
                int right = (int)(fore.x - two.x);
                if (top == down && down == left && left == right)
                {

                }
                else print("Warning");
                vp3.Add(one);
                vp3.Add(two);
                vp3.Add(three);
                vp3.Add(fore);

                cnt += 4; cnt1 += 4;
                array.Add(cnt1 - 4);
                array.Add(cnt1 - 3);
                array.Add(cnt1 - 1);
                /*
                array.Add(cnt1 - 1);
                array.Add(cnt1 - 3);
                array.Add(cnt1 - 4);
                */
                array.Add(cnt1 - 4);
                array.Add(cnt1 - 1);
                array.Add(cnt1 - 2);
                /*
                array.Add(cnt1 - 2);
                array.Add(cnt1 - 1);
                array.Add(cnt1 - 4);
                */
                cnt2 += 6;
            }
        }
        //print(cnt + "   " + cnt1 + "    " + cnt2);
        Vector2[] uv = new Vector2[cnt];
        Vector3[] vpp = new Vector3[cnt1];
        int[] arrray = new int[cnt2];
        for (int i = 0; i < cnt; i++) uv[i] = UV[i];
        for (int i = 0; i < cnt1; i++) vpp[i] = vp3[i];
        for (int i = 0; i < cnt2; i++) arrray[i] = array[i];
        Mesh mesh = gameObject.GetComponent<MeshFilter>().mesh;
        mesh.Clear();
        mesh.vertices = vpp;
        mesh.uv = uv;
        mesh.triangles = arrray;
        //重置法线
        mesh.RecalculateNormals();
        //重置范围
        mesh.RecalculateBounds();
        gameObject.GetComponent<Renderer>().material = tempmaterial;
        gameObject.GetComponent<MeshCollider>().sharedMesh = mesh;
        print(cnt2);
        //print(Ans);
    }

    public float GetCellHeight(Texture2D map, Vector2 uv)
    {
        // 如果贴图不为空
        if (map != null)
        {
            Color c = GetCellColor(map, uv);
            float gray = c.grayscale;
            float h = H * gray;
            return h;
        }
        else return 0;
    }
    public Color GetCellColor(Texture2D map, Vector2 uv)
    {
        Color color = map.GetPixel(Mathf.FloorToInt(map.width * uv.x), Mathf.FloorToInt(map.height * uv.y));
        return color;
    }

    public float GetDistance(Vector3 A, Vector3 B)
    {
        float Dis;
        //print("A:" + A.x + " " + A.y + " " + A.z);
        //print("B:" + B.x + " " + B.y + " " + B.z);
        Dis = Mathf.Sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y) + (A.z - B.z) * (A.z - B.z));
        //print("Dis:"+Dis);
        return Dis;
    }
}
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;

[CustomEditor(typeof(LowerTerrain)),CanEditMultipleObjects]
public class LowerTerrainEditor : Editor {

    Texture2D logo;
    LowerTerrain terrain;
    Vector2 scrollPos;
    /*
    public Texture2D heightmaps;

    public Material tempmaterial;
     */

    [MenuItem("GameObject/3D Object/Huge Terrain")]
    static public void CreatTerrain()
    {
        GameObject gameobject = new GameObject("Huge Terrain");
        gameobject.AddComponent<LowerTerrain>();
        gameobject.AddComponent<MeshFilter>();
        gameobject.AddComponent<MeshCollider>();
        gameobject.AddComponent<MeshRenderer>();
        Selection.activeGameObject = gameobject;
    }
    public override void OnInspectorGUI()
    {
        terrain = (LowerTerrain)target;
        logo = (Texture2D)Resources.Load("NetEase");
        scrollPos = EditorGUILayout.BeginScrollView(scrollPos);
        {

            GUIContent btnTxt = new GUIContent(logo);
            var rt = GUILayoutUtility.GetRect(btnTxt, GUI.skin.label, GUILayout.ExpandWidth(false));

            //设置一个编辑模块
            rt.center = new Vector2(EditorGUIUtility.currentViewWidth / 2, rt.center.y);
            GUI.Button(rt, btnTxt, GUI.skin.label);
            EditorGUI.indentLevel++;
            EditorGUILayout.LabelField("----------在创建地形之前，注意要填写好地形相关信息");
            EditorGUILayout.LabelField("----------注意分层数要根据地形长宽来设定，不要太大");
            terrain.N = EditorGUILayout.IntField("地形长宽：", terrain.N);
            terrain.H = EditorGUILayout.IntField("地形高度：", terrain.H);
            terrain.LOD = EditorGUILayout.IntField("地形分层数：",terrain.LOD);
            terrain.C = EditorGUILayout.Slider("地形分辨率（值越大越精细）：", terrain.C, 0f, 100f);
            terrain.tempmaterial = (Material)EditorGUILayout.ObjectField("地形材质 ：", terrain.tempmaterial, typeof(Material));
            terrain.heightmaps = (Texture2D)EditorGUILayout.ObjectField("地形高度图：", terrain.heightmaps, typeof(Texture2D));
            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button(new GUIContent("Build Huge Terrain", "Build this Terrain")))
            {
                terrain.Start();
            }
            EditorGUILayout.EndHorizontal();
        }
        EditorGUILayout.EndScrollView();

    }

}

```

残差效果图展示(展示可见的后边的结果):

![](https://i.loli.net/2018/08/01/5b61946e1e975.png)
![](https://i.loli.net/2018/08/01/5b61946e288e0.png)
![](https://i.loli.net/2018/08/01/5b61946e3ae86.png)

重构图的效果图展示（重构图当前情况下一定和原图一样的）

![](https://i.loli.net/2018/08/01/5b61950fddacc.png)
![](https://i.loli.net/2018/08/01/5b61950fde1d5.png)
![](https://i.loli.net/2018/08/01/5b61950fe90a1.png)
