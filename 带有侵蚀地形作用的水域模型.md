设计思路：

1.首先右键创建出来一个水域模型的GameObject

2.然后我们设计几个基础功能：

①crtl+鼠标左键选取水域模型的源点。可选多个，但是不能不选。

②然后对于每个水域模型的源点，我们设计一个按钮，将其能够增加水量。

③再设计几个功能按键，分别为经过1单位时间后地形的变化，2单位时间后地形的变化，4单位时间后地形的变化，8单位时间后地形的变化，16、32单位时间后的变化。
以及自定义时间后，地形的变化。

3.核心计算的部分，我们之后再加上关于算法部分的优化能力。

一、我们首先设计只能点选一个点的水域模型的GameObject，第一版本记录：

```Shader
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Source : MonoBehaviour
{

    const double eps = 0.00001;

    Mesh mesh;
    //管道横截面积
    private float A = 1;
    //重力加速度
    private float g = 9.8f;
    //管道长度
    private float l = 1;

    //格点间距，按道理来讲不应该设定为1
    private float lx = 1;
    private float ly = 1;

    //增加的水量
    public float Add;

    //源点
    public Vector3 S;

    //高度图b
    private float[,] heightmaps;
    //水高图d
    private float[,] waterheightmaps = new float[600, 600];

    //流量图F 0上，1下，2左 3右 
    private float[,,] F = new float[600, 600, 5];


    //关于地形的信息
    TerrainData terraindata;
    int width;
    int length;
    int heightResolution;
    int realwidth;
    int reallength;
    int realheight;
    public void AddWater()
    {
        int tx = GetiX(S);
        int tz = GetiZ(S);
        waterheightmaps[tz, tx] += GetiY(Add);
        Add = 0;
    }
    public void GetHeightMaps()
    {
        print("Yes");
        Terrain terrain = Terrain.activeTerrain;
        terraindata = terrain.terrainData;
        print("Yes");
        width = terraindata.heightmapWidth;
        length = terraindata.heightmapHeight;
        heightmaps = terraindata.GetHeights(0, 0, width, length);
        heightResolution = terraindata.heightmapResolution;
        realwidth = (int)terraindata.size.x;
        realheight = (int)terraindata.size.y;
        reallength = (int)terraindata.size.z;

        print(realwidth + "    " + reallength + "     " + realheight + "     " + heightResolution);
        print(width + "       " + length);
    }
    public void GetPoint(Vector3 pos)
    {
        S = pos;
    }
    public void DoWork(int tim)
    {
        //流量图F 0上，1下，2左 3右 
        int[] fx = { -1, 1, 0, 0 };
        int[] fz = { 0, 0, -1, 1 };
        for (int z = 0; z < tim; z++)
        {
            float dertat = 1f;
            //第一次遍历整个图，来进行水通量的计算。
            for (int i = 0; i < width; i++)
            {
                for (int j = 0; j < length; j++)
                {
                    for (int k = 0; k < 4; k++) F[j, i, k] = 0;
                    if (getY(waterheightmaps[j, i]) <= eps) continue;
                    for (int k = 0; k < 4; k++)
                    {
                        int ni = i + fx[k];
                        int nj = i + fz[k];
                        if (ni >= 0 && ni < width && nj >= 0 && nj < length)
                        {
                            //计算流通量的过程用在真实环境中的地形高度来决定。
                            float CH = getY(heightmaps[j, i] + waterheightmaps[j, i]) - getY(heightmaps[nj, ni] + waterheightmaps[nj, ni]);
                            F[j, i, k] = Mathf.Max(0, F[j, i, k] + dertat * A * g * CH / l);
                        }
                    }
                    //计算流动系数
                    float K = Mathf.Min(1, waterheightmaps[j, i] * lx * ly / ((F[j, i, 0] + F[j, i, 1] + F[j, i, 2] + F[j, i, 3]) * dertat));
                    for (int k = 0; k < 4; k++)
                    {
                        F[j, i, k] = F[j, i, k] * K;
                    }
                }
            }
            //第二次遍历整个图，去计算每个点最终变化的情况
            for (int i = 0; i < width; i++)
            {
                for (int j = 0; j < length; j++)
                {
                    if (i - 1 >= 0 && i - 1 < width && i + 1 >= 0 && i + 1 < width && j - 1 >= 0 && j - 1 < length && j + 1 >= 0 && j + 1 < length)
                    {
                        float Tot = dertat * ((F[j - 1, i, 3] + F[j + 1, i, 2] + F[j, i - 1, 1] + F[j, i + 1, 0]) - (F[j, i, 0] + F[j, i, 1] + F[j, i, 2] + F[j, i, 3]));
                        waterheightmaps[j, i] = waterheightmaps[j, i] + GetiY(Tot / (lx * ly));
                    }
                }
            }
        }
        int tx = GetiX(S);
        int tz = GetiZ(S);
        float ty = GetiY(waterheightmaps[tz, tx]);
        print("S:" + ty);
        DrawMesh();
    }
    public void DrawMesh()
    {
        Vector2[] UV = new Vector2[10500000];
        Vector3[] vp3 = new Vector3[10500000];
        int[] array = new int[10500000];
        int cnt, cnt1, cnt2;
        cnt2 = cnt1 = cnt = 0;
        mesh = gameObject.GetComponent<MeshFilter>().mesh;
        mesh.Clear();
        for (int i = 0; i < width; i++)
        {
            for (int j = 0; j < length; j++)
            {
                if (getY(waterheightmaps[j, i]) <= eps) continue;
                Vector3 one = new Vector3(getX(i), getY(heightmaps[j, i]) + 0.05f, getZ(j));
                Vector3 two = new Vector3(getX(i), getY(heightmaps[j + 1, i]) + 0.05f, getZ(j + 1));
                Vector3 three = new Vector3(getX(i + 1), getY(heightmaps[j + 1, i + 1]) + 0.05f, getZ(j + 1));
                Vector3 fore = new Vector3(getX(i + 1), getY(heightmaps[j, i + 1]) + 0.05f, getZ(j));

                Vector3 five = new Vector3(getX(i), getY(heightmaps[j, i] + waterheightmaps[j,i]) + 0.05f, getZ(j));
                Vector3 six = new Vector3(getX(i), getY(heightmaps[j + 1, i]+waterheightmaps[j+1,i]) + 0.05f, getZ(j + 1));
                Vector3 seven = new Vector3(getX(i + 1), getY(heightmaps[j + 1, i + 1]+waterheightmaps[j+1,i+1]) + 0.05f, getZ(j + 1));
                Vector3 eight = new Vector3(getX(i + 1), getY(heightmaps[j, i + 1]+waterheightmaps[j,i+1]) + 0.05f, getZ(j));
                UV[cnt++] = new Vector2(one.x, one.z);
                UV[cnt++] = new Vector2(two.x, two.z);
                UV[cnt++] = new Vector2(three.x, three.z);
                UV[cnt++] = new Vector2(fore.x, fore.z);
                UV[cnt++] = new Vector2(five.x, five.z);
                UV[cnt++] = new Vector2(six.x, six.z);
                UV[cnt++] = new Vector2(seven.x, seven.z);
                UV[cnt++] = new Vector2(eight.x, eight.z);
                vp3[cnt1++] = one;
                vp3[cnt1++] = two;
                vp3[cnt1++] = three;
                vp3[cnt1++] = fore;
                vp3[cnt1++] = five;
                vp3[cnt1++] = six;
                vp3[cnt1++] = seven;
                vp3[cnt1++] = eight;

                //1 2 3
                array[cnt2++] = cnt - 8;
                array[cnt2++] = cnt - 7;
                array[cnt2++] = cnt - 6;

                array[cnt2++] = cnt - 6;
                array[cnt2++] = cnt - 7;
                array[cnt2++] = cnt - 8;
                //1 3 4
                array[cnt2++] = cnt - 8;
                array[cnt2++] = cnt - 6;
                array[cnt2++] = cnt - 5;

                array[cnt2++] = cnt - 5;
                array[cnt2++] = cnt - 6;
                array[cnt2++] = cnt - 8;
                //5 6 7
                array[cnt2++] = cnt - 4;
                array[cnt2++] = cnt - 3;
                array[cnt2++] = cnt - 2;

                array[cnt2++] = cnt - 2;
                array[cnt2++] = cnt - 3;
                array[cnt2++] = cnt - 4;
                //5 7 8
                array[cnt2++] = cnt - 4;
                array[cnt2++] = cnt - 2;
                array[cnt2++] = cnt - 1;

                array[cnt2++] = cnt - 1;
                array[cnt2++] = cnt - 2;
                array[cnt2++] = cnt - 4;

            }
        }
        print(cnt + "     " + cnt1 + "     " + cnt2);
        Vector2[] uv = new Vector2[cnt];
        Vector3[] vp = new Vector3[cnt1];
        int[] arrray = new int[cnt2];
        for (int i = 0; i < cnt; i++) uv[i] = UV[i];
        for (int i = 0; i < cnt1; i++) vp[i] = vp3[i];
        for (int i = 0; i < cnt2; i++) arrray[i] = array[i];
        mesh.uv = uv;
        mesh.vertices = vp;
        mesh.triangles = arrray;
    }

    int GetiX(Vector3 P)
    {
        float Bilv1 = (float)(heightResolution) / (float)(realwidth);
        int tx = (int)(P.x * Bilv1);
        return tx;
    }
    int GetiZ(Vector3 P)
    {
        float Bilv2 = (float)(heightResolution) / (float)(reallength);
        int tz = (int)(P.z * Bilv2);
        return tz;
    }
    float GetiY(float y)
    {
        float Bilv3 = 1.0f / (float)(realheight);
        float ty = y * Bilv3;
        return ty;
    }
    float getX(float x)
    {
        return (float)(x) * (float)(realwidth) / (float)(heightResolution);
    }
    float getY(float y)
    {
        return (float)(y) * (float)(realheight);
    }
    float getZ(float z)
    {
        return (float)(z) * (float)(reallength) / (float)(heightResolution);
    }
}


using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
[CustomEditor(typeof(Source)), CanEditMultipleObjects]
public class SourceEditor : Editor {

    private bool IsHave=false;
    Texture2D logo;
    Source source;
    Vector2 scrollPos;

    [MenuItem("GameObject/3D Object/Source")]
    static public void CreatSource()
    {
        GameObject gameobject = new GameObject("Source");
        gameobject.AddComponent<MeshFilter>();
        gameobject.AddComponent<MeshRenderer>();
        gameobject.AddComponent<Source>();
        Selection.activeGameObject = gameobject;
    }
    public override void OnInspectorGUI()
    {
        //进行数据交互之前必须调用target
        source = (Source)target;
        logo = (Texture2D)Resources.Load("");
        scrollPos = EditorGUILayout.BeginScrollView(scrollPos);
        {
            
            GUIContent btnTxt = new GUIContent(logo);
            var rt = GUILayoutUtility.GetRect(btnTxt, GUI.skin.label, GUILayout.ExpandWidth(false));

            //设置一个编辑模块
            rt.center = new Vector2(EditorGUIUtility.currentViewWidth / 2, rt.center.y);

            GUI.Button(rt, btnTxt, GUI.skin.label);
            
            EditorGUILayout.LabelField("选取水源源点 --- 在地形上单机鼠标左键");
            EditorGUI.indentLevel++;

            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("Point:");
            source.S = EditorGUILayout.Vector3Field("", source.S);
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.BeginHorizontal();
            source.Add= EditorGUILayout.FloatField("在源点处增加水量值", source.Add);
            if (GUILayout.Button(new GUIContent("增加水量", "")))
            {
                source.GetHeightMaps();
                source.AddWater();
            }
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button(new GUIContent("进行1单位时间", "")))
            {
                source.DoWork(1);
            }
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button(new GUIContent("进行100单位时间", "")))
            {
                source.DoWork(100);
            }
            EditorGUILayout.EndHorizontal();




        }
        EditorGUILayout.EndScrollView();
        
        

    }
    protected virtual void OnSceneGUI()
    {
        int controlId = GUIUtility.GetControlID(FocusType.Passive);
        if(source!=null)
        {
            if(IsHave==true)
            {
                EditorGUI.BeginChangeCheck();
                Handles.color = new Color32(147, 225, 58, 255);
                Vector3 handlePos = (Vector3)source.S + source.transform.position;
                if (Tools.current == Tool.Move)
                {
                    float size = 0.6f;

                    Handles.color = Handles.xAxisColor;
                    Vector3 pos = Handles.Slider((Vector3)source.S + source.transform.position, Vector3.right, HandleUtility.GetHandleSize(handlePos) * size, Handles.ArrowHandleCap, 0.01f) - source.transform.position;

                    pos = Handles.Slider((Vector3)pos + source.transform.position, Vector3.up, HandleUtility.GetHandleSize(handlePos) * size, Handles.ArrowHandleCap, 0.01f) - source.transform.position;

                    pos = Handles.Slider((Vector3)pos + source.transform.position, Vector3.forward, HandleUtility.GetHandleSize(handlePos) * size, Handles.ArrowHandleCap, 0.01f) - source.transform.position;

                    source.S = pos;
                }
                if (Tools.current == Tool.Scale)
                {
                    Handles.color = Color.red;
                    Vector3 pos = source.S;
                    source.S = pos;
                }

                if (EditorGUI.EndChangeCheck())
                {
                    Undo.RecordObject(source, "Change Position");
                }
            }
        }
        //监听鼠标和crtl键是否同时按下，如果是，得到shaded中的那个点、
        if (Event.current.type == EventType.MouseDown && Event.current.button == 0 && Event.current.control)
        {
            if(IsHave==false)
            {
                Vector3 screenPosition = Event.current.mousePosition;
                screenPosition.y = Camera.current.pixelHeight - screenPosition.y;
                Ray ray = Camera.current.ScreenPointToRay(screenPosition);
                RaycastHit hit;

                if (Physics.Raycast(ray, out hit))
                {
                    Undo.RecordObject(source, "Add point");

                    Vector3 position = hit.point - source.transform.position;
                    source.GetPoint(position);

                    GUIUtility.hotControl = controlId;
                    Event.current.Use();
                    HandleUtility.Repaint();
                }
                IsHave = true;
            }
            
        }
        if (Event.current.type == EventType.MouseUp && Event.current.button == 0 && Event.current.control)
        {
            GUIUtility.hotControl = 0;
        }
    }

}

```

在代码结果进行运行的时候，遇到的两个小问题：

1.地形越大，进行的速度越慢。

2.这个问题稍微有些致命，莫名其妙的，好像一个点的水，一定可以向四周进行扩散一样。

3.需要加速运行，也就是运输水量的速度可以稍微调参变大一些，具体内容自行进行改动。

那么我们首先围绕第一点和第二点进行优化和改进。

过程代码记录：

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Source : MonoBehaviour
{

    const double eps = 0.01;

    Mesh mesh;
    //管道横截面积
    private float A = 1;
    //重力加速度
    private float g = 9.8f;
    //管道长度
    private float l = 1;

    //格点间距，按道理来讲不应该设定为1
    private float lx = 1;
    private float ly = 1;

    //增加的水量
    public float Add;

    //源点
    public Vector3 S;

    //高度图b
    private float[,] heightmaps;
    //水高图d
    private float[,] waterheightmaps = new float[600, 600];

    //流量图F 0上，1下，2左 3右 
    private float[,,] F = new float[600, 600, 5];
    private bool[,] IsDown = new bool[600, 600];

    //关于地形的信息
    TerrainData terraindata;
    int width;
    int length;
    int heightResolution;
    int realwidth;
    int reallength;
    int realheight;
    public void AddWater()
    {
        int tx = GetiX(S);
        int tz = GetiZ(S);
        waterheightmaps[tz, tx] += GetiY(Add);
        Add = 0;
        print("YES");
        DrawMesh();
    }
    public void GetHeightMaps()
    {
        print("Yes");
        Terrain terrain = Terrain.activeTerrain;
        terraindata = terrain.terrainData;
        print("Yes");
        width = terraindata.heightmapWidth;
        length = terraindata.heightmapHeight;
        heightmaps = terraindata.GetHeights(0, 0, width, length);
        heightResolution = terraindata.heightmapResolution;
        realwidth = (int)terraindata.size.x;
        realheight = (int)terraindata.size.y;
        reallength = (int)terraindata.size.z;

        print(realwidth + "    " + reallength + "     " + realheight + "     " + heightResolution);
        print(width + "       " + length);
    }
    public void GetPoint(Vector3 pos)
    {
        S = pos;
    }
    public void DoWork(int tim)
    {
        //流量图F 0右，1左，2上 3下 
        int[] fx = { -1, 1, 0, 0 };
        int[] fz = { 0, 0, -1, 1 };
        /*
        for(int i=0;i<4;i++)
        {
            print("原来一开始周边地形的高度：" + getY(heightmaps[GetiX(S) + fx[i], GetiZ(S) + fz[i]]));
        }
        */
        for (int z = 0; z < tim; z++)
        {
            float dertat = 1f;
            //第一次遍历整个图，来进行水通量的计算。
            for (int i = 0; i < width; i++)
            {
                for (int j = 0; j < length; j++)
                {
                    for (int k = 0; k < 4; k++) F[j, i, k] = 0;
                    if (getY(waterheightmaps[j, i]) <= eps) continue;
                    for (int k = 0; k < 4; k++)
                    {
                        int ni = i + fx[k];
                        int nj = i + fz[k];
                        if (ni >= 0 && ni < width && nj >= 0 && nj < length)
                        {
                            //计算流通量的过程用在真实环境中的地形高度来决定。
                            float CH = getY(heightmaps[j, i] + waterheightmaps[j, i]) - getY(heightmaps[nj, ni] + waterheightmaps[nj, ni]);
                            if (getY(heightmaps[j, i] + waterheightmaps[j, i]) - getY(heightmaps[nj, ni] + waterheightmaps[nj, ni]) <= eps)
                            {
                                F[j, i, k] = 0;
                                continue;
                            }
                            F[j, i, k] = Mathf.Max(0, F[j, i, k] + dertat * A * g * CH / l);
                            if (F[j, i, k] < 0) F[j, i, k] = 0;
                            
                        }
                    }
                    //计算流动系数
                    float K = Mathf.Min(1, getY(waterheightmaps[j, i]) * lx * ly / ((F[j, i, 0] + F[j, i, 1] + F[j, i, 2] + F[j, i, 3]+0.001f) * dertat));
                    for (int k = 0; k < 4; k++)
                    {
                        F[j, i, k] = F[j, i, k] * K;
                       // print("方向:" + k + "流通值" + F[j, i, k]);
                    }
                }
            }
            //第二次遍历整个图，去计算每个点最终变化的情况
            for (int i = 0; i < width; i++)
            {
                for (int j = 0; j < length; j++)
                {
                    if (i - 1 >= 0 && i - 1 < width && i + 1 >= 0 && i + 1 < width && j - 1 >= 0 && j - 1 < length && j + 1 >= 0 && j + 1 < length)
                    {
                        float Tot = dertat * ((F[j - 1, i, 3] + F[j + 1, i, 2] + F[j, i - 1, 1] + F[j, i + 1, 0]) - (F[j, i, 0] + F[j, i, 1] + F[j, i, 2] + F[j, i, 3]));
                        waterheightmaps[j, i] = waterheightmaps[j, i] + GetiY(Tot / (lx * ly));
                        if (getY(waterheightmaps[j, i]) <= eps) waterheightmaps[j, i] = 0;
                    }
                }
            }
        }
        /*
        int Countcnt = 0;
        for (int i = 0; i < width; i++)
        {
            for (int j = 0; j < length; j++)
            {
                if (getY(waterheightmaps[j, i] )<=eps) continue;
                print("waterHeightmaps:" +  getY(waterheightmaps[j, i])+"    :"+waterheightmaps[j,i]);
                Countcnt++;
            }
        }*/
        int tx = GetiX(S);
        int tz = GetiZ(S);
        float ty = GetiY(waterheightmaps[tz, tx]);
        print("S:" + ty);
        //print("CountCnt:" + Countcnt);
        /*
        for (int i = 0; i < width; i++) 
        {
            for (int j = 0; j < length; j++) 
            {
                if (waterheightmaps[j, i] <= eps) continue;
                else
                {
                    if(IsDown[j,i]==false)
                    {
                        print("Donw");
                        IsDown[j, i] = true;
                        heightmaps[j, i] -= 0.02f;
                    }
                }
            }
        }
        */
        DrawMesh();
    }
    public void DrawMesh()
    {
        Vector2[] UV = new Vector2[10500000];
        Vector3[] vp3 = new Vector3[10500000];
        int[] array = new int[10500000];
        int cnt, cnt1, cnt2;
        cnt2 = cnt1 = cnt = 0;
        mesh = gameObject.GetComponent<MeshFilter>().mesh;
        mesh.Clear();
        for (int i = 0; i < width; i++)
        {
            for (int j = 0; j < length; j++)
            {
                if (getY(waterheightmaps[j, i]) <= eps) continue;
                
                Vector3 one = new Vector3(getX(i), getY(heightmaps[j, i]) + 0.05f, getZ(j));
                Vector3 two = new Vector3(getX(i), getY(heightmaps[j + 1, i]) + 0.05f, getZ(j + 1));
                Vector3 three = new Vector3(getX(i + 1), getY(heightmaps[j + 1, i +1]) + 0.05f, getZ(j + 1));
                Vector3 fore = new Vector3(getX(i + 1), getY(heightmaps[j, i +1]) + 0.05f, getZ(j));
                
                Vector3 five = new Vector3(getX(i), getY(heightmaps[j, i] + waterheightmaps[j, i]) + 0.05f, getZ(j));
                Vector3 six = new Vector3(getX(i), getY(heightmaps[j + 1, i] + waterheightmaps[j, i]) + 0.05f, getZ(j + 1));
                Vector3 seven = new Vector3(getX(i + 1), getY(heightmaps[j + 1, i + 1] + waterheightmaps[j, i]) + 0.05f, getZ(j + 1));
                Vector3 eight = new Vector3(getX(i + 1), getY(heightmaps[j, i + 1] + waterheightmaps[j, i]) + 0.05f, getZ(j));
                /*
                print("Mesh:" + getY(heightmaps[j, i] + waterheightmaps[j, i]) + 0.05f);

                print("Mesh:" + getY(heightmaps[j + 1, i] + waterheightmaps[j, i]) + 0.05f);

                print("Mesh:" +  getY(heightmaps[j + 1, i - 1] + waterheightmaps[j, i]) + 0.05f);

                print("Mesh:" + getY(heightmaps[j, i - 1] + waterheightmaps[j, i]) + 0.05f);

                */
                UV[cnt++] = new Vector2(one.x, one.y);
                UV[cnt++] = new Vector2(two.x, two.y);
                UV[cnt++] = new Vector2(three.x, three.y);
                UV[cnt++] = new Vector2(fore.x, fore.y);
                
                UV[cnt++] = new Vector2(five.x, five.y);
                UV[cnt++] = new Vector2(six.x, six.y);
                UV[cnt++] = new Vector2(seven.x, seven.y);
                UV[cnt++] = new Vector2(eight.x, eight.y);
                
                vp3[cnt1++] = one;
                vp3[cnt1++] = two;
                vp3[cnt1++] = three;
                vp3[cnt1++] = fore;
                
                vp3[cnt1++] = five;
                vp3[cnt1++] = six;
                vp3[cnt1++] = seven;
                vp3[cnt1++] = eight;
                
                //1 2 3 4
                array[cnt2++] = cnt1 - 8;
                array[cnt2++] = cnt1 - 7;
                array[cnt2++] = cnt1 - 6;

                array[cnt2++] = cnt1 - 6;
                array[cnt2++] = cnt1 - 7;
                array[cnt2++] = cnt1 - 8;
                
                array[cnt2++] = cnt1 - 8;
                array[cnt2++] = cnt1 - 6;
                array[cnt2++] = cnt1 - 5;

                array[cnt2++] = cnt1 - 5;
                array[cnt2++] = cnt1 - 6;
                array[cnt2++] = cnt1 - 8;
                
                //5 6 7 8
                array[cnt2++] = cnt1 - 4;
                array[cnt2++] = cnt1 - 3;
                array[cnt2++] = cnt1 - 2;

                array[cnt2++] = cnt1 - 2;
                array[cnt2++] = cnt1 - 3;
                array[cnt2++] = cnt1 - 4;
                
                array[cnt2++] = cnt1 - 4;
                array[cnt2++] = cnt1 - 2;
                array[cnt2++] = cnt1 - 1;

                array[cnt2++] = cnt1 - 1;
                array[cnt2++] = cnt1 - 2;
                array[cnt2++] = cnt1 - 4;

                //6 5 2 1

                array[cnt2++] = cnt1 - 3;
                array[cnt2++] = cnt1 - 4;
                array[cnt2++] = cnt1 - 7;

                array[cnt2++] = cnt1 - 7;
                array[cnt2++] = cnt1 - 4;
                array[cnt2++] = cnt1 - 3;

                array[cnt2++] = cnt1 - 8;
                array[cnt2++] = cnt1 - 7;
                array[cnt2++] = cnt1 - 3;

                //7 6 3 2

                array[cnt2++] = cnt1 - 2;
                array[cnt2++] = cnt1 - 3;
                array[cnt2++] = cnt1 - 6;

                array[cnt2++] = cnt1 - 6;
                array[cnt2++] = cnt1 - 3;
                array[cnt2++] = cnt1 - 2;

                array[cnt2++] = cnt1 - 2;
                array[cnt2++] = cnt1 - 6;
                array[cnt2++] = cnt1 - 7;

                array[cnt2++] = cnt1 - 7;
                array[cnt2++] = cnt1 - 6;
                array[cnt2++] = cnt1 - 2;

                //8 7 4 3
                array[cnt2++] = cnt1 - 1;
                array[cnt2++] = cnt1 - 2;
                array[cnt2++] = cnt1 - 5;

                array[cnt2++] = cnt1 - 5;
                array[cnt2++] = cnt1 - 2;
                array[cnt2++] = cnt1 - 1;

                array[cnt2++] = cnt1 - 1;
                array[cnt2++] = cnt1 - 5;
                array[cnt2++] = cnt1 - 6;

                array[cnt2++] = cnt1 - 6;
                array[cnt2++] = cnt1 - 5;
                array[cnt2++] = cnt1 - 1;

                //8 5 4 2

                array[cnt2++] = cnt1 - 1;
                array[cnt2++] = cnt1 - 4;
                array[cnt2++] = cnt1 - 5;

                array[cnt2++] = cnt1 - 5;
                array[cnt2++] = cnt1 - 4;
                array[cnt2++] = cnt1 - 1;

                array[cnt2++] = cnt1 - 1;
                array[cnt2++] = cnt1 - 5;
                array[cnt2++] = cnt1 - 7;

                array[cnt2++] = cnt1 - 7;
                array[cnt2++] = cnt1 - 5;
                array[cnt2++] = cnt1 - 1;



            }
        }
        print(cnt + "     " + cnt1 + "     " + cnt2);
        Vector2[] uv = new Vector2[cnt];
        Vector3[] vp = new Vector3[cnt1];
        int[] arrray = new int[cnt2];
        for (int i = 0; i < cnt; i++) uv[i] = UV[i];
        for (int i = 0; i < cnt1; i++) vp[i] = vp3[i];
        for (int i = 0; i < cnt2; i++) arrray[i] = array[i];
        mesh.vertices = vp;
        mesh.uv = uv;
        mesh.triangles = arrray;
    }

    int GetiX(Vector3 P)
    {
        float Bilv1 = (float)(heightResolution) / (float)(realwidth);
        int tx = (int)(P.x * Bilv1);
        return tx;
    }
    int GetiZ(Vector3 P)
    {
        float Bilv2 = (float)(heightResolution) / (float)(reallength);
        int tz = (int)(P.z * Bilv2);
        return tz;
    }
    float GetiY(float y)
    {
        float Bilv3 = 1.0f / (float)(realheight);
        float ty = y * Bilv3;
        return ty;
    }
    float getX(float x)
    {
        return (float)(x) * (float)(realwidth) / (float)(heightResolution);
    }
    float getY(float y)
    {
        return (float)(y) * (float)(realheight);
    }
    float getZ(float z)
    {
        return (float)(z) * (float)(reallength) / (float)(heightResolution);
    }
}


```

没有基于地形水力侵蚀的代码：

```C#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Source : MonoBehaviour
{

    const double eps = 0.0001;

    Mesh mesh;
    //管道横截面积
    private float A = 1;
    //重力加速度
    private float g = 9.8f;
    //管道长度
    private float l = 1;

    //格点间距，按道理来讲不应该设定为1
    private float lx = 1;
    private float ly = 1;

    //增加的水量
    public float Add;

    //源点
    public Vector3 S;

    //高度图b
    private float[,] heightmaps;
    //水高图d
    private float[,] waterheightmaps = new float[600, 600];

    //流量图F 0上，1下，2左 3右 
    private float[,,] F = new float[600, 600, 5];
    private bool[,] IsDown = new bool[600, 600];

    //关于地形的信息
    TerrainData terraindata;
    int width;
    int length;
    int heightResolution;
    int realwidth;
    int reallength;
    int realheight;
    public void AddWater()
    {
        int tx = GetiX(S);
        int tz = GetiZ(S);
        waterheightmaps[tz, tx] += GetiY(Add);
        Add = 0;
        print("YES");
        DrawMesh();
    }
    public void GetHeightMaps()
    {
        print("Yes");
        Terrain terrain = Terrain.activeTerrain;
        terraindata = terrain.terrainData;
        print("Yes");
        width = terraindata.heightmapWidth;
        length = terraindata.heightmapHeight;
        heightmaps = terraindata.GetHeights(0, 0, width, length);
        heightResolution = terraindata.heightmapResolution;
        realwidth = (int)terraindata.size.x;
        realheight = (int)terraindata.size.y;
        reallength = (int)terraindata.size.z;

        print(realwidth + "    " + reallength + "     " + realheight + "     " + heightResolution);
        print(width + "       " + length);
    }
    public void GetPoint(Vector3 pos)
    {
        S = pos;
    }
    public void DoWork(int tim)
    {
        //流量图F 0右，1左，2上 3下 
        int[] fx = { -1, 1, 0, 0 };
        int[] fz = { 0, 0, -1, 1 };
        for (int z = 0; z < tim; z++)
        {
            float dertat = 1f;
            //第一次遍历整个图，来进行水通量的计算。
            for (int i = 0; i < width; i++)
            {
                for (int j = 0; j < length; j++)
                {
                    for (int k = 0; k < 4; k++) F[j, i, k] = 0;
                    if (getY(waterheightmaps[j, i]) <= eps) continue;
                    for (int k = 0; k < 4; k++)
                    {
                        int ni = i + fx[k];
                        int nj = j + fz[k];
                        if (ni >= 0 && ni < width && nj >= 0 && nj < length)
                        {
                            //计算流通量的过程用在真实环境中的地形高度来决定。
                            float CH = getY(heightmaps[j, i] + waterheightmaps[j, i]) - getY(heightmaps[nj, ni] + waterheightmaps[nj, ni]);
                            if (getY(heightmaps[j, i] + waterheightmaps[j, i]) - getY(heightmaps[nj, ni] + waterheightmaps[nj, ni]) <= eps)
                            {
                                F[j, i, k] = 0;
                                continue;
                            }
                            F[j, i, k] = Mathf.Max(0, F[j, i, k] + dertat * A * g * CH / l);
                            if (F[j, i, k] < 0) F[j, i, k] = 0;
                            
                        }
                    }
                    //计算流动系数
                    float K = Mathf.Min(0.9f, getY(waterheightmaps[j, i]) * lx * ly / ((F[j, i, 0] + F[j, i, 1] + F[j, i, 2] + F[j, i, 3]+4f) * dertat));
                    for (int k = 0; k < 4; k++)
                    {
                        F[j, i, k] = F[j, i, k] * K;
                       // print("方向:" + k + "流通值" + F[j, i, k]);
                    }
                }
            }
            //第二次遍历整个图，去计算每个点最终变化的情况
            for (int i = 0; i < width; i++)
            {
                for (int j = 0; j < length; j++)
                {
                    if (i - 1 >= 0 && i - 1 < width && i + 1 >= 0 && i + 1 < width && j - 1 >= 0 && j - 1 < length && j + 1 >= 0 && j + 1 < length)
                    {
                        float Tot = dertat * ((F[j - 1, i, 3] + F[j + 1, i, 2] + F[j, i - 1, 1] + F[j, i + 1, 0]) - (F[j, i, 0] + F[j, i, 1] + F[j, i, 2] + F[j, i, 3]));
                        waterheightmaps[j, i] = waterheightmaps[j, i] + GetiY(Tot / (lx * ly));
                        if (getY(waterheightmaps[j, i]) <= eps) waterheightmaps[j, i] = 0;
                    }
                }
            }
        }
        DrawMesh();
    }
    public void DrawMesh()
    {
        Vector2[] UV = new Vector2[10500000];
        Vector3[] vp3 = new Vector3[10500000];
        int[] array = new int[10500000];
        int cnt, cnt1, cnt2;
        cnt2 = cnt1 = cnt = 0;
        mesh = gameObject.GetComponent<MeshFilter>().mesh;
        mesh.Clear();
        for (int i = 0; i < width; i++)
        {
            for (int j = 0; j < length; j++)
            {
                if (getY(waterheightmaps[j, i]) <= eps) continue;
                
                Vector3 one = new Vector3(getX(i), getY(heightmaps[j, i]) + 0.05f, getZ(j));
                Vector3 two = new Vector3(getX(i), getY(heightmaps[j + 1, i]) + 0.05f, getZ(j + 1));
                Vector3 three = new Vector3(getX(i + 1), getY(heightmaps[j + 1, i +1]) + 0.05f, getZ(j + 1));
                Vector3 fore = new Vector3(getX(i + 1), getY(heightmaps[j, i +1]) + 0.05f, getZ(j));
                
                Vector3 five = new Vector3(getX(i), getY(heightmaps[j, i] + waterheightmaps[j, i]) + 0.05f, getZ(j));
                Vector3 six = new Vector3(getX(i), getY(heightmaps[j + 1, i] + waterheightmaps[j, i]) + 0.05f, getZ(j + 1));
                Vector3 seven = new Vector3(getX(i + 1), getY(heightmaps[j + 1, i + 1] + waterheightmaps[j, i]) + 0.05f, getZ(j + 1));
                Vector3 eight = new Vector3(getX(i + 1), getY(heightmaps[j, i + 1] + waterheightmaps[j, i]) + 0.05f, getZ(j));
                /*
                print("Mesh:" + getY(heightmaps[j, i] + waterheightmaps[j, i]) + 0.05f);

                print("Mesh:" + getY(heightmaps[j + 1, i] + waterheightmaps[j, i]) + 0.05f);

                print("Mesh:" +  getY(heightmaps[j + 1, i - 1] + waterheightmaps[j, i]) + 0.05f);

                print("Mesh:" + getY(heightmaps[j, i - 1] + waterheightmaps[j, i]) + 0.05f);

                */
                UV[cnt++] = new Vector2(one.x, one.y);
                UV[cnt++] = new Vector2(two.x, two.y);
                UV[cnt++] = new Vector2(three.x, three.y);
                UV[cnt++] = new Vector2(fore.x, fore.y);
                
                UV[cnt++] = new Vector2(five.x, five.y);
                UV[cnt++] = new Vector2(six.x, six.y);
                UV[cnt++] = new Vector2(seven.x, seven.y);
                UV[cnt++] = new Vector2(eight.x, eight.y);
                
                vp3[cnt1++] = one;
                vp3[cnt1++] = two;
                vp3[cnt1++] = three;
                vp3[cnt1++] = fore;
                
                vp3[cnt1++] = five;
                vp3[cnt1++] = six;
                vp3[cnt1++] = seven;
                vp3[cnt1++] = eight;
                
                //1 2 3 4
                array[cnt2++] = cnt1 - 8;
                array[cnt2++] = cnt1 - 7;
                array[cnt2++] = cnt1 - 6;

                array[cnt2++] = cnt1 - 6;
                array[cnt2++] = cnt1 - 7;
                array[cnt2++] = cnt1 - 8;
                
                array[cnt2++] = cnt1 - 8;
                array[cnt2++] = cnt1 - 6;
                array[cnt2++] = cnt1 - 5;

                array[cnt2++] = cnt1 - 5;
                array[cnt2++] = cnt1 - 6;
                array[cnt2++] = cnt1 - 8;
                
                //5 6 7 8
                array[cnt2++] = cnt1 - 4;
                array[cnt2++] = cnt1 - 3;
                array[cnt2++] = cnt1 - 2;

                array[cnt2++] = cnt1 - 2;
                array[cnt2++] = cnt1 - 3;
                array[cnt2++] = cnt1 - 4;
                
                array[cnt2++] = cnt1 - 4;
                array[cnt2++] = cnt1 - 2;
                array[cnt2++] = cnt1 - 1;

                array[cnt2++] = cnt1 - 1;
                array[cnt2++] = cnt1 - 2;
                array[cnt2++] = cnt1 - 4;

                //6 5 2 1

                array[cnt2++] = cnt1 - 3;
                array[cnt2++] = cnt1 - 4;
                array[cnt2++] = cnt1 - 7;

                array[cnt2++] = cnt1 - 7;
                array[cnt2++] = cnt1 - 4;
                array[cnt2++] = cnt1 - 3;

                array[cnt2++] = cnt1 - 8;
                array[cnt2++] = cnt1 - 7;
                array[cnt2++] = cnt1 - 3;

                //7 6 3 2

                array[cnt2++] = cnt1 - 2;
                array[cnt2++] = cnt1 - 3;
                array[cnt2++] = cnt1 - 6;

                array[cnt2++] = cnt1 - 6;
                array[cnt2++] = cnt1 - 3;
                array[cnt2++] = cnt1 - 2;

                array[cnt2++] = cnt1 - 2;
                array[cnt2++] = cnt1 - 6;
                array[cnt2++] = cnt1 - 7;

                array[cnt2++] = cnt1 - 7;
                array[cnt2++] = cnt1 - 6;
                array[cnt2++] = cnt1 - 2;

                //8 7 4 3
                array[cnt2++] = cnt1 - 1;
                array[cnt2++] = cnt1 - 2;
                array[cnt2++] = cnt1 - 5;

                array[cnt2++] = cnt1 - 5;
                array[cnt2++] = cnt1 - 2;
                array[cnt2++] = cnt1 - 1;

                array[cnt2++] = cnt1 - 1;
                array[cnt2++] = cnt1 - 5;
                array[cnt2++] = cnt1 - 6;

                array[cnt2++] = cnt1 - 6;
                array[cnt2++] = cnt1 - 5;
                array[cnt2++] = cnt1 - 1;

                //8 5 4 2

                array[cnt2++] = cnt1 - 1;
                array[cnt2++] = cnt1 - 4;
                array[cnt2++] = cnt1 - 5;

                array[cnt2++] = cnt1 - 5;
                array[cnt2++] = cnt1 - 4;
                array[cnt2++] = cnt1 - 1;

                array[cnt2++] = cnt1 - 1;
                array[cnt2++] = cnt1 - 5;
                array[cnt2++] = cnt1 - 7;

                array[cnt2++] = cnt1 - 7;
                array[cnt2++] = cnt1 - 5;
                array[cnt2++] = cnt1 - 1;



            }
        }
        print(cnt + "     " + cnt1 + "     " + cnt2);
        Vector2[] uv = new Vector2[cnt];
        Vector3[] vp = new Vector3[cnt1];
        int[] arrray = new int[cnt2];
        for (int i = 0; i < cnt; i++) uv[i] = UV[i];
        for (int i = 0; i < cnt1; i++) vp[i] = vp3[i];
        for (int i = 0; i < cnt2; i++) arrray[i] = array[i];
        mesh.vertices = vp;
        mesh.uv = uv;
        mesh.triangles = arrray;
    }

    int GetiX(Vector3 P)
    {
        float Bilv1 = (float)(heightResolution) / (float)(realwidth);
        int tx = (int)(P.x * Bilv1);
        return tx;
    }
    int GetiZ(Vector3 P)
    {
        float Bilv2 = (float)(heightResolution) / (float)(reallength);
        int tz = (int)(P.z * Bilv2);
        return tz;
    }
    float GetiY(float y)
    {
        float Bilv3 = 1.0f / (float)(realheight);
        float ty = y * Bilv3;
        return ty;
    }
    float getX(float x)
    {
        return (float)(x) * (float)(realwidth) / (float)(heightResolution);
    }
    float getY(float y)
    {
        return (float)(y) * (float)(realheight);
    }
    float getZ(float z)
    {
        return (float)(z) * (float)(reallength) / (float)(heightResolution);
    }
}

```











