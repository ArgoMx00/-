近期的任务就是将第一部分任务“创建河流”的基本问题搞定。
功能描述：

①摄像机通过键盘输入控制移动。

②鼠标通过点选河流路径，生成一条简单河床并生成水域，水要求是流体的。可以按照有规律的去运动。不用规定特殊方向和速度之类的。

一、今天我们尝试一下将水动起来。

因为是编码完成水流动态效果 ，所以真正做到水流动的那种效果暂时还是做不到的，我们先完成一个按照Cos值波动的的波浪。

①我们继续继承之前的做法，由面来组成每个小小的部分，每个部分组合在一起打成波面的效果即可。

②我们按照Cos拨动的值来模拟一下水波流动的感觉，然后通过Mesh将其改变出来即可。

代码如下：

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Shape_Update2 : MonoBehaviour {

    Mesh mesh;
    //x轴长度
    int length = 35;
    //z轴长度
    int width = 25;
    //水波高度
    float RiverHeight = 3f;
    //总运行时间
    float Tottime;
    private void Start()
    {
        Tottime = 0;
    }
    private void Update()
    {
        BuildMoveRiver(Time.deltaTime+Tottime);
        Tottime += Time.deltaTime;
    }
    void BuildMoveRiver(float StartTime)
    {
        float now = StartTime*100;
        int cnt1, cnt2;
        cnt1 = cnt2 = 0;
        Vector3[] vp3 = new Vector3[100000];
        int[] array = new int[100000];
        for(int i=0;i<length-1;i++)
        {
            //创建波浪
            Vector3 one = new Vector3(i,0,width);
            Vector3 two = new Vector3(i, 0, 0);
            Vector3 three = new Vector3(i + 1, 0, width);
            Vector3 fore = new Vector3(i + 1, 0, 0);
            one.y += Mathf.Cos(now*Mathf.PI/180)*RiverHeight;
            two.y += Mathf.Cos(now * Mathf.PI / 180)*RiverHeight;
            three.y += Mathf.Cos((now + 30) * Mathf.PI / 180)*RiverHeight;
            fore.y += Mathf.Cos((now + 30) * Mathf.PI / 180)*RiverHeight;
            vp3[cnt1++] = one;
            vp3[cnt1++] = two;
            vp3[cnt1++] = three;
            vp3[cnt1++] = fore;
            array[cnt2++] = cnt1 - 4;
            array[cnt2++] = cnt1 - 3;
            array[cnt2++] = cnt1 - 1;

            array[cnt2++] = cnt1 - 1;
            array[cnt2++] = cnt1 - 3;
            array[cnt2++] = cnt1 - 4;

            array[cnt2++] = cnt1 - 4;
            array[cnt2++] = cnt1 - 1;
            array[cnt2++] = cnt1 - 2;

            array[cnt2++] = cnt1 - 2;
            array[cnt2++] = cnt1 - 1;
            array[cnt2++] = cnt1 - 4;
            now += 30;

        }
        print(StartTime+ "   " +cnt1 + "  " + cnt2);
        Vector3[] vvp3 = new Vector3[cnt1];
        int[] arrray = new int[cnt2];
        for(int i=0;i<cnt1;i++)
        {
            vvp3[i] = vp3[i];
        }
        for(int i=0;i<cnt2;i++)
        {
            arrray[i] = array[i];
        }



        mesh = gameObject.GetComponent<MeshFilter>().mesh;
        mesh.Clear();
        mesh.vertices = vvp3;
        mesh.triangles = arrray;
    }
}

···

实际效果图（实际肯定是动起来的,截图只能放几张效果，作为记录即可）：

![](https://i.loli.net/2018/06/06/5b177b58dab6b.png) ![]https://i.loli.net/2018/06/06/5b177b79d1a99.png




